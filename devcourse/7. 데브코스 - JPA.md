# 7. 데브코스 - JPA

## 스프링 웹 어플리케이션의 데이터 저장 계층

- 자바 애플리케이션은 JDBC API를 이용하여 데이터계층과 통신함



### JDBC 예제

```java
@Slf4j
public class JDBCTest {

    static final String JDBC_DRIVER = "org.h2.Driver";
    static final String DB_URL = "jdbc:h2:~/test";
    static final String USER = "sa";
    static final String PASSWORD = "";

    static final String DROP_TABLE_SQL = "DROP TABLE customers IF EXISTS";
    static final String CREATE_TABLE_SQL = "CREATE TABLE customers(id SERIAL, first_name VARCHAR(255), last_name VARCHAR(255))";
    static final String INSERT_SQL = "INSERT INTO customers (id, first_name, last_name) VALUES(1, 'honggu', 'kang')";

    @Test
    void jdbc_sample() {
        try {
            Class.forName(JDBC_DRIVER);
            Connection con = DriverManager.getConnection(DB_URL, USER, PASSWORD);
            log.info("GET CONNECTION");

            Statement stmt = con.createStatement();
            stmt.executeUpdate(DROP_TABLE_SQL);
            stmt.executeUpdate(CREATE_TABLE_SQL);
            log.info("CREATED TABLE");

            stmt.executeUpdate(INSERT_SQL);
            log.info("INSERTED CUSTOMER INFORMATION");

            ResultSet rs = stmt.executeQuery("SELECT * FROM customers WHERE id = 1");

            while(rs.next()) {
                String fullName = rs.getString("first_name") + " " + rs.getString("last_name");
                log.info("CUSTOMER FULL_NAME = {}", fullName);
            }

            rs.close();
            stmt.close();
            con.close();
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}
```

- 지나치게 번잡하다!

- 이를 해결하기 위해 스프링은 JDBC Template 제공

  ```java
  @SpringBootTest
  ...
      @Test
      void jdbcTemplate_sample() {
          jdbcTemplate.update(DROP_TABLE_SQL);
          jdbcTemplate.update(CREATE_TABLE_SQL);
          log.info("CREATED TABLE USING JDBC TEMPLATE");
  
          jdbcTemplate.update(INSERT_SQL);
          log.info("INSERTED CUSTOMER INFORMATION USING JDBC TEMPLATE");
  
          String fullName = jdbcTemplate.queryForObject(
                  "SELECT * FROM customers WHERE id = 1",
                  (rs, i) -> rs.getString("first_name") + " " + rs.getString("last_name")
          );
          log.info("FULL_NAME = {}", fullName);
      }
  ```

  - JDBC Template은 JDBC 직접 사용보다는 낫지만 자바 코드와 쿼리가 뒤섞인다는 문제는 해결되지 않음

- Mybatis(QueryMapper)

  - 자바 코드와 쿼리를 분리

  - 쿼리 수정으로 자버 코드 수정이나 컴파일 하는 작업을 거치지 않아도 됨

  - 애노테이션, xml 중 하나 이용해서 쿼리 등록

  - `application.yml`

    ```yaml
    spring:
      datasource:
        driver-class-name: org.h2.Driver
        url: jdbc:h2:~/test
        username: sa
        password:
    # https://mybatis.org/spring-boot-starter/mybatis-spring-boot-autoconfigure
    mybatis:
      type-aliases-package: org.programmers.springdao.domain
      configuration:
        map-underscore-to-camel-case: true
        default-fetch-size: 100
        default-statement-timeout: 30
      mapper-locations: classpath:mapper/*.xml
    ```

    - `type-aliases-package: org.programmers.springdao.domain`
      - Mybatis는 resultSet을 자바 객체에 매핑해줌, 매핑될 객체의 위치
    - `map-underscore-to-camel-case: true`
      - `first_name -> firstName` 식으로 매핑
    - `  mapper-locations: classpath:mapper/*.xml`: 쿼리를 관리할 위치

- `CustomerMapper.xml`

  ```xml
  <?xml version="1.0" encoding="UTF-8"?>
  <!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd">
  <mapper namespace="org.programmers.springdao.repository.CustomerXmlMapper">
      <insert id="save">
          INSERT INTO customers (id, first_name, last_name)
          VALUES (#{id}, #{firstName}, #{lastName})
      </insert>
  
      <update id="update">
          UPDATE customers
          SET first_name=#{firstName},
              last_name=#{lastName}
          WHERE id = #{id}
      </update>
  
      <select id="findById" resultType="customers">
          SELECT *
          FROM customers
          WHERE id = #{id}
      </select>
  
      <select id="findAll" resultType="customers">
          SELECT *
          FROM customers
      </select>
  </mapper>
  ```

  - id값으로 정의된 것이 인터페이스의 메서드와 매핑됨

- `Customer`

  ```java
  @Alias("customers")
  @AllArgsConstructor
  @Getter
  public class Customer {
      private long id;
      private String firstName;
      private String lastName;
  
      public void setId(long id) {
          this.id = id;
      }
  
      public void setFirstName(String firstName) {
          this.firstName = firstName;
      }
  
      public void setLastName(String lastName) {
          this.lastName = lastName;
      }
  }
  ```

  - `@Alias`
  - Mybatis는 Getter/Setter 기반 동작

- `CustomerXmlMapper`

  ```java
  @Mapper
  public interface CustomerXmlMapper {
      void save(Customer customer);
      Customer findById(long id);
  }
  ```

- 사용 코드

  ```java
  @Slf4j
  @SpringBootTest
  public class MybatisTest {
  
      static final String DROP_TABLE_SQL = "DROP TABLE customers IF EXISTS";
      static final String CREATE_TABLE_SQL = "CREATE TABLE customers(id SERIAL, first_name VARCHAR(255), last_name VARCHAR(255))";
  
      @Autowired
      JdbcTemplate jdbcTemplate;
  
      @Autowired
      CustomerXmlMapper customerMapper;
  
      @Test
      void save_test() {
          jdbcTemplate.update(DROP_TABLE_SQL);
          jdbcTemplate.update(CREATE_TABLE_SQL);
  
          customerMapper.save(new Customer(1L, "honggu", "kang"));
          Customer customer = customerMapper.findById(1L);
  
          log.info("fullName = {} {}", customer.getFirstName(), customer.getLastName());
      }
  }
  ```

- 코드와 쿼리를 분리함으로써 유지보수가 용이해졌다.



## JPA 소개

- `applcation.yml`

  ```yaml
    jpa:
      generate-ddl: true
      open-in-view: false
      show-sql: true
  ```

- `CustomerEntity`

  ```java
  @Entity
  @Table(name = "customers")
  @Getter
  @NoArgsConstructor
  public class CustomerEntity {
  
      @Id
      private long id;
      private String firstName;
      private String lastName;
  
      public void setId(long id) {
          this.id = id;
      }
  
      public void setFirstName(String firstName) {
          this.firstName = firstName;
      }
  
      public void setLastName(String lastName) {
          this.lastName = lastName;
      }
  }
  ```

- `CustomerRepository`

  ```java
  public interface CustomerRepository extends JpaRepository<CustomerEntity, Long> {
  }
  ```

- JPA 쓰는 이유

  - 생산성 증진: SQL 중심적 개발에서 탈피
  - RDB와 OOP 패러다임 불일치 해결




### 개발환경  설정

- `application.yml`

  ```yaml
  spring:
    h2:
      console:
        enabled: true
    jpa:
      generate-ddl: true
      hibernate:
        ddl-auto: create-drop
      show-sql: true
      open-in-view: false
      database: h2
      properties:
        hibernate:
          dialect: org.hibernate.dialect.MySQL5InnoDBDialect
          query.in_clause_parameter_padding: true
  ```

- `DataSourceConfig`

  ```java
  @Configuration
  public class DataSourceConfig {
  
      @Bean
      public DataSource dataSource() {
          DriverManagerDataSource dataSource = new DriverManagerDataSource();
          dataSource.setDriverClassName("org.h2.Driver");
          dataSource.setUrl("jdbc:h2:~/test");
          dataSource.setUsername("sa");
          dataSource.setUsername("sa");
          dataSource.setPassword("");
  
          return dataSource;
      }
  
      @Bean
      public JpaVendorAdapter jpaVendorAdapter(JpaProperties jpaProperties) {
          AbstractJpaVendorAdapter jpaVendorAdapter = new HibernateJpaVendorAdapter();
          jpaVendorAdapter.setShowSql(jpaProperties.isShowSql());
          jpaVendorAdapter.setDatabasePlatform(jpaProperties.getDatabasePlatform());
          jpaVendorAdapter.setGenerateDdl(jpaProperties.isGenerateDdl());
  
          return jpaVendorAdapter;
      }
  
      @Bean
      public LocalContainerEntityManagerFactoryBean entityManagerFactory(DataSource dataSource, JpaVendorAdapter jpaVendorAdapter,
                                                                             JpaProperties jpaProperties) {
          LocalContainerEntityManagerFactoryBean emfBean = new LocalContainerEntityManagerFactoryBean();
          emfBean.setDataSource(dataSource);
          emfBean.setPackagesToScan("org.programmers.springbootjpa.domain");
          emfBean.setJpaVendorAdapter(jpaVendorAdapter);
  
          Properties properties = new Properties();
          properties.putAll(jpaProperties.getProperties());
          emfBean.setJpaProperties(properties);
          return emfBean;
      }
  
      @Bean
      public PlatformTransactionManager transactionManager(LocalContainerEntityManagerFactoryBean entityManagerFactory) {
          JpaTransactionManager transactionManager = new JpaTransactionManager();
          transactionManager.setEntityManagerFactory(entityManagerFactory.getObject());
  
          return transactionManager;
      }
  }
  ```

  

