
# 7장. SQL 응용
## 1. 데이터베이스 기본
### 1. 트랜잭션
1. 개념
	- 인가받지 않은 사용자로부터 데이터를 보장하기 위해 DBMS가 가져야 하는 특성이자, DB 시스템에서 하나의 논리적 기능을 정상적으로 수행하기 위한 작업의 기본 단위
2. 특성
	- 원자성(Atomicity)
		- 작업 최소 단위
		- 연산 전체 성공 혹은 실패(All or Nothing)
		- **기법**: 커밋/롤백, 회복성 보장
	- 일관성(Consistency)
		- 실행 성공 후 일관된 DB상태 보존
		- **기법**: 무결성 제약조건, 동시성 제어
	- 격리성(Isolation)
		- 트랜잭션 연산 중간 결과를 타 트랜잭션이 접근 불가
		- **기법**: DB Isolation Level
			- **DB Isolation Level(고립 수준)**
				1. Read Uncommitted: 연산중인 데이터 읽기 O, 쓰기 X
				2. Read Committed: 연산 완료 데이터 읽기O
				3. Repeatable Read: 선행 트랜잭션이 읽는 데이터 접근 X(~선행 트랜잭션 종료시까지)
				4. Serializable Read: 선행 트랜잭션이 읽는 데이터 영역 전체 접근 X
3. 상태
	```mermaid
	graph LR
	A(활성) --> B(부분 완료)
	A --> C(실패)
	B -- Commit --> D(완료)
	C -- Rollback --> E(철회)
4. 트랜잭션 제어 언어(TCL; Transaction Control Language)
	- COMMIT, ROLLBACK, CHECKPOINT
5. 병행 제어(일관성 제어 기법)
	1. 개념
		- Concurrency Control
		- 일관성 유지를 위해 상호작용 제어
	2. 미보장 시 문제점
		- 갱신 손실(Lost Update): 선행 트랜잭션의 결과를 후행 트랜잭션이 덮어씀
		- 현황 파악오류(Dirty Read): 트랜잭션의 중간 수행 결과를 타 트랜잭션이 참조
		- 모순성(Inconsistency): 두 트랜잭션의 동시 실행으로 일관성 결여
		- 연쇄 복귀(Cascading Rollback)
	3. 기법 종류
		- 로킹(Locking)
		- 낙관적 검증: 검증 없는 트랜잭션 수행, 트랜잭션 종료 시 검증
		- 타임 스탬프 순서(Time Stamp Ordering): 트랜잭션과 그것이 읽거나 갱신한 데이터에 타임 스탬프 부여, 그것에 따라 트랜잭션 수행
		- 다중버전 동시성 제어(MVCC; Multi Version Concurrency Control): 트랜잭션 타임스탬프와 데이터의 타임스탬프 비교, 직렬가능성이 보장되는 버전을 선택
	4. 회복(Recovery) 기법(영속성 주요 기법)
		- 트랜잭션 실행 중 장애 발생시 복구
		- 종류
			1. 로그 기반
				- 지연 갱신(Deferred Update) 회복 기법
				- 즉각 갱신(Immediate Update) 회복 기법
			2. 체크 포인트 회복 기법(Checkpoint Recovery): 검사점 이후에 처리된 트랜잭션만 장애 발생 이전으로 복원
			3. 그림자 페이징(Shadow Paging) 회복 기법: 트랜잭션시 복제본 생성, 장애시 이를 이용해 복구
### 2. DDL
1. 개념
	- Data Definition Language
	- 데이터 정의어: 데이터 구조와 관련
2. DDL의 대상
	- 도메인
	- 스키마
		- 외부
		- 개념
		- 내부
	- 테이블(Table) = 릴레이션(Relation) = 엔티티(Entity)
		- 필드들로 구성된 데이터의 집합체
		- 튜플(Tuple) = 행(Row) = 레코드, 릴레이션에서 같은 값을 가질 수 없음, 튜플의 수 = 카디널리티(cardinality)
		- 애트리뷰트(Attribute) = 열(Column), 열의 수 = 차수(degree)
		- 식별자
		- 도메인 = 단일 애트리뷰트가 취할 수 있는 같은 타입의 원자값들의 집합
	- 뷰
		- 물리테이블들로부터 join 등으로 생성된 논리 테이블
		- 단순 질의어 사용 가능: 여러 테이블 접근할 필요 없이 사용 간단, 테이블의 일부만 이용
		- 특징
			- 논리적 데이터 독립성: DB에 영향 없이 원하는 형태로 데이터 접근
			- 데이터 조작 연산 간소화
			- 보안 기능(접근제어) 제공: 뷰 외의 필드 조회, 접근을 불가하게
			- 뷰 변경 불가:  뷰 정의는 alter문으로 변경 불가(뷰는 create ~ drop)
		- 장단점
			- 장점
				- 논리적 독립성
				- 데이터 관리 용이
				- 데이터 보안 용이
			- 단점
				- 뷰 자체 인덱스 불가
				- 뷰 정의 변경 불가
				- 데이터 변경 제약 존재
	- 인덱스
		- 테이블에 대한 조회속도를 높이는 자료구조
		- 테이블의 특정 레코드(=튜플) 위치를 알려 주는 용도
		- 특징
			- 기본키(PK; Primary Key) 컬럼은 자동으로 인덱스가 생성
			- 연원일, 이름 기준 인덱스는 자동 생성 안함
			- 조건절에 '='로 비교되는 컬럼을 대상으로 인덱스 설정시 검색 속도 향상
			- 인덱스 유무에 따른 검색
				- 없을 경우: 테이블 전체 스캔(Table Full Scan): 테이블 전체 검색
				- 있을 경우: 인덱스 범위 스캔(Index Range Scan): 빠른 검색
			- 종류
				- 순서 인덱스(Ordered): 정렬된 순서로 생성된 인덱스, B-Tree 알고리즘 활용
				- 해시 인덱스(Hash): 해시함수 이용하여 데이터 키 값으로 직접 접근, 튜플(Row) 양에 무관한 데이터 접근 비용
				- 비트맵 인덱스(Bitmap): 각 컬럼에 적은 개수 값이 입력된 경우, 수정 변경이 적은 경우 이용(생년월일, 상품번호 등)
				- 함수 기반 인덱스(Functional): 수식이나 함수를 적용함
				- 단일 인덱스(Singled): 단일 컬럼으로만 구성, 주 사용 컬럼이 하나이 경우 사용
				- 결합 인덱스(Concatenated): 두 개 이상의 컬럼으로 구성, WHERE 조건 사용 빈도가 높은 경우 사용
				- 클러스터드 인덱스(Clustered): PK기준으로 레코드를 묶어 저장하는 인덱스, 저장 데이터의 물리적 순서에 따라 인덱스 생성, 특정 범위 검색에 유리
			- 스캔 방식
				- 인덱스 범위 스캔(Index Range Scan): 루트 블록 -> 리프 블록 탐색 후 리프 블록을 필요 범위만큼 스캔
				- 인덱스 전체 스캔(Index Full Scan): 수직 탐색 없이 인덱스 리프 블록을 처음부터 끝까지 수평적으로 탐색
				- 인덱스 단일 스캔(Index Unique Scan): 수직적 탐색만
				- 인덱스 생략 스캔(Index Skip Scan): 선두 컬럼이 조건 절에 빠졌어도 인덱스를 활용하는 스캔 방식
3. DDL 명령어
	- CREATE: DB 오브젝트 생성
	- ALTER: ~ 변경
	- DROP: ~ 삭제
	- TRUNCATE: ~ 내용 삭제
4. TABLE관련 DDL
	1. CREATE TABLE: 테이블 생성
		```SQL
		CREATE TABLE 사원
		(
		  사번 VARCHAR(10) PRIMARY KEY,
		  업무 VARCHAR(20) FOREIGN KEY REFERENCES 부서(부서코드),
		  이름 VARCHAR(10) UNIQUE,
		  생년월일 CHAR(8) NOT NULL,
		  성별 CHAR(1) CHECK (성별 = 'M' OR 성별 = 'F'),
		  입사일 DATE DEFAULT SYSDATE -- SYSDATE는 현재시간/날짜
		);

	2. ALTER TABLE: 테이블 수정
		- 컬럼 추가: CREATE TABLE의 제약조건 사용 가능
			```SQL
			ALTER TABLE 사원 ADD 전화번호 VARCHAR(11) UNIQUE;
		- 컬럼 수정
			```SQL
			ALTER TABLE 사원 MODIFY 이름 VARCHAR(30) NOT NULL;
		- 컬럼 삭제
			```SQL
			ALTER TABLE 사원 DROP 생년월일;
	3. DROP TABLE: 테이블 삭제
		- FK의 경우 옵션으로 CASCADE(참조하는 테이블 연쇄 삭제)와 RESTRICT(삭제할 테이블이 참조되고 있으면 제거 안 함) 중 선택 가능
		```SQL
		DROP TABLE 사원;
	4. TRUNCATE TABLE: 테이블 내 데이터 삭제
		```SQL
		TRUNCATE TABLE 사원;
5. VIEW 관련 DDL
	1. CREATE VIEW: 뷰 생성
		- VIEW 테이블의 SELECT 문에는 UNION이나 ORDER BY 절 사용 불가
		- 컬럼명 생략시 SELECT문의 컬럼명이 자동 사용
		```SQL
		CREATE VIEW 사원뷰 AS
		SELECT 사번, 이름
		   FROM 사원
		   WHERE 성별 = 'M';
	2. CREATE OR REPLACE VIEW
		- 뷰를 교체, 사용법은 CREATE VIEW와 동일
	3. DROP VIEW
		```SQL
		DROP VIEW 뷰이름;
6. INDEX 관련 DDL
	1. CREATE INDEX: 인덱스 생성
		- UNIQUE 생략 가능, 인덱스가 걸린 컬럼은 중복 허용 X
		- 복수 컬럼을 인덱스로 걸 수 있음
			```SQL
			CREATE INDEX 사번인덱스 ON 사원(사번);
	2. ALTER INDEX: 인덱스 수정
		- 일부 DBMS에서 지원하지 않음
		- 기존 인덱스 삭제 + 신규 인덱스 생성을 권장
		```SQL
		ALTER INDEX 사번인덱스 ON 사원(사번);
	3. DROP INDEX: 인덱스 삭제
		```SQL
		DROP INDEX 사번인덱스;
### 3. DML
1. 개념
	- 데이터 조작어 DML; Data Manipulation Language
	- 데이터베이스에 저장된 자료들을 CRUD 하는 언어
2. DML 명령어: SELECT, INSERT, UPDATE, DELETE
3. SELECT(데이터 조회) 명령어
	1. SELECT
		```SQL
		SELECT [ALL / DISTINCT] 속성명1, 속성명2, ...
		FROM 테이블명1, ...
		[WHERE 조건]
		[GROUP BY 속성명1, ...]
		[HAVING 그룹조건]
		ORDER BY 속성 [ASC / DESC] ];
	2. JOIN
		- 개념: 두 개 이상의 테이블을 연결하여 데이터를 검색하는 방법
