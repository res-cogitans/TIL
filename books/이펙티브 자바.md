﻿﻿﻿﻿﻿﻿﻿﻿﻿# 1장 들어가기
### 기술 용어 사용
- **자바 언어 명세(JLS, The Java Language Specification)**: 이 책에서는 자바8용 명세 따름
	- 지원 자료형
		- 인터페이스
			- Annotation
		- 클래스
			- Enum
		- 배열
		- 기본 타입(primitive): 유일하게 참조형이 아님(객체가 아님)
	- 클래스의 멤버
		- 필드
		- 메서드
			- 메서드 시그니처: 메서드 이름 + 입력 매개변수의 타입들 (!반환값의 타입)
		- 멤버 클래스
		- 멤버 인터페이스
- 자바 언어 명세와 다른 부분
	- 상속(inheritance) = 서브클래싱(subclassing)
	- 인터페이스 상속 -> 클래스가 인터페이스를 구현(implement), 인터페이스가 다른 인터페이스를 확장(extend)
	- 명시하지 않은(default) 접근 수준(access level)
		- 패키지 접근(package access) -> 패키지-프라이빗(package-private)
- 자바 언어 명세에 정의되지 않은 것들
	- 공개(exported) API(Application Programming Interface)
		- 프로그래머가 클래스, 인터페이스, 패키지를 통해 접근할 수 있는 모든 클래스, 인터페이스, 생성자, 멤버, 직렬화된 형태(serialized form)
			- API 요소(element): 클래스, 인터페이스, 생성자, 멤버, 직렬화된 형태
		- 자바 지원 자료형인 인터페이스와 구별하기 위해 사용한 용어
		- API를 사용하는 프로그램 작성자(사람): API의 사용자
		- API를 사용하는 클래스(코드): API 클라이언트
		- 공개 API는 API 정의 패키지의 밖에서 접근 가능한 요소로 구성 -> 모든 클라이언트가 접근할 수 있고, API작성자가 지원하기로 약속한 요소
			- javadoc을 기본 실행시 API요소들만 담은 문서 생성
		- 패키지의 공개 API는 패키지의 모든 public 클래스, 인터페이스의 public, protected 멤버와 생성자로 구성
			- 자바 9의 모듈 시스템을 통해 공개할 패키지 선택 가능



# 2장 객체 생성과 파괴

## 아이템1: 생성자 대신 정적 팩터리 메서드를 고려하라
```java
public static Boolean valueOf(boolean b) {
    return b ? Boolean.TRUE : Boolean.FALSE;
}
```
- 디자인 패턴의 팩터리 메서드(Factory Method)와는 다름!
- 해당 클래스의 인스턴스를 반환하는 단순한 정적 메서드


### 정적 팩터리 메서드가 생성자보다 좋은 점
1. **이름을 가질 수 있다**
- 생성자: `BigInteger(int, int, Random)`에 비해
정적 팩터리 메서드 `BigInteger.probablePrime`이 더 직관적이다.
- 생성자 오버로딩을 이용하는 데에도 한계가 있다.
	- 하나의 시그니처로는 생성자를 하나만 가질 수 있다.
		- 매개변수의 순서를 다르게 하는 방식
			- `Constructor(int i, String s)`와
			- `Constructor(String s, int i)`는 서로 다르다는 점을 이용하는 방식
			- 하지만 이 경우 직관성이 떨어지고, 혼란만 가중시킨다.
		- 반면, 정적 팩터리 메서드는 하나의 시그니처로 하나의 생성자만 가질 수 있는 제약을 받지 않는다.
2. **호출될 때마다 인스턴스를 새로 생성하지는 않아도 된다.**
- 인스턴스 통제(instance-controlled) 클래스
	- 인스턴스 미리 만들기, 캐싱 등으로 불필요한 객체 생성 회피 -> 성능 향상
	- 인스턴스 통제를 통해 객체를
		- 싱글턴(singleton)
		- 인스턴스화 불가(noninstantiable)
		- 불변 값 인스턴스에서 동치인 인스턴스가 하나임을 보장(Leibniz's law)
		- 플라이웨이트 패턴
		- 열거형(인스턴스가 하나임을 보장)
		만들 수 있다.
3. **반환 타입의 하위 타입 객체를 반환할 수 있는 능력이 있다.**
- 반환 객체의 클래스를 선택 가능한 유연성
	- API를 작게 유지
	- 인터페이스 기반 프레임워크: 인터페이스를 정적 팩터리 메서드의 반환 타입으로 사용
		- 구현 객체를 인터페이스로 다룬다는 점에서 API 학습 난이도를 낮추며, 다형성을 활용하기 좋다.
- Java8이전의 경우 인터페이스에서 정적 메서드 반환 불가
	- 동반 클래스 사용해야:
	```java
	public interface Type {
	    ...
	}
	```
	이를 반환하는 정적 메서드`typeFactory()` Type 내에 생성이 불가능하기에
	```java
	public class Types {
	    static Type typeFactory() {
	    ...
	    }
	}
	```
	위와 같은 방식으로 동반 클래스(companion class)를 만들어야 했다.
	- 예시) java.util.Collections
- 자바8 이후로는 인터페이스가 정적 메서드를 가질 수 있다.
	- 즉 동반 클래스를 가질 필요가 적다.
	- 하지만 인터페이스는 public 정적 멤버만 허용하며
	- 자바9에서 private 정적 메서드까지 허용하지만, 어쨌든 정적 필드와 정적 멤버 클래스는 여진히 public만 가능하다.
	- 이런 이유로 package-private 클래스에 정적 메서드 구현 코드 일부를 둬야 하는 경우도 있다.
4. **입력 매개변수에 따라 매번 다른 클래스의 객체를 반환할 수 있다.**
  - 유연하게 반환 하위 클래스를 선택, 변경할 수 있다.
  - 위와 마찬가지로, 다형성을 활용하는 데 용이하다. 클라이언트는 실제 어느 하위 클래스의 인스턴스인지를 알 필요가 없다.
  - 예시: `java.util.EnumSet.java`의 경우

  ```java
  /**
   * Creates an empty enum set with the specified element type.
   *
   * @param <E> The class of the elements in the set
   * @param elementType the class object of the element type for this enum
   *     set
   * @return An empty enum set of the specified type.
   * @throws NullPointerException if {@code elementType} is null
   */
  public static <E extends Enum<E>> EnumSet<E> noneOf(Class<E> elementType) {
      Enum<?>[] universe = getUniverse(elementType);
      if (universe == null)
          throw new ClassCastException(elementType + " not an enum");
  
      if (universe.length <= 64)
          return new RegularEnumSet<>(elementType, universe);
      else
          return new JumboEnumSet<>(elementType, universe);
  }
  ```

  원소의 수에 따라 `RegularEnumSet`이나 `JumboEnumSet`을 반환한다.

  - 하위 클래스이기만 한다면

    - 클라이언트가 하위 클래스의 존재를 모르며,

    - 필요 없는 하위 클래스는 삭제해도 문제가 없으며

    - 필요한 다른 클래스를 추가해도 된다는 점에 주목하라.

5. **정적 팩터리 메서드를 작성하는 시점에는 반환할 객체의 클래스가 존재하지 않아도 된다.**

  - 서비스 제공자 프레임워크(service provider framework)
   - 대표적인 예로 JDBC(Java Database Connectivity)
   - 제공자(provider)인 서비스 구현체들을 클라이언트에 제공하는 역할을 프레임워크가 담당 -> 클라이언트를 구현체로부터 분리!
  	- 구성: 3개의 핵심 컴포넌트(경우에 따라 +1)
        		- 서비스 인터페이스(service inteface): 구현체의 동작을 정의
  	- 제공자 등록 API(provider registration API): 제공자가 구현체를 등록할 때 사용
  
  	- 서비스 접근 API(service access API): 클라이언트가 서비스의 인스턴스를 얻을 때 사용
        		- 클라이언트가 원하는 구현체의 조건을 명시하여 반환받음, 명시하지 않으면 기본 구현체 혹은 지원 구현체 중 하나를 반환
                		- 유연한 정적 팩터리

~~~java
		```java
		    @CallerSensitive
		    public static Connection getConnection(String url,
		        java.util.Properties info) throws SQLException {
		
		        return (getConnection(url, info, Reflection.getCallerClass()));
		    }
		...
		    @CallerSensitive
		    public static Connection getConnection(String url,
		        String user, String password) throws SQLException {
		        java.util.Properties info = new java.util.Properties();
		
		        if (user != null) {
		            info.put("user", user);
		        }
		        if (password != null) {
		            info.put("password", password);
		        }
		
		        return (getConnection(url, info, Reflection.getCallerClass()));
		    }
		...
		    @CallerSensitive
		    public static Connection getConnection(String url)
		        throws SQLException {
		
		        java.util.Properties info = new java.util.Properties();
		        return (getConnection(url, info, Reflection.getCallerClass()));
		    }
		...
		        //  Worker method called by the public getConnection() methods.
		    private static Connection getConnection(
		        String url, java.util.Properties info, Class<?> caller) throws SQLException {
		        /*
		         * When callerCl is null, we should check the application's
		         * (which is invoking this class indirectly)
		         * classloader, so that the JDBC driver class outside rt.jar
		         * can be loaded from here.
		         */
		        ClassLoader callerCL = caller != null ? caller.getClassLoader() : null;
		        if (callerCL == null || callerCL == ClassLoader.getPlatformClassLoader()) {
		            callerCL = Thread.currentThread().getContextClassLoader();
		        }
		
		        if (url == null) {
		            throw new SQLException("The url cannot be null", "08001");
		        }
		
		        println("DriverManager.getConnection(\"" + url + "\")");
		
		        ensureDriversInitialized();
		
		        // Walk through the loaded registeredDrivers attempting to make a connection.
		        // Remember the first exception that gets raised so we can reraise it.
		        SQLException reason = null;
		
		        for (DriverInfo aDriver : registeredDrivers) {
		            // If the caller does not have permission to load the driver then
		            // skip it.
		            if (isDriverAllowed(aDriver.driver, callerCL)) {
		                try {
		                    println("    trying " + aDriver.driver.getClass().getName());
		                    Connection con = aDriver.driver.connect(url, info);
		                    if (con != null) {
		                        // Success!
		                        println("getConnection returning " + aDriver.driver.getClass().getName());
		                        return (con);
		                    }
		                } catch (SQLException ex) {
		                    if (reason == null) {
		                        reason = ex;
		                    }
		                }
		
		            } else {
		                println("    skipping: " + aDriver.driver.getClass().getName());
		            }
		
		        }
		
		        // if we got here nobody could connect.
		        if (reason != null)    {
		            println("getConnection failed: " + reason);
		            throw reason;
		        }
		
		        println("getConnection: no suitable driver found for "+ url);
		        throw new SQLException("No suitable driver found for "+ url, "08001");
		    }
~~~

​	제공된 파라미터에 따라서 실제로 getConnection() 작업을 하는 메서드에 형식을 맞춰 파라미터를 넘기고, 인터페이스로서 Driver를 받고 있다.
​	
 - 그런데 왜 리플렉션을 사용할까?

- 서비스 제공자 인터페이스(service provider interface): 서비스 인터페이스의 인스턴스를 생성하는 팩터리 객체를 설명

  - 리플렉션?
  		- 서비스 제공자 프레임워크 패턴의 변형
		- 브리지 패턴: 서비스 접근 API가 공급자가 제공하는 것보다 더 풍부한 서비스 인터페이스를 클라이언트에 반환
		- DI 프레임워크
			- `java,util.ServiceLoader`: 자바6부터 제공되는 범용 서비스 제공자 프레임워크
			- JDBC의 경우 자바6 이전에 등장했기에 위를 사용 안 함.



### 단점
1. **상속을 하려면 public이나 protected 생성자가 필요하니 정적 팩터리 메서드만 제공하면 하위 클래스를 만들 수 없다.**
	- 상속보다 컴포지션을 사용하도록 유도하고
	- 불변 타입으로 만들기 위한 제약이 된다는 점에서 장점이 되기도 한다.
2. **정적 팩터리 메서드는 프로그래머가 찾기 어렵다.**
	- 생성자처럼 API 설명에 명확히 들어나지 않기 때문(JavaDocs)
	- API 문서를 잘 작성하고 메서드명을 규약에 따라 짓는 것으로 문제를 완화해야:
	- 정적 팩터리 메서드에 흔한 명명 방식
		- from: 매개변수를 받아서 해당 타입의 인스턴스를 반환하는 형변환 메서드
			- `Date d = Date.from(instant);`
		- of: 여러 매개변수를 받아 적합한 타입의 인스턴스를 반환하는 집계 메서드
			- `Set<Rank> faceCards = EnumSet.of(JACK, QUEEN, KING)`
		- valueOf: from과 of의 더 자세한 버전
			- `BigInteger prime = BigInteger.valueOf(Integer.MAX_VALUE);`
		- instance 혹은 getInstance: (매개변수를 받는다면) 매개변수로 명시한 인스턴스를 반환하지만, 같은 인스턴스임을 보장하지는 않는다.
			- `StackWalker luke = StackWalker.getInstance(options);`
		- create 혹은 newInstance: instance 혹은 getInstance와 같지만, 매번 새로운 인스턴스를 생성해 반환함을 보장한다.
			- `Object newArray = Array.newInstance(classObject, arrayLen);`
		- getType: getInstance와 같으나, 생성할 클래스가 아닌 다른 클래스에 팩터리 매서드를 정의할 때 쓴다. "Type"은 팩터리 메서드가 반환할 객체의 타입이다.
			- `FileStore fs = Files.getFileStore(path);`
		- newType: getType과 같으나, 매번 새로운 인스턴스를 생성해 반환함을 보장한다.
			- `BufferedReader br = Files.newBufferedReader(path);`
		- type: getType과 newType의 간결한 버전
			- `List<Complaint> litany = Collections.list(legacyLitany);`
> 핵심 정리
> 정적 팩터리 메서드와 public 생성자는 각자의 쓰임새가 있으니 상대적인 장단점을 이해하고 사용하는 것이 좋다. 그렇다고 하더라도 정적 팩터리를 사용하는 게 유리한 경우가 많으므로 무작정 public 생성자를 제공하던 습관이 있다면 고치자.

## 아이템 2: 생성자에 매개변수가 많다면 빌더를 고려하라.
- 아이템 2: 생성자에 매개변수가 많다면 빌더를 고려하라.
  - 정적 팩터리와 생성자의 공통 제약사항: 선택적 매개변수가 많을 경우 대응이 어렵다.

### 선택 매개변수가 많을 때 대응법
1. **점층적 생성자 패턴(telescoping constructor pattern)**
```java
public class NutritionFacts {
    private final sevingSize;
    private final servings;
    private final int calories;
    private final int fat;
    private final int sodium;
    
    public NutritionFacts(int servingSize, int servings) {
    this(servingSize, servings, 0);
    }
    
    public NutritionFacts(int servingSize, int servings, int calories) {
    this(servingSize, servings, calories, 0);
    }

    public NutritionFacts(int servingSize, int servings, int calories, int fat) {
    this.servingSize = servingSize;
    this.servings = servings;
    this.calories = calories;
    this.fat = fat;
    }
}
```
- 설정하길 원하지 않는 매개변수에도 값을 지정해줘야 함
- 코드 가독성이 낮고 수정 및 사용이 어려움

2. **자바빈즈 패턴(JavaBeans pattern)**
- 기본 생성자로 객체 생성 후 Setter로 값 설정
- 단점
	- 객체 하나를 생성하기 위해 Setter를 여러 번 호출해야 한다.
	- 객체가 완전히 생성되기 전까지는 일관성(consistency)이 무너진 상태에 놓인다.
		- 때문에 클래스를 불변으로 만들 수 없으며
		- 스레드 안전성을 얻기 위해 추가 작업이 필요하다.
	- freeze 메서드
		- 생성이 끝난 객체를 얼리며(freeze) 얼리기 전에는 사용하지 못 하게 만들어 위의 단점을 완화하려는 기법
		- 하지만 freeze 메서드를 객체 사용 전에 호출하였는지를 컴파일 단계에서 검증 불가하기에 런타임 오류에 취약하다.
3. 빌더 패턴
- 점층적 생성자 패턴의 안전성과 자바빈즈 패턴의 가독성을 갖춤

###  빌더 패턴(Builder Pattern)
- 작동방식
	- 필수 매개변수만으로 생성자 / 정적 팩터리를 호출하여 빌더 객체를 얻는다.
	- 빌더 객체의 설정 메서드(Setter와 유사)로 선택 매개변수를 설정한다.
	- 매개변수가 없는 build 메서드를 호출해 필요한 (일반적으로는 불변) 객체를 얻는다.
- 빌더는 생서할 클래스 안에 정적 멤버 클래스로 만들어두는 것이 보통이다.
- 의문사항: NutritionFacts 클래스는 불변???
- Builder의 Setter 메서드
	- 자기 자신을 반환하므로 메서드 연쇄 가능
		- 메서드 연쇄(method chaining) = 플루언트 API(fluent API)
	- 메서드명을 속성명으로 하면 가독성이 좋은 코드를 짤 수 있다:
	- `NutritionFacts cocacola = NutritionFacts.Builder(240, 8).calories(100).sodium(35).carbohydrate(27).build();`
	- 빌더 패턴은 파이썬/스칼라의 명명된 선택적 매개변수(named optional parameters)를 흉내낸 것이다.
- 유효성 검사 코드
	- 빌더의 생성자와 메서드에서 입력 매개변수를 검사
	- build 메서드가 호출하는 생성자 = NutritionFacts(Builder builder)에서 여러 매개변수에 걸친 불변식(invariant)을 검사
		- 빌더로부터 매개변수를 복사한 후 해당 객체 필드도 검사한다.
		- 문제 발견시 IllegalArgumentException
		- 

#### 불변과 불변식
- 불변(immutable or immutability)
	- 변경을 허용하지 않는다. <-> 가변(mutable) 객체
		- Ex) String
- 불변식(invariant)
	- 프로그램이 실행되는 동안 or 정해진 기간 동안 반드시 만족해야 하는 조건
	- 변경 허용이 가능하지만 조건 내에서만 가능
		- Ex) List의 크기는 0 이상, Period의 start필드 값은 end 필드 값보다 앞서야 함
- 가변 객체에도 불변식은 존재할 수 있으며 불변은 불변식의 극단적인 예라고 할 수 있다.
- 

### 빌더와 계층적 클래스
- 각 계층의 클래스에 관련 빌더를 멤버로 정의
	- 추상 클래스는 추상 빌더를, 구체 클래스(concrete class)는 구체 빌더를 갖게 함
	- EnumSet에 대해 추가!!!!
	- 시뮬레이트한 셀프 타입(simulated self-type) 관용구: self 타입이 없는 자바에서 self메서드 정의하여 사용
		- 이를 통해 형변환 없이 메서드 연쇄 지원
	- 공변 변환 타이핑(covariant return typing): 하위 클래스의 메서드가 상위 클래스의 메서드가 정의한 반환 타입이 아닌, 그 하위 타이블 반환하는 기능
		- 이를 통해 형변환 없이 빌더 사용 가능

### 그 외
- 빌더를 사용하면 가변인수(varargs) 매개변수를 여러 개 사용할 수 있다.
	- 각각을 적절한 메서드로 나눠 선언하거나
	- 메서드를 여러 번 호출하도록 하고 각 호출 때 남겨진 매개변수들을 하나의 필드로 모음
	
- 빌더는 매우 유연함

- 단점
	- 객체 생성 이전에 빌더를 만들어야 함
		- 경우에 따라 성능에 부정적 영향
		
	- 매개변수가 많을 때에나 빛을 발함
		- 하지만 매개변수는 점차 늘어나는 법이기에 빌더로 애초에 만드는 것이 좋을 때가 많다.
		
		  

## 아이템3. private 생성자나 열거 타입으로 싱글톤임을 보증하라.
### 싱글톤
- 단일 인스턴스
- 예시
	- 함수와 같은 무상태(stateless) 객체
	- 설계상 유일해야 하는 시스템 컴포넌트
- 싱글톤 클래스는 이를 사용하는 클라이언트를 테스트하기 어렵게 만들 수 있음 - mock 구현으로 대체가 어렵기 때문
### 싱글톤의 생성 방식
- 1, 2 모두 생성자는 private로 감추고, 인스턴스 접근 수단으로 public static 멤버를 남겨둠
#### 1.  private static final 필드 방식
```java
public class Elvis {
    public static final Evlis INSTANCE = new Elvis();
    private Elvis() {...}
	    
    public void leaveTheBuilding() {...}
}
```
- private 생성자는 private final인 싱글턴 인스턴스를 초기화할 때 단 한번만 호출된다.
- **코드가 싱글턴임이 API에 명백하게 드러난다는 장점**
- 이 인스턴스가 싱글턴임이 보장되지만 유일하게 예외가 있는데, 리필렉션 API인 `AccessibleObject.setAccessible`을 사용해 private 생성자를 호출하는 공격이 있을 수 있다.
	- 이를 예방하려면 생성자 차원에서 2번째 객체가 생성되려 할 때 예외를 던지도록 한다.
#### 2. 정적 팩터리 방식의 싱글턴
```java
public class Elvis {
    private static final Elvis INSTANCE = new Elvis();  
    private Elvis() {...}
    public static Elvis getInstance() {return INSTANCE;}
    
    public void leaveTheBuilding() {...}
}
```
- 동일 객체의 참조를 반환하기에 싱글턴 보장(단, 이 경우에도 리플렉션을 통한 예외는 동일)
- **장점**
	- API를 변경하지 않고도 싱글턴이 아니게 할 수 있다.
	- 정적 팩터리를 제네릭 싱글턴 팩터리로 만들 수 있다.
	- 정적 팩터리의 메서드 참조를 공급자(supplier)로 사용할 수 있다.
		- `Elvis::getInstance`를 `Supplier<Elvis>`로 사용하는 방식

#### 3. 열거 타입 방식
```java
public enum Elvis {
    INSTANCE;
    
    public void leaveTheBuilding() {...}
```
- 원소가 하나인 열거 타입을 선언하는 것
- public 필드 방식과 비슷하지만 추가적인 노력 없이 직렬화가 가능
- 복잡한 직렬화 상황이나 리플렉션 공격에서도 제2의 인스턴스 생성을 완전히 막음

### 직렬화
- 1과 2의 방식으로 만든 싱글턴 클래스를 직렬화하려면 단순히 `implements Serializable`로는 부족함
- 모든 인스턴스 필드를 일시적(transient)이라 선언하고 readResolve 메서드를 제공해야 함
	- 이렇게 하지 않을 경우 역직렬화할 때 마다 새로운 인스턴스가 만들어진다.
```java
private Object readResolve() {
    // '진짜' Elvis를 반환하고, 가짜 Elvis는 가비지 컬렉터에 맡긴다.
    return INSTANCE;
}
```

### 정리
- 직렬화에 관해서 가장 용이한것은 3
	- 대부분 상황에서는 3의 방식: 원소가 하나뿐인 열거 타입이 싱글턴을 만드는 가장 좋은 방법
	- 단 Enum 외의 클래스를 상속해야 할 경우 3은 사용 불가
		- 열거 타입이 다른 인터페이스를 구현하도록 선언하는 것은 불가하기 때문
	
- 2의 장점: 변경 용이성 / 정적 팩터리의 메서드 참조를 공급자로 사용이 필요하지 않다면 1이 나음

  

## 아이템4. 인스턴스화를 막으려거든 private 생성자를 사용하라
- 정적 메서드와 정적 필드만을 담은 클래스
	- 예시
		- `java.lang.Math`와 `java.util.Array`: 기본 타입 값이나 배열 관련 메서드를 모아놓음
		- `java.util.Collections`: 특정 인터페이스를 구현하는 객체를 생성해주는 정적 메서드(혹은 팩터리) 모음(자바 8부터는 인터페이스에 넣을 수 있다)
		- final 클래스와 관련한 메서드를 모을 경우: final클래스를 상속해서 하위 클래스에 메서드를 넣는 건 불가능하기 때문
	- 인스턴스 없이 사용하려고 설계한 유틸리티 클래스
		- 생성자를 명시하지 않으면 public 기본 생성자가 만들어지기에, 의도치 않게 인스턴스화 가능해짐
- 인스턴스화를 막기 위해서
	- 추상 클래스로 만드는 것으로는 부족
		- 하위 클래스를 만들어서 인스턴스화할 수 있기 때문
		- 상속해서 사용하라는 의미로 오독될 수도 있다.
	- **private 생성자를 추가하여 클래스의 인스턴스화를 막아라!**
```java
public class UtilityClass() {
    // 기본 생성자가 만들어지는 것을 막는다(인스턴스화 방지용).
    private UtilityClass() {
        throw new AssertionError();
    }
    ...
}
```
- AssertionError는 클래스 내부에서 생성자를 호출하는 경우를 대비
- 호출 불가능한 생성자는 직관성이 낮기 때문에 주석을 달아주는 편이 좋음
- 상속을 불가능하게 만든다.
	- 모든 생성자는 명시적/묵시적으로 상위 클래스의 생성자를 호출하게 된다. private 생성자는 하위 클래스가 상위 클래스 생성자에 접근할 수 없게 하기에 상속이 불가하게 만든다.

## 아이템5. 자원을 직접 명시하지 말고 의존 객체 주입을 사용하라
### 자원에 의존하는 클래스 구현: 사전에 의존하는 맞춤법 검사기 사례
#### 부정적 예시
1.  정적 유틸리티 클래스
```java
public class SpellChecker {
    private final Lexicon dictionary =...;
    
    private SpellChecker() {} // 객체 생성 방지
    
    public static boolean isValid(String word) { ... }
    public static List<String> suggestions(String typo) { ... }
}
```

2. 싱글톤
```java
public class SpellChecker {
    private final Lexicon dictionary = ...;
    
    private Spellchecker(...) {}
    public static SpellChecker INSTANCE = new pellChecker(...);
    
    public boolean isValid(String word) { ... }
    public List<String> suggestions(String typo) { ... }
}
```
- 1과 2는 모두 자원(사전)을 단 하나만 사용한다고 가정한다는 점이 단점이다.
	- 실제로는 다양한 자원을 사용할 수 있어야 한다.
	- 대안: dictionary 필드를 final하지 않게 만드는 방법
		- 오류를 내기 쉬우며 멀티스레드 환경에서 사용 불가
	- 사용하는 자원에 따라 동작이 달라지는 클래스에는 정적 유틸리티 클래스나 싱글톤 방식은 부적합하다.

#### 대안: 의존 객체 주입 패턴
```java
public class SpellChecker {
    private final Lexicon dictionary;
    
    public SpellChecker(Lexicon dictionary) {
    
}
```

- 인스턴스를 생성할 때 생성자에 필요한 자원을 넘겨주는 방식

- 자원의 수나 의존관계와 무관하게 작동

- 불변을 보장, 동일 자원 공유를 안전하게 할 수 있음

- 생성자, 정적 팩터리, 빌더 모두에 적용 가능한 방법

- 변형: 생성자에 자원 팩터리를 넘겨주는 방식
	- 한정적 와일드카드 타입(bounded wildcard type)을 이용해 팩터리 타입 매개변수를 제한해야
		- 예시
	```java
	Mosaic create(Supplier<? extends Tile> tileFactory) {...}
	```
	
- 단, 의존성이 많은 프로젝트에서는 코드를 어지럽힐 수 있다: 의존 객체 주입 프레임워크를 사용하여 해결하라

- 의문사항: 왜 싱글톤을 사용해서 안 되나? 싱글톤에 DI 사용하면 되지 않나(스프링의 경우)?



## 아이템6. 불필요한 객체 생성을 피하라
- 생성보다는 재사용이 더 낫다.
- 불변 객체는 재사용이 언제나 가능하다.
- 정적 팩터리 메서드를 사용하여 불필요한 객체 생성을 피할 수 있다.
	- `Boolean(String)` 대신 `Boolean.valueOf(String)`을 사용하는 것이 좋다.
	- 가변 객체의 경우 사용중 변경이 없을 것임을 안다면 재사용 가능하다.
- 생성 비용비 비싼 객체가 자주 필요할 경우 캐싱하여 재사용하라.
	- 정적 멤버로 자주 불변 인스턴스를 캐싱해둔다.
	- 만일 클래스 호출: 인스턴스 초기화 이후 메서드를 호출하지 않는다면 성능상 낭비가 된다.
		- 이를 막기 위해 지연 초기화를 사용할 수 있으나 성능상의 이점이 미미한 반면 코드를 복잡하게 만들기에 사용을 권하지 않는다.
- 재사용 직관성: 보충
	- 어댑터 패턴
	- 오토박싱
		- 기본형과 박싱된 클래스의 구별을 흐리지만 성능 상으로 차이가 있음에 유의
		- long이 아니라 Long으로 선언한 것 만으로 불필요한 인스턴스를 매우 많이 만들게 될 수도 있다.
		- 박싱된 기본 타입보다는 기본 타입을 사용하고, 의도치 않은 오토박싱이 숨어들지 않게 주의해야
- 그러나 기본적으로는 객체 생성을 피하기 보다는, 명확성, 간결성, 기능을 위한 것일 경우 추가하는 것이 더 좋은 선택이다. 
	- 요즘 JVM은 작은 객체를 생성, 회수하는 것에 부담이 적기 때문
- 객체 풀을 직접 설정하는 것은 피하라
	- DB연결 풀처럼 생성 비용이 비싼 경우는 물론 예외
	- 하지만 기본적으로 객체 풀은 코드를 혼잡하게 하며 성능상 이점이 낮다. -> GC가 발달해서 가벼운 객체의 경우 GC가 더 빠름
- 방어적 복사가 필요한 상황에서 객체를 재사용했을 때의 피해가, 불필요한 객체를 반복 생성했을 때의 피해보다 훨씬 크다는 점에 유의하라.



## 아이템7. 다 쓴 객체 참조를 해제하라
- 자바에는 GC가 있지만 메모리 관리는 여전히 필요하다.
- Stack의 사례
	```java
	public class Stack {
	    private Object[] elements;
	    private int size;
	    
	    ...
	    
	    public Object pop() {
	        if (size == 0)
	            throw new EmptyStackException();
	        return elements[--size];
	    }
	    
	    ...
	}
	```
	- pop으로 인해 활성 영역 밖으로 밀려난 elements[size]에 대한 참조를 Stack이 가지고 있기 때문에 이는 GC가 회수하지 않는다.
	- 참조가 남아 있을 경우 그 참조가 참조하는 것들도 GC가 회수하지 못하므로 누수는 더 커진다.
### null 처리(참조 해제)
```java
public Object pop() {
    if (size ==0)
        throw new mptyStackException();
    Object result = elements[--size];
    elements[size] = null; // 다 쓴 참조 해제
    return result;
}
```
- 활성 영역 밖의 원소를 접근하려고 하면 NPE가 발생한다. 오류 발견에 도움이 된다.
#### null 처리는 언제 사용해야 하나?
- 예외적인 경우에만 사용하는 것이 기본이다.
	- 참조를 담은 변수를 유효 범위(scope) 밖으로 밀어내는 것이 낫다.
	
- Stack의 예시처럼 자기 메모리를 직접 관리하는 경우, 쓸모 없는 객체를 GC는 인지할 수 없기에 직접 null처리 해주는 것이다.

- 자기 메모리를 직접 관리하는 클래스는 메모리 누수를 주의해야 한다.

- 캐시는 메모리 누수의 주범이다. 객체 참조를 캐시에 넣고, 객체의 다 쓴 참조(osolete reference)를 그대로 가지고 있는 경우가 있다.
	- 해법: WeakHashMap
	- LinkedHashMap
	
- listener, callback
	- weak reference
	
	

## 아이템8. finalizer와 cleaner 사용을 피하라
- 자바의 두 가지 객체 소멸자
	- finalizer: 기본적으로 사용하지 마라. 예측 힘들고 위험하다.
	- cleaner: finalizer보다는 덜 위험하지만 여전히 예측하기 힘들고 느리며 불필요하다.
- C++의 파괴자(destructor)와는 다른 개념이다!
	1.  C++의 파괴자는 객체와 관련된 자원을 회수하는 보편적인 방법이다. 
		- 반면 자바에서는 접근할 수 없게 된 객체를 회수하는 역할을 GC가 담당하고 있다.
	2. C++의 파괴자는 비메모리 자원을 회수하는 용도로도 쓰인다.
		- 반면 자바에서는 try-with-resources와 try-finally를 사용해 해결한다.
-  finalizer와 cleaner는 즉시 수행된다는 보장이 없다 -> 제 때 수행해야 하는 작업은 절대 할 수 없다.
	- 이 수행 속도는 GC 구현과 수행 시점에 의존하는 프로그램의 동작에 달려있다.
	- finalizer 스레드의 우선 순위 문제로 인해서 오히려 자원 회수가 지연되는 문제가 발생할 수 있다.
		- cleaner의 경우 수행 스레드를 제어할 수는 있지만, 백그라운드에서 GC의 통제하에 수행되기에 여전히 문제 있다.
- 자바 언어 명세는 finalizer와 cleaner의 수행 시점뿐만 아니라 수행 여보도 보장하지 않는다.
	- 따라서 상태를 영구 수정하는 작업에서는 절대 사용해서는 안 된다.
		- ex) DB 공유자원의 영구 lock 해제
- `System.gc`, `System.runFinalization` 메서드는 finalizer와 cleaner의 실행 가능성을 높일 수 있으나, 보장하지는 못한다.
