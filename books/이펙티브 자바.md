﻿﻿﻿﻿﻿﻿﻿﻿﻿﻿﻿﻿﻿﻿﻿﻿﻿﻿# 1장 들어가기
### 기술 용어 사용
- **자바 언어 명세(JLS, The Java Language Specification)**: 이 책에서는 자바8용 명세 따름
	- 지원 자료형
		- 인터페이스
			- Annotation
		- 클래스
			- Enum
		- 배열
		- 기본 타입(primitive): 유일하게 참조형이 아님(객체가 아님)
	- 클래스의 멤버
		- 필드
		- 메서드
			- 메서드 시그니처: 메서드 이름 + 입력 매개변수의 타입들 (!반환값의 타입)
		- 멤버 클래스
		- 멤버 인터페이스
- 자바 언어 명세와 다른 부분
	- 상속(inheritance) = 서브클래싱(subclassing)
	- 인터페이스 상속 -> 클래스가 인터페이스를 구현(implement), 인터페이스가 다른 인터페이스를 확장(extend)
	- 명시하지 않은(default) 접근 수준(access level)
		- 패키지 접근(package access) -> 패키지-프라이빗(package-private)
- 자바 언어 명세에 정의되지 않은 것들
	- 공개(exported) API(Application Programming Interface)
		- 프로그래머가 클래스, 인터페이스, 패키지를 통해 접근할 수 있는 모든 클래스, 인터페이스, 생성자, 멤버, 직렬화된 형태(serialized form)
			- API 요소(element): 클래스, 인터페이스, 생성자, 멤버, 직렬화된 형태
		- 자바 지원 자료형인 인터페이스와 구별하기 위해 사용한 용어
		- API를 사용하는 프로그램 작성자(사람): API의 사용자
		- API를 사용하는 클래스(코드): API 클라이언트
		- 공개 API는 API 정의 패키지의 밖에서 접근 가능한 요소로 구성 -> 모든 클라이언트가 접근할 수 있고, API작성자가 지원하기로 약속한 요소
			- javadoc을 기본 실행시 API요소들만 담은 문서 생성
		- 패키지의 공개 API는 패키지의 모든 public 클래스, 인터페이스의 public, protected 멤버와 생성자로 구성
			- 자바 9의 모듈 시스템을 통해 공개할 패키지 선택 가능



# 2장 객체 생성과 파괴

## 아이템1: 생성자 대신 정적 팩터리 메서드를 고려하라
```java
public static Boolean valueOf(boolean b) {
    return b ? Boolean.TRUE : Boolean.FALSE;
}
```
- 디자인 패턴의 팩터리 메서드(Factory Method)와는 다름!
- 해당 클래스의 인스턴스를 반환하는 단순한 정적 메서드


### 정적 팩터리 메서드가 생성자보다 좋은 점
1. **이름을 가질 수 있다**
- 생성자: `BigInteger(int, int, Random)`에 비해
정적 팩터리 메서드 `BigInteger.probablePrime`이 더 직관적이다.
- 생성자 오버로딩을 이용하는 데에도 한계가 있다.
	- 하나의 시그니처로는 생성자를 하나만 가질 수 있다.
		- 매개변수의 순서를 다르게 하는 방식
			- `Constructor(int i, String s)`와
			- `Constructor(String s, int i)`는 서로 다르다는 점을 이용하는 방식
			- 하지만 이 경우 직관성이 떨어지고, 혼란만 가중시킨다.
		- 반면, 정적 팩터리 메서드는 하나의 시그니처로 하나의 생성자만 가질 수 있는 제약을 받지 않는다.
2. **호출될 때마다 인스턴스를 새로 생성하지는 않아도 된다.**
- 인스턴스 통제(instance-controlled) 클래스
	- 인스턴스 미리 만들기, 캐싱 등으로 불필요한 객체 생성 회피 -> 성능 향상
	- 인스턴스 통제를 통해 객체를
		- 싱글턴(singleton)
		- 인스턴스화 불가(noninstantiable)
		- 불변 값 인스턴스에서 동치인 인스턴스가 하나임을 보장(Leibniz's law)
		- 플라이웨이트 패턴
		- 열거형(인스턴스가 하나임을 보장)
		만들 수 있다.
3. **반환 타입의 하위 타입 객체를 반환할 수 있는 능력이 있다.**
- 반환 객체의 클래스를 선택 가능한 유연성
	- API를 작게 유지
	- 인터페이스 기반 프레임워크: 인터페이스를 정적 팩터리 메서드의 반환 타입으로 사용
		- 구현 객체를 인터페이스로 다룬다는 점에서 API 학습 난이도를 낮추며, 다형성을 활용하기 좋다.
- Java8이전의 경우 인터페이스에서 정적 메서드 반환 불가
	- 동반 클래스 사용해야:
	```java
	public interface Type {
	    ...
	}
	```
	이를 반환하는 정적 메서드`typeFactory()` Type 내에 생성이 불가능하기에
	```java
	public class Types {
	    static Type typeFactory() {
	    ...
	    }
	}
	```
	위와 같은 방식으로 동반 클래스(companion class)를 만들어야 했다.
	- 예시) java.util.Collections
- 자바8 이후로는 인터페이스가 정적 메서드를 가질 수 있다.
	- 즉 동반 클래스를 가질 필요가 적다.
	- 하지만 인터페이스는 public 정적 멤버만 허용하며
	- 자바9에서 private 정적 메서드까지 허용하지만, 어쨌든 정적 필드와 정적 멤버 클래스는 여진히 public만 가능하다.
	- 이런 이유로 package-private 클래스에 정적 메서드 구현 코드 일부를 둬야 하는 경우도 있다.
4. **입력 매개변수에 따라 매번 다른 클래스의 객체를 반환할 수 있다.**
  - 유연하게 반환 하위 클래스를 선택, 변경할 수 있다.
  - 위와 마찬가지로, 다형성을 활용하는 데 용이하다. 클라이언트는 실제 어느 하위 클래스의 인스턴스인지를 알 필요가 없다.
  - 예시: `java.util.EnumSet.java`의 경우

  ```java
  /**
   * Creates an empty enum set with the specified element type.
   *
   * @param <E> The class of the elements in the set
   * @param elementType the class object of the element type for this enum
   *     set
   * @return An empty enum set of the specified type.
   * @throws NullPointerException if {@code elementType} is null
   */
  public static <E extends Enum<E>> EnumSet<E> noneOf(Class<E> elementType) {
      Enum<?>[] universe = getUniverse(elementType);
      if (universe == null)
          throw new ClassCastException(elementType + " not an enum");
  
      if (universe.length <= 64)
          return new RegularEnumSet<>(elementType, universe);
      else
          return new JumboEnumSet<>(elementType, universe);
  }
  ```

  원소의 수에 따라 `RegularEnumSet`이나 `JumboEnumSet`을 반환한다.

  - 하위 클래스이기만 한다면

    - 클라이언트가 하위 클래스의 존재를 모르며,

    - 필요 없는 하위 클래스는 삭제해도 문제가 없으며

    - 필요한 다른 클래스를 추가해도 된다는 점에 주목하라.

5. **정적 팩터리 메서드를 작성하는 시점에는 반환할 객체의 클래스가 존재하지 않아도 된다.**

  - 서비스 제공자 프레임워크(service provider framework)
   - 대표적인 예로 JDBC(Java Database Connectivity)
   - 제공자(provider)인 서비스 구현체들을 클라이언트에 제공하는 역할을 프레임워크가 담당 -> 클라이언트를 구현체로부터 분리!
  	- 구성: 3개의 핵심 컴포넌트(경우에 따라 +1)
        		- 서비스 인터페이스(service inteface): 구현체의 동작을 정의
  	- 제공자 등록 API(provider registration API): 제공자가 구현체를 등록할 때 사용
  
  	- 서비스 접근 API(service access API): 클라이언트가 서비스의 인스턴스를 얻을 때 사용
        		- 클라이언트가 원하는 구현체의 조건을 명시하여 반환받음, 명시하지 않으면 기본 구현체 혹은 지원 구현체 중 하나를 반환
                		- 유연한 정적 팩터리

~~~java
		```java
		    @CallerSensitive
		    public static Connection getConnection(String url,
		        java.util.Properties info) throws SQLException {
		
		        return (getConnection(url, info, Reflection.getCallerClass()));
		    }
		...
		    @CallerSensitive
		    public static Connection getConnection(String url,
		        String user, String password) throws SQLException {
		        java.util.Properties info = new java.util.Properties();
		
		        if (user != null) {
		            info.put("user", user);
		        }
		        if (password != null) {
		            info.put("password", password);
		        }
		
		        return (getConnection(url, info, Reflection.getCallerClass()));
		    }
		...
		    @CallerSensitive
		    public static Connection getConnection(String url)
		        throws SQLException {
		
		        java.util.Properties info = new java.util.Properties();
		        return (getConnection(url, info, Reflection.getCallerClass()));
		    }
		...
		        //  Worker method called by the public getConnection() methods.
		    private static Connection getConnection(
		        String url, java.util.Properties info, Class<?> caller) throws SQLException {
		        /*
		         * When callerCl is null, we should check the application's
		         * (which is invoking this class indirectly)
		         * classloader, so that the JDBC driver class outside rt.jar
		         * can be loaded from here.
		         */
		        ClassLoader callerCL = caller != null ? caller.getClassLoader() : null;
		        if (callerCL == null || callerCL == ClassLoader.getPlatformClassLoader()) {
		            callerCL = Thread.currentThread().getContextClassLoader();
		        }
		
		        if (url == null) {
		            throw new SQLException("The url cannot be null", "08001");
		        }
		
		        println("DriverManager.getConnection(\"" + url + "\")");
		
		        ensureDriversInitialized();
		
		        // Walk through the loaded registeredDrivers attempting to make a connection.
		        // Remember the first exception that gets raised so we can reraise it.
		        SQLException reason = null;
		
		        for (DriverInfo aDriver : registeredDrivers) {
		            // If the caller does not have permission to load the driver then
		            // skip it.
		            if (isDriverAllowed(aDriver.driver, callerCL)) {
		                try {
		                    println("    trying " + aDriver.driver.getClass().getName());
		                    Connection con = aDriver.driver.connect(url, info);
		                    if (con != null) {
		                        // Success!
		                        println("getConnection returning " + aDriver.driver.getClass().getName());
		                        return (con);
		                    }
		                } catch (SQLException ex) {
		                    if (reason == null) {
		                        reason = ex;
		                    }
		                }
		
		            } else {
		                println("    skipping: " + aDriver.driver.getClass().getName());
		            }
		
		        }
		
		        // if we got here nobody could connect.
		        if (reason != null)    {
		            println("getConnection failed: " + reason);
		            throw reason;
		        }
		
		        println("getConnection: no suitable driver found for "+ url);
		        throw new SQLException("No suitable driver found for "+ url, "08001");
		    }
~~~

​	제공된 파라미터에 따라서 실제로 getConnection() 작업을 하는 메서드에 형식을 맞춰 파라미터를 넘기고, 인터페이스로서 Driver를 받고 있다.
​	
 - 그런데 왜 리플렉션을 사용할까?

- 서비스 제공자 인터페이스(service provider interface): 서비스 인터페이스의 인스턴스를 생성하는 팩터리 객체를 설명

  - 리플렉션?
  		- 서비스 제공자 프레임워크 패턴의 변형
		- 브리지 패턴: 서비스 접근 API가 공급자가 제공하는 것보다 더 풍부한 서비스 인터페이스를 클라이언트에 반환
		- DI 프레임워크
			- `java,util.ServiceLoader`: 자바6부터 제공되는 범용 서비스 제공자 프레임워크
			- JDBC의 경우 자바6 이전에 등장했기에 위를 사용 안 함.



### 단점
1. **상속을 하려면 public이나 protected 생성자가 필요하니 정적 팩터리 메서드만 제공하면 하위 클래스를 만들 수 없다.**
	- 상속보다 컴포지션을 사용하도록 유도하고
	- 불변 타입으로 만들기 위한 제약이 된다는 점에서 장점이 되기도 한다.
2. **정적 팩터리 메서드는 프로그래머가 찾기 어렵다.**
	- 생성자처럼 API 설명에 명확히 들어나지 않기 때문(JavaDocs)
	- API 문서를 잘 작성하고 메서드명을 규약에 따라 짓는 것으로 문제를 완화해야:
	- 정적 팩터리 메서드에 흔한 명명 방식
		- from: 매개변수를 받아서 해당 타입의 인스턴스를 반환하는 형변환 메서드
			- `Date d = Date.from(instant);`
		- of: 여러 매개변수를 받아 적합한 타입의 인스턴스를 반환하는 집계 메서드
			- `Set<Rank> faceCards = EnumSet.of(JACK, QUEEN, KING)`
		- valueOf: from과 of의 더 자세한 버전
			- `BigInteger prime = BigInteger.valueOf(Integer.MAX_VALUE);`
		- instance 혹은 getInstance: (매개변수를 받는다면) 매개변수로 명시한 인스턴스를 반환하지만, 같은 인스턴스임을 보장하지는 않는다.
			- `StackWalker luke = StackWalker.getInstance(options);`
		- create 혹은 newInstance: instance 혹은 getInstance와 같지만, 매번 새로운 인스턴스를 생성해 반환함을 보장한다.
			- `Object newArray = Array.newInstance(classObject, arrayLen);`
		- getType: getInstance와 같으나, 생성할 클래스가 아닌 다른 클래스에 팩터리 매서드를 정의할 때 쓴다. "Type"은 팩터리 메서드가 반환할 객체의 타입이다.
			- `FileStore fs = Files.getFileStore(path);`
		- newType: getType과 같으나, 매번 새로운 인스턴스를 생성해 반환함을 보장한다.
			- `BufferedReader br = Files.newBufferedReader(path);`
		- type: getType과 newType의 간결한 버전
			- `List<Complaint> litany = Collections.list(legacyLitany);`
> 핵심 정리
> 정적 팩터리 메서드와 public 생성자는 각자의 쓰임새가 있으니 상대적인 장단점을 이해하고 사용하는 것이 좋다. 그렇다고 하더라도 정적 팩터리를 사용하는 게 유리한 경우가 많으므로 무작정 public 생성자를 제공하던 습관이 있다면 고치자.

## 아이템 2: 생성자에 매개변수가 많다면 빌더를 고려하라.
- 아이템 2: 생성자에 매개변수가 많다면 빌더를 고려하라.
  - 정적 팩터리와 생성자의 공통 제약사항: 선택적 매개변수가 많을 경우 대응이 어렵다.

### 선택 매개변수가 많을 때 대응법
1. **점층적 생성자 패턴(telescoping constructor pattern)**
```java
public class NutritionFacts {
    private final sevingSize;
    private final servings;
    private final int calories;
    private final int fat;
    private final int sodium;
    
    public NutritionFacts(int servingSize, int servings) {
    this(servingSize, servings, 0);
    }
    
    public NutritionFacts(int servingSize, int servings, int calories) {
    this(servingSize, servings, calories, 0);
    }

    public NutritionFacts(int servingSize, int servings, int calories, int fat) {
    this.servingSize = servingSize;
    this.servings = servings;
    this.calories = calories;
    this.fat = fat;
    }
}
```
- 설정하길 원하지 않는 매개변수에도 값을 지정해줘야 함
- 코드 가독성이 낮고 수정 및 사용이 어려움

2. **자바빈즈 패턴(JavaBeans pattern)**
- 기본 생성자로 객체 생성 후 Setter로 값 설정
- 단점
	- 객체 하나를 생성하기 위해 Setter를 여러 번 호출해야 한다.
	- 객체가 완전히 생성되기 전까지는 일관성(consistency)이 무너진 상태에 놓인다.
		- 때문에 클래스를 불변으로 만들 수 없으며
		- 스레드 안전성을 얻기 위해 추가 작업이 필요하다.
	- freeze 메서드
		- 생성이 끝난 객체를 얼리며(freeze) 얼리기 전에는 사용하지 못 하게 만들어 위의 단점을 완화하려는 기법
		- 하지만 freeze 메서드를 객체 사용 전에 호출하였는지를 컴파일 단계에서 검증 불가하기에 런타임 오류에 취약하다.
3. 빌더 패턴
- 점층적 생성자 패턴의 안전성과 자바빈즈 패턴의 가독성을 갖춤

###  빌더 패턴(Builder Pattern)
- 작동방식
	- 필수 매개변수만으로 생성자 / 정적 팩터리를 호출하여 빌더 객체를 얻는다.
	- 빌더 객체의 설정 메서드(Setter와 유사)로 선택 매개변수를 설정한다.
	- 매개변수가 없는 build 메서드를 호출해 필요한 (일반적으로는 불변) 객체를 얻는다.
- 빌더는 생서할 클래스 안에 정적 멤버 클래스로 만들어두는 것이 보통이다.
- 의문사항: NutritionFacts 클래스는 불변???
- Builder의 Setter 메서드
	- 자기 자신을 반환하므로 메서드 연쇄 가능
		- 메서드 연쇄(method chaining) = 플루언트 API(fluent API)
	- 메서드명을 속성명으로 하면 가독성이 좋은 코드를 짤 수 있다:
	- `NutritionFacts cocacola = NutritionFacts.Builder(240, 8).calories(100).sodium(35).carbohydrate(27).build();`
	- 빌더 패턴은 파이썬/스칼라의 명명된 선택적 매개변수(named optional parameters)를 흉내낸 것이다.
- 유효성 검사 코드
	- 빌더의 생성자와 메서드에서 입력 매개변수를 검사
	- build 메서드가 호출하는 생성자 = NutritionFacts(Builder builder)에서 여러 매개변수에 걸친 불변식(invariant)을 검사
		- 빌더로부터 매개변수를 복사한 후 해당 객체 필드도 검사한다.
		- 문제 발견시 IllegalArgumentException
		- 

#### 불변과 불변식
- 불변(immutable or immutability)
	- 변경을 허용하지 않는다. <-> 가변(mutable) 객체
		- Ex) String
- 불변식(invariant)
	- 프로그램이 실행되는 동안 or 정해진 기간 동안 반드시 만족해야 하는 조건
	- 변경 허용이 가능하지만 조건 내에서만 가능
		- Ex) List의 크기는 0 이상, Period의 start필드 값은 end 필드 값보다 앞서야 함
- 가변 객체에도 불변식은 존재할 수 있으며 불변은 불변식의 극단적인 예라고 할 수 있다.
- 

### 빌더와 계층적 클래스
- 각 계층의 클래스에 관련 빌더를 멤버로 정의
	- 추상 클래스는 추상 빌더를, 구체 클래스(concrete class)는 구체 빌더를 갖게 함
	- EnumSet에 대해 추가!!!!
	- 시뮬레이트한 셀프 타입(simulated self-type) 관용구: self 타입이 없는 자바에서 self메서드 정의하여 사용
		- 이를 통해 형변환 없이 메서드 연쇄 지원
	- 공변 변환 타이핑(covariant return typing): 하위 클래스의 메서드가 상위 클래스의 메서드가 정의한 반환 타입이 아닌, 그 하위 타이블 반환하는 기능
		- 이를 통해 형변환 없이 빌더 사용 가능

### 그 외
- 빌더를 사용하면 가변인수(varargs) 매개변수를 여러 개 사용할 수 있다.
	- 각각을 적절한 메서드로 나눠 선언하거나
	- 메서드를 여러 번 호출하도록 하고 각 호출 때 남겨진 매개변수들을 하나의 필드로 모음
	
- 빌더는 매우 유연함

- 단점
	- 객체 생성 이전에 빌더를 만들어야 함
		- 경우에 따라 성능에 부정적 영향
		
	- 매개변수가 많을 때에나 빛을 발함
		- 하지만 매개변수는 점차 늘어나는 법이기에 빌더로 애초에 만드는 것이 좋을 때가 많다.
		
		  

## 아이템3. private 생성자나 열거 타입으로 싱글톤임을 보증하라.
### 싱글톤
- 단일 인스턴스
- 예시
	- 함수와 같은 무상태(stateless) 객체
	- 설계상 유일해야 하는 시스템 컴포넌트
- 싱글톤 클래스는 이를 사용하는 클라이언트를 테스트하기 어렵게 만들 수 있음 - mock 구현으로 대체가 어렵기 때문
### 싱글톤의 생성 방식
- 1, 2 모두 생성자는 private로 감추고, 인스턴스 접근 수단으로 public static 멤버를 남겨둠
#### 1.  private static final 필드 방식
```java
public class Elvis {
    public static final Evlis INSTANCE = new Elvis();
    private Elvis() {...}
	    
    public void leaveTheBuilding() {...}
}
```
- private 생성자는 private final인 싱글턴 인스턴스를 초기화할 때 단 한번만 호출된다.
- **코드가 싱글턴임이 API에 명백하게 드러난다는 장점**
- 이 인스턴스가 싱글턴임이 보장되지만 유일하게 예외가 있는데, 리필렉션 API인 `AccessibleObject.setAccessible`을 사용해 private 생성자를 호출하는 공격이 있을 수 있다.
	- 이를 예방하려면 생성자 차원에서 2번째 객체가 생성되려 할 때 예외를 던지도록 한다.
#### 2. 정적 팩터리 방식의 싱글턴
```java
public class Elvis {
    private static final Elvis INSTANCE = new Elvis();  
    private Elvis() {...}
    public static Elvis getInstance() {return INSTANCE;}
    
    public void leaveTheBuilding() {...}
}
```
- 동일 객체의 참조를 반환하기에 싱글턴 보장(단, 이 경우에도 리플렉션을 통한 예외는 동일)
- **장점**
	- API를 변경하지 않고도 싱글턴이 아니게 할 수 있다.
	- 정적 팩터리를 제네릭 싱글턴 팩터리로 만들 수 있다.
	- 정적 팩터리의 메서드 참조를 공급자(supplier)로 사용할 수 있다.
		- `Elvis::getInstance`를 `Supplier<Elvis>`로 사용하는 방식

#### 3. 열거 타입 방식
```java
public enum Elvis {
    INSTANCE;
    
    public void leaveTheBuilding() {...}
```
- 원소가 하나인 열거 타입을 선언하는 것
- public 필드 방식과 비슷하지만 추가적인 노력 없이 직렬화가 가능
- 복잡한 직렬화 상황이나 리플렉션 공격에서도 제2의 인스턴스 생성을 완전히 막음

### 직렬화
- 1과 2의 방식으로 만든 싱글턴 클래스를 직렬화하려면 단순히 `implements Serializable`로는 부족함
- 모든 인스턴스 필드를 일시적(transient)이라 선언하고 readResolve 메서드를 제공해야 함
	- 이렇게 하지 않을 경우 역직렬화할 때 마다 새로운 인스턴스가 만들어진다.
```java
private Object readResolve() {
    // '진짜' Elvis를 반환하고, 가짜 Elvis는 가비지 컬렉터에 맡긴다.
    return INSTANCE;
}
```

### 정리
- 직렬화에 관해서 가장 용이한것은 3
	- 대부분 상황에서는 3의 방식: 원소가 하나뿐인 열거 타입이 싱글턴을 만드는 가장 좋은 방법
	- 단 Enum 외의 클래스를 상속해야 할 경우 3은 사용 불가
		- 열거 타입이 다른 인터페이스를 구현하도록 선언하는 것은 불가하기 때문
	
- 2의 장점: 변경 용이성 / 정적 팩터리의 메서드 참조를 공급자로 사용이 필요하지 않다면 1이 나음

  

## 아이템4. 인스턴스화를 막으려거든 private 생성자를 사용하라
- 정적 메서드와 정적 필드만을 담은 클래스
	- 예시
		- `java.lang.Math`와 `java.util.Array`: 기본 타입 값이나 배열 관련 메서드를 모아놓음
		- `java.util.Collections`: 특정 인터페이스를 구현하는 객체를 생성해주는 정적 메서드(혹은 팩터리) 모음(자바 8부터는 인터페이스에 넣을 수 있다)
		- final 클래스와 관련한 메서드를 모을 경우: final클래스를 상속해서 하위 클래스에 메서드를 넣는 건 불가능하기 때문
	- 인스턴스 없이 사용하려고 설계한 유틸리티 클래스
		- 생성자를 명시하지 않으면 public 기본 생성자가 만들어지기에, 의도치 않게 인스턴스화 가능해짐
- 인스턴스화를 막기 위해서
	- 추상 클래스로 만드는 것으로는 부족
		- 하위 클래스를 만들어서 인스턴스화할 수 있기 때문
		- 상속해서 사용하라는 의미로 오독될 수도 있다.
	- **private 생성자를 추가하여 클래스의 인스턴스화를 막아라!**
```java
public class UtilityClass() {
    // 기본 생성자가 만들어지는 것을 막는다(인스턴스화 방지용).
    private UtilityClass() {
        throw new AssertionError();
    }
    ...
}
```
- AssertionError는 클래스 내부에서 생성자를 호출하는 경우를 대비
- 호출 불가능한 생성자는 직관성이 낮기 때문에 주석을 달아주는 편이 좋음
- 상속을 불가능하게 만든다.
	- 모든 생성자는 명시적/묵시적으로 상위 클래스의 생성자를 호출하게 된다. private 생성자는 하위 클래스가 상위 클래스 생성자에 접근할 수 없게 하기에 상속이 불가하게 만든다.

## 아이템5. 자원을 직접 명시하지 말고 의존 객체 주입을 사용하라
### 자원에 의존하는 클래스 구현: 사전에 의존하는 맞춤법 검사기 사례
#### 부정적 예시
1.  정적 유틸리티 클래스
```java
public class SpellChecker {
    private final Lexicon dictionary =...;
    
    private SpellChecker() {} // 객체 생성 방지
    
    public static boolean isValid(String word) { ... }
    public static List<String> suggestions(String typo) { ... }
}
```

2. 싱글톤
```java
public class SpellChecker {
    private final Lexicon dictionary = ...;
    
    private Spellchecker(...) {}
    public static SpellChecker INSTANCE = new pellChecker(...);
    
    public boolean isValid(String word) { ... }
    public List<String> suggestions(String typo) { ... }
}
```
- 1과 2는 모두 자원(사전)을 단 하나만 사용한다고 가정한다는 점이 단점이다.
	- 실제로는 다양한 자원을 사용할 수 있어야 한다.
	- 대안: dictionary 필드를 final하지 않게 만드는 방법
		- 오류를 내기 쉬우며 멀티스레드 환경에서 사용 불가
	- 사용하는 자원에 따라 동작이 달라지는 클래스에는 정적 유틸리티 클래스나 싱글톤 방식은 부적합하다.

#### 대안: 의존 객체 주입 패턴
```java
public class SpellChecker {
    private final Lexicon dictionary;
    
    public SpellChecker(Lexicon dictionary) {
    
}
```

- 인스턴스를 생성할 때 생성자에 필요한 자원을 넘겨주는 방식

- 자원의 수나 의존관계와 무관하게 작동

- 불변을 보장, 동일 자원 공유를 안전하게 할 수 있음

- 생성자, 정적 팩터리, 빌더 모두에 적용 가능한 방법

- 변형: 생성자에 자원 팩터리를 넘겨주는 방식
	- 한정적 와일드카드 타입(bounded wildcard type)을 이용해 팩터리 타입 매개변수를 제한해야
		- 예시
	```java
	Mosaic create(Supplier<? extends Tile> tileFactory) {...}
	```
	
- 단, 의존성이 많은 프로젝트에서는 코드를 어지럽힐 수 있다: 의존 객체 주입 프레임워크를 사용하여 해결하라

- 의문사항: 왜 싱글톤을 사용해서 안 되나? 싱글톤에 DI 사용하면 되지 않나(스프링의 경우)?



## 아이템6. 불필요한 객체 생성을 피하라
- 생성보다는 재사용이 더 낫다.
- 불변 객체는 재사용이 언제나 가능하다.
- 정적 팩터리 메서드를 사용하여 불필요한 객체 생성을 피할 수 있다.
	- `Boolean(String)` 대신 `Boolean.valueOf(String)`을 사용하는 것이 좋다.
	- 가변 객체의 경우 사용중 변경이 없을 것임을 안다면 재사용 가능하다.
- 생성 비용비 비싼 객체가 자주 필요할 경우 캐싱하여 재사용하라.
	- 정적 멤버로 자주 불변 인스턴스를 캐싱해둔다.
	- 만일 클래스 호출: 인스턴스 초기화 이후 메서드를 호출하지 않는다면 성능상 낭비가 된다.
		- 이를 막기 위해 지연 초기화를 사용할 수 있으나 성능상의 이점이 미미한 반면 코드를 복잡하게 만들기에 사용을 권하지 않는다.
- 재사용 직관성: 보충
	- 어댑터 패턴
	- 오토박싱
		- 기본형과 박싱된 클래스의 구별을 흐리지만 성능 상으로 차이가 있음에 유의
		- long이 아니라 Long으로 선언한 것 만으로 불필요한 인스턴스를 매우 많이 만들게 될 수도 있다.
		- 박싱된 기본 타입보다는 기본 타입을 사용하고, 의도치 않은 오토박싱이 숨어들지 않게 주의해야
- 그러나 기본적으로는 객체 생성을 피하기 보다는, 명확성, 간결성, 기능을 위한 것일 경우 추가하는 것이 더 좋은 선택이다. 
	- 요즘 JVM은 작은 객체를 생성, 회수하는 것에 부담이 적기 때문
- 객체 풀을 직접 설정하는 것은 피하라
	- DB연결 풀처럼 생성 비용이 비싼 경우는 물론 예외
	- 하지만 기본적으로 객체 풀은 코드를 혼잡하게 하며 성능상 이점이 낮다. -> GC가 발달해서 가벼운 객체의 경우 GC가 더 빠름
- 방어적 복사가 필요한 상황에서 객체를 재사용했을 때의 피해가, 불필요한 객체를 반복 생성했을 때의 피해보다 훨씬 크다는 점에 유의하라.



## 아이템7. 다 쓴 객체 참조를 해제하라
- 자바에는 GC가 있지만 메모리 관리는 여전히 필요하다.
- Stack의 사례
	```java
	public class Stack {
	    private Object[] elements;
	    private int size;
	    
	    ...
	    
	    public Object pop() {
	        if (size == 0)
	            throw new EmptyStackException();
	        return elements[--size];
	    }
	    
	    ...
	}
	```
	- pop으로 인해 활성 영역 밖으로 밀려난 elements[size]에 대한 참조를 Stack이 가지고 있기 때문에 이는 GC가 회수하지 않는다.
	- 참조가 남아 있을 경우 그 참조가 참조하는 것들도 GC가 회수하지 못하므로 누수는 더 커진다.
### null 처리(참조 해제)
```java
public Object pop() {
    if (size ==0)
        throw new mptyStackException();
    Object result = elements[--size];
    elements[size] = null; // 다 쓴 참조 해제
    return result;
}
```
- 활성 영역 밖의 원소를 접근하려고 하면 NPE가 발생한다. 오류 발견에 도움이 된다.
#### null 처리는 언제 사용해야 하나?
- 예외적인 경우에만 사용하는 것이 기본이다.
	- 참조를 담은 변수를 유효 범위(scope) 밖으로 밀어내는 것이 낫다.
	
- Stack의 예시처럼 자기 메모리를 직접 관리하는 경우, 쓸모 없는 객체를 GC는 인지할 수 없기에 직접 null처리 해주는 것이다.

- 자기 메모리를 직접 관리하는 클래스는 메모리 누수를 주의해야 한다.

- 캐시는 메모리 누수의 주범이다. 객체 참조를 캐시에 넣고, 객체의 다 쓴 참조(osolete reference)를 그대로 가지고 있는 경우가 있다.
	- 해법: WeakHashMap
	- LinkedHashMap
	
- listener, callback
	- weak reference
	
	

## 아이템8. finalizer와 cleaner 사용을 피하라

### 자바의 두 가지 객체 소멸자
- finalizer: 기본적으로 사용하지 마라. 예측 힘들고 위험하다.
- cleaner: finalizer보다는 덜 위험하지만 여전히 예측하기 힘들고 느리며 불필요하다.
- C++의 파괴자(destructor)와는 다른 개념이다!
	1.  C++의 파괴자는 객체와 관련된 자원을 회수하는 보편적인 방법이다. 
		- 반면 자바에서는 접근할 수 없게 된 객체를 회수하는 역할을 GC가 담당하고 있다.
	2. C++의 파괴자는 비메모리 자원을 회수하는 용도로도 쓰인다.
		- 반면 자바에서는 try-with-resources와 try-finally를 사용해 해결한다.
### 난점
1.  finalizer와 cleaner는 즉시 수행된다는 보장이 없다 -> 제 때 수행해야 하는 작업은 절대 할 수 없다.
	- 이 수행 속도는 GC 구현과 수행 시점에 의존하는 프로그램의 동작에 달려있다.
	- finalizer 스레드의 우선 순위 문제로 인해서 오히려 자원 회수가 지연되는 문제가 발생할 수 있다.
		- cleaner의 경우 수행 스레드를 제어할 수는 있지만, 백그라운드에서 GC의 통제하에 수행되기에 여전히 문제 있다.
2. 자바 언어 명세는 finalizer와 cleaner의 수행 시점뿐만 아니라 수행 여부도 보장하지 않는다.
	- 따라서 상태를 영구 수정하는 작업에서는 절대 사용해서는 안 된다.
		- ex) DB 공유자원의 영구 lock 해제
	- `System.gc`, `System.runFinalization` 메서드는 finalizer와 cleaner의 실행 가능성을 높일 수 있으나, 보장하지는 못한다.
	- `System.runFinalizersOnExit`와 `Runtime.runFinalizersOnExit`메서드는 보장은 해주지만 심각한 결함으로 사용해서는 안 된다.
3. finalizer동작 중 예외 발생시 예외 무시되며, 작업이 그 순간 종료 되어 버린다.
	- 다른 스레드가 이 훼손된 객체를 접근할 때의 동작을 예측할 수 없다.
		- cleaner 사용하는 라이브러리의 경우 스레드를 통제하기 때문에 이 문제는 발생하지 않음
4. 성능 문제
	- GC의 효율을 떨어뜨린다.
	- 안전망 방식을 사용할 경우에는 훨씬 빨라진다. (단 여전히 성능이 낮긴 하다)
5. 보안 문제: finalizer 공격
	- 생성자/직렬화 과정에서 예외 발생시, 생성되다 만 객체에서 악의적인 하위 클래스의 finalizer가 수행될 수 있음
	- 정적 필드에 자기의 참조를 할당하여 GC의 수집대상이 되지 않을 수 있다.
	- 해결
		- 일반적인 객체의 생성을 막는 것은 생성자에서 예외를 던지는 것으로 가능하지만, finalizer의 경우 부족
		- final 클래스들은 하위 클래스를 만들 수 없기에 이 문제에서 안전
		- final이 아닌 클래스들은 아무 일도 하지 않는 finalize 메서드를 만들고 final로 선언하면 된다.
### 대안: AutoCloseable
- 파일, 스레드 등 종료해야 할 자원을 담고 있는 객체 클래스는 AutoCloseable을 구현하게 하라.
- 사용 후 `close()`메서드를 호출하여 관리한다.
- 단, try-with-resources를 사용하여 예외 발생 시에도 정상적인 종료를 보장해야 한다.
- close 여부를 추적하게끔 하라
	- close메서드에서 객체가 더 이상 유효하지 않음을 필드에 기록하라
	- 다른 메서드에서 이 필드를 사용할 때는 검사를 통해, close 이후일 경우 IllegalStateException을 던지게 하라
### 사용해도 될 때
1. 자원의 소유자가 close 메서드를 호출하지 않는 것에 대비하는 안전망 역할
	- `FileInputStream`, `FileOutputStream`, `ThreadPoolExecutor`가 그 대표적 예
2. 네이티브 피어(native peer)와 연결된 객체
	- 네이티브 피어: 일반 자바 객체가 네이티브 메섣를 통해 기능을 위임한 네이티브 객체
	- 자바객체가 아니기의 GC가 인지못함
	- 단, 성능 저하를 감당할 수 있으며, 네이티브 피어의 자원이 중요한 것이 아닐 때에만 사용
		- 이에 해당하지 않을 때는 그냥 close 메서드를 사용하라.
	- finalizer와 달리 cleaner는 클래스 public API에 나타나지 않음
	- cleaner의 사용은 내부 구현 문제

## 아이템9. try-finally보다는 try-with-resources를 사용하라
- try-finally
	```java
	static String firstLineOfFile(String path) throws IOException {
	    BufferedReader br = new BufferedReader(new FileReader(path));
	    try {
	        return br.readLine();
	    } finally {
	        br.close();
	    }
	}
	```
	- 자원을 하나 더 사용하게 될 경우
		```java
		static void copy(String src, String dst) throws IOException {
		    InputStream in = new FileInputStream(src);
		    try {
		        OutputStream out = new FileOutputStream(dst);
		        try {
		            byte[] buf = new byte[BUFFER_SIZE];
		            int n;
		            while ((n = in.read(buf)) >= 0)
		                out.write(buf, 0, n);
		        } finally {
		            out.close();
		        }
	    	} finally {
		        in.close();
		    }
		}
		```
		- 자원이 추가되면 난잡해진다.
		- try 블록과 finally 블록 모두에 예외가 발생할 경우 후자의 예외가 전자의 예외를 집어삼켜, 스택 추적 내역에서 전자의 예외에 대한 정보는 남지 않게 된다. -> 디버깅이 어려워 진다.
	
- try-with-resources: 위의 문제들을 해결
	```java
	static String firstLineOfFile(String path) throws IOException {
	    try (BufferedReader br = new BufferedReader(new FileReader(path))) {
	        return br.readLine();
	    }
	}
	```
	- 자원을 하나 더 사용하게 될 경우
	```java
	static void copy(String src, String dst) throws IOException {
		    try (InputStream in = new FileInputStream(src);
		    OutputStream out = new FileOutputStream(dst)) {
		        byte[] buf = new byte[BUFFER_SIZE];
		        int n;
		        while ((n = in.read(buf)) >=0)
		            out.write(buf, o, n);
        }
	}
	```
	- 가독성이 향상되었다.
	- readLine과 close 양 쪽 모두에서 예외 발생시 readLine에서 발생한 예외가 기록된다.
		- close 쪽 예외는 숨겨지지만 스택 추적 내역에 suppressed 꼬리표를 달고 출력된다.
		- Throwable의 getSuppressed 메서드를 이용해서 프로그램 코드에서 가져올 수도 있다.
	- catch 절도 사용 가능하다: try문 중첩 없이 다수 예외를 처리 가능하다.
	
	
# 3장 모든 객체의 공통 메서드
- final이 아닌 Object 메서드(equals, hashCode, toString, clone, finalize)는 일반 규약에 맞게 재정의해야 한다.
-`Comparable.compareTo`는 Object 메서드는 아니지만 유사한 성격을 갖기에 여기서 다룬다.



## 아이템10. equals는 일반 규약을 지켜 재정의하라
### equals를 재정의하지 않는 경우
equals 메서드를 재정의하는 것은 위험부담이 있기 때문에 다음 상황 중 하나에 해당하면 재정의하지 않아도 된다.
- 각 인스턴스가 본질적으로 고유한 경우
	- 값을 표현하는 것이 아니라 동작하는 객체를 표현하는 클래스
	- Thread가 대표적인 예
- 인스턴스의 논리적 동치성(logical equality)을 검사할 일이 없는 경우
	- 검사할 필요가 있는 경우: `java.util.regex.Pattern`의 경우 재정의했음
- 상위 클래스에서 재정의한 equals가 하위 클래스에도 들어맞는 경우
	- AbstractSet, AbstractList, AbstractMap의 equals를 상속해서 사용하는 것의 그 예
- 클래스가 private이거나 package-private이고 equals 메서드를 호출할 일이 없는 경우
	- 실수로라도 호출을 막고 싶을 경우 다음과 같이 구현하면 된다:
	```java
	@Override
	public boolean equals(Object o) {
	    throws ew AssertionError(); //호출 금지!
	}
	```
	
### equals 재정의해야하는 경우
- 객체 식별성(object identity)가 아니라 논리적 동치성을 확인해야 하는데, 상위 클래스의 equals가 재정의되지 않았을 경우
	- 주로 값 클래스들이 해당
	- equals를 논리적 동치성을 확인하도록 재정의할 경우 Map의 키나 Set의 원소로 사용 가능하다.
	- 값 클래스라도 동일 값을 갖는 인스턴스가 둘 이상 생성되지 않음을 보장하는 경우라면 재정의할 필요 없다.
		- Enum도 여기에 해당
		- 이 경우 논리적 동치성과 객체 식별성이 동치가 되어버림

### equals 일반규약

`equals` 메서드는 null이 아닌 객체 참조들의 동등성 관계를 구현한다:

- 이는 *재귀적(reflexive)*이다: null이 아닌 모든 참조값 `x`에 대해서, `x.equals(x)`는 `true`를 반환해야 한다.
- 이는 *대칭적(symmetric)*이다: null이 아닌 모든 참조값 `x`와 `y`에 대해서, `x.equals(y)`는 `true`를 반환하는 것과 `y.equals(x)`가 `true`를 반환하는 것은 필요충분 관계이다.
- 이는 *추이적(transitive)*이다: null이 아닌 모든 참조값 `x`와 `y`, 그리고 `z`에 대해서, 만약 `x.equals(y)`가 `true`를 반환하고, `y.equals(z)`가 `true`를 반환한다면, `x.equals(z)`는 `true`를 반환해야 한다.
- 이는 *일관적(consistent)*이다: null이 아닌 모든 참조값 `x`와 `y`에 대해서, 만약 `equals`비교에 사용되는 객체들의 정보들이 변경되지 않는 한에서, `x.equals(y)`를 여러 번 호출하는 것(multiple invocations)은 일관성 있게 `true`를 반환하거나, 일관성 있게 `false`를 반환해야 한다.
- null이 아닌 참조값 `x`에 대하여 `x.equals(null)`은 `false`를 반환해야 한다.

`Object` 클래스의 `equals` 메서드는 객체 사이에서 가능한 한 구별적인 동등성 관계를 구현했다. 그것은, null이 아닌 모든 참조값 `x`와 `y`에 대해서, 이 메서드가 `true`를 반환하는 것은 `x`와 `y`가 동일한(same) 객체를 참조하는 것(`x == y`가 `true` 값을 가질 때)와 필요충분관계이다. 

일반적으로 이 메서드를 오버라이드 했을 때마다 `hashCode`를 오버라이드 하는 것이 일반적으로 필수적임을 주의하라. 동등한(equal) 객체들이 동등한 해시코드를 가져야 한다는 `hashCode` 메서드의 일반규약을 지키기 위함이다.

#### 추이성
- Point와 ColoredPoint의 예시
	- ColorPoint가 Point와 equals 비교할 때는 color 필드를 무시하게 구현할 경우, 대칭성은 지켜지지만 추이성이 무너짐
		- 가령, ColoredPoint의 equals(Object o)가 Point의 인스턴스이면서 ColoredPoint의 인스턴스가 아닌 경우에 o.equals(this)의 형태로 구현 된 경우
		- 같은 방식으로 equals를 구현한 Point의 다른 구체 클래스와 비교를 시도할 경우 무한 재귀의 위험성이 있다. 이 경우 각 구체 클래스의 equals를 무한히 서로 호출하게 될 것이다,
	- 이 문제는 모든 객체 지향 언어의 동치관계에서 나타나는 근본적인 문제다. 구체 클래스를 확장해 새로운 필드를 추가하면서 equals 규약을 만족시킬 방법은 존재하지 않는다.
		- 동일 구현 클래스 객체와 비교할 때만 true이게 구현한다고 해도
		- 이 경우에는 Point의 하위 클래스를 Point로 활용할 수 없게 된다.
		- 리스코프 치환 원칙을 위반한다!
- 대안: 상속 대신 컴포지션을 사용하는 방법
	- 상속 대신 Point를 ColorPoint의 private 필드로 두고, ColorPoint와 같은 위치의 일반 Point를 반환하는 public 뷰 메서드를 사용하는 방식
	- 자바 라이브러리의 예시: java.sql.Timestamp의 nanoseconds 필드는 java.util.Date의 확장
		- 이로 인해 Timetamp의 equals는 대칭성 위배, Date와 한 컬렉션에 넣거나 섞어 사용시 문제 발생

#### 일관성
- 불변 객체들의 경우 equals의 결과가 변화해선 안 된다.
- equals 판단에 신뢰할 수 없는 자원이 끼어들게 해서는 안 된다.
	- java.net.URL의 예

#### null-아님
- 명시적 null 검사는 불필요하다.
- 어차피 형변환을 통한 값 비교를 위해 instanceof 연산자로 매개변수가 올바른 타입인지 미리 살펴야 하기 때문이다.

### 정리
#### equals 구현 방법 - 단계별 정리
1. ==연산자를 사용해 입력이 자기 자신의 참조인지 확인한다.
	- 성능 최적화용이다.
2. instanceof 연산자로 입력이 올바른 타입인지 확인한다.
	- 경우에 따라 equals 구현된 클래스가 아니라 그것이 구현한 인터페이스인지 검사할 때도 있다.
	- Set, List, Map, Map.Entry가 그 예다.
3. 입력을 올바른 타입으로 형변환한다.
	- 2로 인해서 무조건 성공
4. 입력 객체와 자기 자신의 대응되는 '핵심' 필드들이 모두 일치하는지 하나씩 검사한다.
	- 인터페이스로 타입 검사를 했을 경우에는 인터페이스 메서드를 사용해야 한다.

#### 필드 값 비교
- 기본 타입 필드는 ==연산자로 비교하라.
	- 단 **float, double의 경우는 예외다! `Float.compare(float, float)`과 `Double.compare(double, double)`을 사용하라!**  
		- `Float.NaN`, `-0.0f` 등 특별한 부동소수값을 다뤄야 하기 때문이다.
		- `Float.equals`나 `Double.equals` 사용가능하지만, 성능 문제(오토박싱 유발)
- 참조 타입은 각각의 equals 메서드 이용한다.
	- null을 정상 값으로 취급하는 참조 타입 필드의 경우
		- `Object.equals(Object, Object)` 사용하여 NPE 방지
- 배열의 모든 원소가 핵심 필드라면 `Arrays.equals` 메서드 중 하나를 사용하라.
- 비교하기 복잡한 필드를 가지고 있는 경우 필드 표준형(canonical form)을 저장, 표준혀끼리 비교하라.
	- 불변 클래스에 맞는 방식임
	- 가변일 경우 값이 바뀔 때마다 표준형을 갱신해줘야 함.
- 다를 가능성이 크거나 비용이 싼 필드부터 비교하라 -> 성능 최적화
	- 파생 필드를 비교할 필요는 없으나 경우에 따라 파생 필드 비교가 더 빠를 수도 있음(파생 필드가 객체 전체의 상황 반영할 때)
#### 그 외 주의사항
- equals를 정의할 땐 hashCode도 반드시 재정의하라
- 필드들의 동치성 검사 차원을 넘어서는 경우 문제 발생할 가능성 있다. 단순하게 해결하라.
- equals 메서드의 매개변수는 Object로 선언하라.
	- Object 외의 클래스로 정의할 경우 `Object.equals`의 재정의가 아니라 오버로딩한 것이다.
	- 하위 클래스에서의 @Override 에너테이션이 false positive를 내게 하고 보안 상으로도 잘못된 정보 전달
- 구글의 AutoValue 프레임워크는 equals/hashCode 작성/테스트를 도와준다.

## 아이템11. equals를 재정의하려거든 hashCode도 재정의하라

- equals 오버라이드 이후에 hashCode 오버라이드 하지 않는다면 hashCode 일반규약을 어기게 된다.
> - equals 비교에 사용되는 정보가 변경되지 않았다면, 애플리케이션이 실행되는 동안 그 객체의 hashCode 메서드는 몇 번을 호출해도 일관되게 항상 같은 값을 반환해야 한다. 단 애플리케이션을 다시 실행한다면 이 값이 달라져도 상관없다.
> - equals(Obejct)가 두 객체를 같다고 판단했다면 , 두 객체의 hashCode는 똑같은 값을 반환해야 한다.
> - equals(Object)가 두 객체를 다르다고 판단했더라도, 두 객체의 hashCode가 서로 다른 값을 반환할 필요는 없다. 단, 다른 객체에 대해서는 다른 값을 반환해야 해시테이블의 성능이 좋아진다.
- 논리적 동치(equals)인 두 객체에 대해 동일 해시코드를 반환해야 한다는 점이 중요하다. (위에서 두 번째 규약)
	- 이를 위반하면
	 `hashMap.put(new Foo(100), "이름");`일 때 `hashMap.get(new Foo(100))`은 "이름"을 반환하지 않는다.
	 - 논리적으로는 동치임에도 두 Foo의 hashCode 값이 다르기 때문이다.
	 - get 메서드가 엉뚱한 해시 버킷에서 객체를 찾게 되며, 만일 같은 버킷에 담겼다고 해도 해시코드가 다르기 때문에 동치성 비교를 하지도 않는다.
- 잘못된 해시코드 구현
	```java
	@Override
	public int hashCode() { return 42; }
	```
	- 위는 동치인 객체에 대해서 동일한 해시코드를 반환한다. -> 해시코드의 규정에 맞다.
	- 하지만 성능 면에서는 최악이다.
		- 모든 객체가 해시 테이블의 버킷 하나에 담겨, LinkedList처럼 동작한다. 
		- O(1) -> O(n) 으로 수행시간이 느려진다.
		
### 올바른 해시코드를 구현하기 위한 요령
1. int 변수 result를 값 c로 초기화(c는 첫 핵심 필드: equals 비교에 사용되는 필드를 2-1방식으로 계산한 것)
2. 핵심 필드 f 각각에 대해 다음을 수행
	1. 해당 필드의 해시코드 c를 계산
		1. 기본 타입의 경우 Type.hashCode(f)
		2. 이 클래스의 equals가 필드 f의 equals를 재귀적 호출할 경우 필드의 hashCode를 재귀적으로 호출한다. 
			- 복잡한 경우에는 필드의 표준형을 만들고 그것의 hashCode를 호출한다.
			- 필드의 값이 null이면 전통적으로 0을 사용한다.
		3. 필드가 배열일 경우 핵심 원소 각각을 별도 필드처럼 다룬다.
			- 핵심원소의 해시코드를 계산한 후 2.2 방식으로 갱신한다.
			- 모든 원소가 핵심 원소일 경우 Arrays.hashCode 사용한다.
	2. 2.1에서 계산한 c로 result를 갱신한다.
		- result = 31 * result + c;
3. result를 반환한다.

#### 추가 사항
- 단위 테스트를 통해 검증한다. (동치인 인스턴스는 서로 같은 해시코드를 반환해야 한다.)
- 파생 필드는 해시코드 계산에서 제외해도 된다.
- equals 비교에 사용되지 않은 필드는 반드시 제외하라.
- 단계 2.2.2 추가정보
	- 31 * result는 필드를 곱하는 순서가 result 값에 영향을 주게 한다.
		- 비슷한 필드가 여럿일 때 해시 효과를 높임
			- 가령 String의 경우 곱셈을 통해 아나그램의 해시코드를 같게 하지 않는다.
		- 곱한 숫자가 31인 이유
			- 31이 홀수이면서 소수이기 때문
			- 수가 짝수이고 오버플로가 발생할 경우 정보를 잃게 됨: 시프트 연산과 같은 효과를 내기 때문
			- 소수를 곱하는 이유는 전통적
			- 31을 이용할 경우 시프트 연산과 뺄셈으로 최적화 가능
- 이를 바탕으로 한 구현 예
	```java
	@Override
	public int hashCode() {
	    int result = Short.hashCode(areaCode);
	    result = 31 * result + Short.hashCode(prefix);
	    result = 31 * result + Short.hashCode(lineNum);
	    return result;
	}
	```
- 참고: Guava의 com.google.common.hash.Hashing은 해시 충돌이 더 적은 방법을 제공

#### 성능 최적화
- `Object.hash()`
	```java
	@Override
	public int hashCode() {
	    return Object.hash(lineNum, prefix, areaCode);
	}
	```
	- 위의 방식에 비해 코드 길이를 줄일 수 있음
	- 성능은 더 부족함
		- 입력 인수를 위한 배열이 생성됨
		- 입력 인수 중 기본타입이 있을 경우 박싱, 언박싱을 거침
	
- 캐싱
	- 클래스가 불변이고 해시코드 계산 비용이 클 경우 사용을 고려
	- 해키 키로 이 타입의 객체가 사용될 것 같을 경우 인스턴스 생성 시 해시코드를 계산해둘 것
	- 해시의 키로 사용되지 않을 경우, hashCode가 처음 호출 될 때로 지연 초기화할 수도 있다.
		- 이 경우 이 클래스를 thread safe 하게 만들어야 한다.
		- result값을 객체의 해시코드와는 다른 값으로 초기화하고, result값이 그 값이 아닐 때만 해시코드를 생성하게끔 만들면 된다.
	
- 성능최적화를 위해 핵심 코드를 생략하여 해시코드를 계산해선 안 된다!
	- 생성 속도는 빨라져도, 해시테이블의 성능을 심각하게 떨어뜨릴 수 있다.
	- 자바2이전의 String이 그 예다.
	
- 해시코드 생성 규칙을 API 사용자에게 자세히 공표해선 안 된다.
	- 클라이언트가 특정 방식에 의존하지 않아야 추후 변경이 용이하기 때문이다.
	- String, Integer 등 자바 라이브러리의 많은 클래스가 이러한 실수를 저질렀다.
	
	

## 아이템12. toString을 항상 재정의하라

- `Object.toString()`은 `클래스명@16진수해시코드`를 반환한다. 의미 있는 정보를 전달하기 위해 오버라이드 해야한다. (toString 규약은 모든 하위 클래스에서 오버라이드를 권장한다.)
- toString 오버라이드는 사용성을 높이고 디버그에 용이하다. 
- toString은 객체를 println, printf, +연산자(문자열), assert 구문에 인자로 넘길 때 / 디버거가 객체를 출력할 때 자동으로 호출된다.
- toString은 객체가 가진 주요 정보 모두를 반환하는 것이 좋다.
	- 이상적으로는 모두를 반환하는 것이 좋지만, 객체가 거대하거나 객체의 상태가 문자열로 표현하기에 부적합할 경우에는 요약 정보를 담는다.
	- 반환값의 포맷을 문서화할지 정하라, 이 경우
		- 값 그대로 I/O 이용하거나 CSV 파일처럼 사람이 읽을 수 있는 데이터 객체로 저장 가능
		- 명시한 포맷에 맞는 문자열과 객체를 상호 전환할 수 있는 정적 팩터리/생성자를 함께 제공하면 더 좋음
			- BigInteger, BigDecimal과 같은 대부분의 기본 타입 클래스가 이 방식을 따른다.
		- 한 번 명시한 포맷에서 벗어나기는 힘들다는 단점이 있다.
- toString 반환값에 대한 의도를 명시해야 한다. 포맷을 명시할 경우 더 그렇다.
- toString 반환값에 포함된 정보를 가져올 수 있는 API를 제공하라.
	- 제공하지 않을 경우 파싱이 추가적으로 필요한데, 성능을 악화시키며 불필요하다.
	- 접근자를 제공하지 않으면 포맷이 준-표준 API나 다름 없어지며, 포맷이 바뀌면 시스템이 망가지게 된다.
- 정적 유틸리티 클래스, 대부분의 열거 타입은 따로 toString을 재정의하지 않아도 된다.
	- 단 하위 클래스들이 공유해야 할 문자열 표현이 있는 추상 클래스의 경우 재정의가 필요
		- 대다수의 컬렉션 구현체는 추상 컬렉션 클래스들의 toString을 상속해 사용
- AutoValue 프레임워크 등은 toString을 생성해주지만 그 클래스의 의미에 대해서는 파악하지 못함에 유의



## 아이템13. clone 재정의는 주의해서 진행하라

### Clonable
- 복제해도 되는 클래스임을 명시하는 용도의 믹스인 인터페잇(mixin interface)
- clone 메서드는 정작 Cloneable이 아니라 Object에 선언되어 있고, protected이다.
	- 즉, Clonable을 구현하는 것 만으로는 clone을 호출할 수 없다.
- 하는 일
	- Object의 clone 메서드 동작 방식을 결정함
		- Cloneable 인터페이스를 구현한 클래스에서 clone이 호출되면 객체의 필드들을 모두 복사한 객체를 반환,
		- 그렇지 않은 경우 CloneNotSupportedException 던짐
		- 위는 모범적이지 않은 인터페이스 용례임
			- 인터페이스의 구현은 인터페이스가 정의한 기능을 사용한다는 의미인데,
			- 여기서는 상위 클래스의 메서드 동작 방식을 변경한 것
- 실제 사용시 Cloneable을 구현한 클래스는 clone을 public 메서드로 제공하며, 그 복제가 제대로 이루어지게 해야 한다.
	- 이를 구현하다 보면 생성자를 호출하지 않고 객체를 생성할 수 있게 되는 문제점이 발생한다.

### `clone()`
#### clone 메서드 규약(Object 명세에 있음)
- 다음은 일반적으로 참이지만 필수는 아님
	- `x.clone() != x`
	- `x.clone().getClass() == x.getClass()`
	- `x.clone().equals(x)`
- 관례상 반환된 객체는 `super.clone()`을 호출하여 얻은 것이어야 함. 이 클래스와 모든 상위 클래스가 이를 따른다면
	- `x.clone().getClass() == x.getClass()`는 참이다.
- 관례상, 반환된 객체와 원본 객체는 독립적이어야 함
	- 이를 위해서 `super.clone()`으로 얻은 객체의 필드 일부를 반환 전에 수정해야 할 수도 있음

#### 해설
- 상당히 느슨한 규약임
- 강제성이 없다는 점을 제외하면 생성자 연쇄와 유사한 메커니즘
	- 단, `super.clone()`이 아니라 생성자를 호출, 반환할 경우 하위 클래스가 `super.clone()` 호출 시에 clone 메서드가 잘못 작동하게 된다.
	- final 클래스에서는 하위 클래스가 없기 때문에 이 사항을 신경 쓰지 않아도 된다.
		- 하지만, final 클래스가 `super.clone`을 호출하지 않는다면 Cloneable을 구현할 필요도 없기에 이는 무의미하다.
#### 불변 클래스의 clone() 구현 사례
- 코드
	```java
	@Override
	public PhoneNumber clone() {
	    try {
	        return (PhoneNumber) super.clone();
	    } catch (CloneNotSupportedException e) {
	        throw new AssertionError(); // 일어날 수 없는 일이다.
	    }
	}
	```
- 불변 클래스는 굳이 clone 메서드를 제공하지 않는 게 낫다. 불필요한 복사는 지양해야 하기 때문이다.
- 재정의한 메서드의 반환 타입은 상위 클래스의 메서드가 반환하는 타입의 하위 타입일 수 있다.
	- 공변 변환 타이핑(covariant return typing)을 자바가 지원하기에 가능
	- 이를 위해서 반환 전에 Object로 반환되는 `super.clone()`을 하위 타입으로 형변환한다.
	- 위의 CloneNotSupportedException을 검사하는 try~catch 블록은, PhoneNumber가 Clonable을 구현한다는 것을 알기에 불필요하다.
	- 비검사 예외(uncheckd exception) 이어야 했다.

#### 클래스가 가변 객체를 참조하는 경우
##### 재귀적 호출
- Stack 클래스에 Object[] elements 필드가 있다면, clone으로  복제된 elements 필드도 원본과 동일한 배열을 참조하게 된다. 원본<->복제품 변화가 서로 영향을 끼친다.
- 코드
	```java
	@Override
	public Stack clone() {
	    try {
	        Stack result = (Stack) super.clone();
	        result.elements = elements.clone();
	        return result;
	    } catch (CloneNotSupportedException e) {
	        throw new AssertionError();
	    }
	}
	```
	- elements배열의 clone을 재귀적으로 호출해서 문제를 해결했다.
	- 배열의 clone()은 원본 배열과 똑같은 배열을 반환하기에 형변환이 필요 없다.
		- 이 이유로 배열을 복제할 경우 배열의 clone 메서드를 사용하는 것이 권장된다.
		- elements 필드가 final일 경우 새 값 할당이 불가하기에 위 해법은 작동하지 않는다.
			- **가변 객체를 참조하는 필드는 final로 선언하라는 일반 용법과 Cloneable 아키텍처(+직렬화)는 충돌한다.**
				- 단, 해당 가변 객체가 공유되도 된다면 괜찮다.

##### 재귀적 호출을 통한 해결이 불가한 경우
###### 방법1
- 코드
	```java
	public class HashTable implements Cloneable {
	    private Entry[] buckets = ...;
	
        private static class Entry {
            final Object key;
            Object value;
            Entry next;
	
            Entry(Object key, Object value, Entry next) {
                this.key = key;
                this.value = value;
                this.next = next;
            }
        }
        ... // 나머지 코드는 생략
	}
	```
	위 해시 테이블의 사례에서, clone을 재귀적으로 호출한다면,
	```java
	@Override
	public HashTable clone() {
	    try {
	        HashTable result = (HashTable) super.clone();
	        result.buckets = buckets.clone();
	        return result;
	    } catch (CloneNotSupportedException e) {
	        throw new AssertionError();
	    }
	}
	```
	복제본이 원본과 다른 버킷 배열을 갖지만, 그것이 참조하는 연결 리스트(next)를 참조하기 때문에 문제가 해결되지 않는다. 다음은 각 버킷을 구성하는 연결 리스트를 복사하는 해법이다:
	```java
	Entry deepCopy() {
	    return new Entry(key, value,
	        next ==null ? null: next.deepCopy());
	}
	
	@Override
	public HashTable clone() {
	    try {
	        HashTable result = (HashTable) super.clone();
	        result.buckets = new Entry[buckets.length];
	        for (int i = 0; i < buckets.length; i++)
	            if (buckets[i] != null)
	                result.buckets[i] = buckets[i].deepCopy();
	        return result;
	    } catch (CloneNotSupportedException e) {
	        throw new AssertionError();
	    }
	}
	```
	단순한 방법으로 연결 리스트를 복제하지만, 재귀호출로 인해 리스트의 원소 수만큼 스택 프레임을 소비하여, StackOverFlow의 위험이 있다. 대안으로 재귀 호출 대신 반복자를 이용하는 방법이 있다:
	```java
	Entry deepCopy() {
        Entry result = new Entry(key, value, next);
        for (Entry p = result; p.next != null; p = p.next)
            p.next = new Entry(p.next.key, p.next.value, p.next.next);
        return result;
	}
	```

###### 방법2
- `super.clone()`을 통해 얻은 객체의 모든 필드를 초기 상태로 설정하고, 고수준 API를 통해 원본과 같이 세팅한다.
	- 코드가 깔끔해지지만
	- 상대적으로 성능이 저하된다.
	- Cloneable 아키텍처는 필드 단위 객체 복사에 기반하는데, 이를 우회하기에 Cloneable과는 어울리지 않다.

 #### 주의사항
 - (생성자와 마찬가지로) 재정의될 수 있는 메서드를 호출해선 안 된다.
	 - 추후 추가



## 아이템 70. 복구할 수 있는 상황에는 검사 예외를, 프로그래밍 오류에는 런타임 예외를 사용하라
- throwable: 문제 상황을 알리는 타입
	- 검사 예외
	- 런타임 예외
	- 에러
- 언제 어떤 throwable을 사용해야 하는가?
1. 호출 측에서 복구할 것으로 여겨질 경우 검사 예외 사용
	- 호출자는 검사 예외를
		1. catch로 잡아 처리하거나
		2. 더 바깥으로 전파한다.
	- 검사 예외는 그 상황에서 호출자에게 복구할 것을 요구하는 것이다.
	
2. 프로그래밍 오류를 나타낼 때는 런타임 예외를 사용
	- 비검사 throwable에는 런타임 예외와 에러가 있음
		- 둘 다 공통적으로 프로그램이 잡아선 안 되는 종류
			- 잡지 않으면, 오류 메시지와 함께 종료됨
		- 복구가 불가능한 상황이거나, 더 이상 실행하는 것이 좋지 않은 상황임을 의미하기 때문
	- 런타임 예외의 대부분은 전제조건을 만족하지 못할 때 발생
		- API 명세 규약을 지키지 못했을 때
	- 복구 가능한 상황인지, 프로그래밍 오류인지를 구별하기 모호함
		- 자원 고갈의 예) 감당 불가능한 크기의 배열을 잘못한 문제인지(프로그래밍 오류 -> 런타임 예외), 일시적 자원 부족인지(복구 가능 -> 검사 예외) 
		- 모호한 경우에는 비검사 예외를 선택하는 것이 나음
	
3. 에러의 경우
	- JVM 자원부족, 불변식 깨짐 등 수행 불가능한 상황을 나타냄
	- 널리 사용되는 규약: Error를 상속해 하위 클래스를 만들지 말아라.
	- 또한 Error는 직접 throw 해서도 안 된다.
	
	

## 아이템 71. 필요 없는 검사 예외 사용은 피하라
- 검사 예외는 발생한 문제를 프로그래머가 처리하여 안정성을 높인다.

- 하지만, 검사 예외를 남용할 경우 API 사용을 불편하게 한다.
	- 특히 검사 예외를 던지는 메서드는 스트림 내에서 직접 사요할 수 없다.
	
- 검사 예외의 필요성 여부
	- API를 제대로 사용해도 발생 가능한 예외이거나
	- 프로그래머가 의미 있는 조치를 취할 수 있는 경우 검사 예외를 사용해도 괜찮지만
	- 위에 해당하지 않을 경우 비검사 예외를 사용하라.
	
- 단 하나의 검사 예외만 던지게 될 경우 충분히 고민해 볼 필요가 있다.
	- 여러 개를 사용할 때는 catch 문을 하나 추가하는 것으로 끝나지만, 위의 경우에는 try 블록과 스트림 사용 불가라는 큰 차이가 발생하기 때문이다.
	
- 대안
	- 적절한 결과 타입을 담은 빈 옵셔널을 반환
		- 예외 발생에 대한 부가 정보를 담을 수 없다는 단점
	- 검사 예외를 던지는 메서드를 2개로 쪼개는 방식
	
	

## 아이템 72. 표준 예외를 사용하라

- 쉽게 사용할 수 있는 API
- 코드 가독성 상승
- 클래스 수 감소로 인한 메모리 및 성능 이득
- 주요 목록
	- IllegalArgumentException: 잘못된 인수(null의 경우 NPE)
	- IllegalStateException: 객체가 메서드를 수행하기에 부적절한 상태
	- NullPointerException: null을 허용하지 않는 메서드에 null을 넘김
	- IndexOutOfBoundsException: 인덱스 범위 넘어섬
	- ConcurrentModificationException: 허용하지 않는 동시 수정이 발견됨
		- 단 동시 수정 검출하는 안정적 방법이 없기에 이는 완전히 잡아내는 것이 아니라 경고에 가까움
	- UnsupportedOperationException: 호출된 메서드를 지원하지 않음
		- 일반적인 경우 정의한 메서드를 모두 지원하기 사용 적음
		- 인터페이스의 메서드 일부를 구현 못 할 때 사용
- 표준 예외를 사용시 API문서를 참조하여 그 예외가 어떤 상황에 던져지는지 확인하고 사용해야 한다.
- 추가적인 정보 전달을 위해 표준 예외를 확장할 수도 있다.
	- 단, 예외는 직렬화할 수 있으며 직렬화에는 많은 부담이 따르기에 새로운 예외를 규정하는 데에는 신중해야 한다.
- 모호한 경우
	- 인수 값이 무엇이었든 어차피 실패했을 경우에는 IllegalStateException, 그렇지 않으면 IllegalArgumentException을 사용하라.



## 아이템 73. 추상화 수준에 맞는 예외를 던져라
- 저수준 예외를 처리하지 않고 바깥으로 전파시키지 않으면
	- 작업과 무관한 예외가 나타남 -> 원인 파악을 혼란하게 함
	
	- 내부 구현을 드러내서 윗 레벨 API를 오염시키기 때문에
	
	  

### 예외 번역(exception translation)
- 상위 계층에서 저수준 예외를 잡아 추상화 수준에 맞는 예외로 바꿔 던짐
- 예외 연쇄(exception chaining)
	- 문제의 근본 원인(cause)인 저수준 예외를 고수준 예외에 실어 보내는 것
	- 저수준 예외가 디버깅에 도움이 될 경우 사용
	- Throwable의 getCause 메서드를 이용해서 저수준 예외를 꺼내 볼 수 있음
	- 예외 연쇄용 생성자
	```java
	NewException(Throwable cause) {
        super(cause);
	}
	```
	위와 같은 형태의 생성자는 Throwable(Throwable)까지 연쇄적으로 원인을 건내게 한다.
		- 대부분의 표준 예외에는 예외 연쇄용 생성자가 있으며,
		- 그렇지 않은 경우 initCause 메서드를 이용해 원인을 표시할 수 있다.
		- 단 예외 번역도 남용하지 않음이 좋다.
			- 최선의 방식은 저수준 메서드가 항상 성공하게 하는 것이다.
			- 상위 계층 메서드의 매개변수를 하위 계층에 건내기 전에 확인하는 방식 등의 방법이 있다.
			- 하위 계층의 예외를 피할 수 없는 경우 상위 계층에서 처리하여 API호출자에게까지 전파하지 않는 방법도 가능하다.
				- 이 경우 로깅 기능을 이용하여 기록하라.
