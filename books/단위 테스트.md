# 단위 테스트(Unit Testing)

- ## 생산성과 품질을 위한 단위 테스트 원칙과 패턴

- ### 블라디미르 코리코프 지음, 임준혁 옮김



# Part 1. 더 큰 그림

# 1장 단위 테스트의 목표

## 1.1 단위 테스트 현황

- 단위 테스트는 이제 선택이 아닌 필수
- 단위 테스트는 단순히 테스트를 작성하는 것보다 큰 범주의 일임
  - 단순히 테스트 프레임워크나 Mocking library를 배우는, 기술적인 부분만 있는 게 아님
  - 최대한 이득을 얻도록 노력해야 함
    - 테스트에 드는 노력을 최소화하고
    - 테스트로 인한 이득을 최대화해야 함
- 어떤 단위 테스트가 좋은지 고민해야 함



## 1.2 단위 테스트의 목표

- **단위 테스트의 부수 효과**: 더 나은 설계를 도움

  - 단위 테스트는 더 나은 설계로 이어짐

    - 하지만 이는 부정 지표로서만 의미 있음
    - 즉, 단위 테스트하기 쉬운 코드라고 해서 좋은 코드는 아닐 수 있음

  - 단위 테스트하기 용이함과 좋은 코드의 상관관계
    $$
    모든\,코드조각\,c에\,대하여,\,단위테스트하기\,쉬움Ec,\,좋은\,코드임\,Gc라\,할\,때\\
    \quad \neg Ec \rightarrow \neg Gc\,이다. \,즉\,Gc \rightarrow Ec\,이다.\\
    \quad 역은\,성립하지\,않는다.
    $$

  - 단위 테스트하기 어려운 경우 주 원인은 강한 결합도(tight coupling)

- **단위 테스트의 주 목표: 소프트웨어 프로젝트의 지속 가능한 성장을 가능하게 하는 것**
  
  - **지속성과 확장성을 기반으로, 장기적으로 개발 속도를 유지하게 함**
  - **소프트웨어 엔트로피(software entropy)**
    - 프로젝트 진행에 따라 개발 속도가 빠르게 감소하는 현상
    - 소프트웨어에서는 품질을 떨어트리는 코드 형태로 엔트로피가 나타남
  - 테스트는 소프트웨어 엔트로피를 낮출 수 있음
    - 코드 베이스의 신뢰성을 지키고 코드의 안정화를 도움
    - 기능 확장 및 리팩토링에 도움
      - 테스트가 안전망 역할을 수행, 회귀에 대한 보험을 제공
        - 회귀(regression)
          - 코드 수정 등 사건 이후에 기능이 잘못 작동하는 것
          - 소프트웨어 버그와 동의어
      - 기능 도입, 리팩토링 이후에도 기존 기능이 잘 작동하는 지 확인 가능
  - 단점: **초반에 노력이 필요**
    - 하지만, 프로젝트 후반의 소프트웨어 엔트로피를 줄여주기에 장기적으로는 비용적 이득



### 1.2.1 좋은 테스트와 좋지 않은 테스트를 가르는 요인

- 잘못 만든 테스트와 개발 속도
  - 잘못 만든 테스트도 초반에는 침체 단계에 도달하는 것을 막아줌
  - 하지만 거시적인 관점에서는 큰 차이가 없음: 결국에는 침체 단계에 도달하게 됨

- 테스트에도 품질이 있음
  - 안 좋은 테스트는
    - 잘못된 경고를 발생시키며
    - 회귀 오류를 알아내는 데 도움이 되지 않음
    - 유지보수가 어렵고 느림
  - **테스트의 품질을 신경 쓰지 않고 무작정 많은 테스트를 만드는 것은 부적절**
- 테스트의 유지 비용
  - 다음 활동들에 필요한 시간에 따라 결정됨
    - 기반 코드를 리팩토링할 때 테스트도 리팩토링
    - 각 코드 변경 시 테스트 실행
    - 테스트가 잘못된 경고를 발생시킬 때 처리
    - 기반 코드 동작을 이해하기 위해 테스트를 읽는 데 시간을 투자
- **지속 가능한 프로젝트 성장을 위해 고품질 테스트에만 집중하라**
  - **테스트의 가치(품질)와 유지 비용 모두를 고려하여 좋은 테스트를 판별**
  - 고품질 테스트만 테스트 스위트에 남기자

- 제품 코드 대 테스트 코드
  - 테스트가 많다고 꼭 좋은 것이 아님
  - 테스트 코드도 코드임
  - 때문에 테스트 코드에도 책임이 따름



## 1.3 테스트 스위트 품질 측정을 위한 커버리지 지표

- **커버리지 지표**

  - 테스트 스위트가 소스 코드를 얼마나 실행하는지 백분율로 표시

  - 높을 수록 좋지만, 높다고 테스트 스위트의 품질이 좋음을 보장하지는 않음
    - 이 경우에도 **커버리지 지표는 좋은 코드의 필요조건이다. 역은 성립하지 않는다.**



### 1.3.1 코드 커버리지 지표에 대한 이해

- 코드 커버리지(code coverage) = 테스트 커버리지(test coverage)
  $$
  코드\,커버리지\,= \,{실행\,코드\,라인\,수\over 전체\,라인\,수}
  $$

  - 한계
    - 단순 라인 커버 비율만 측정하기에,
      **커버리지는 오르지만, 실질적인 검증 효과는 동일할 수 있음**



### 1.3.2 분기 커버리지 지표에 대한 이해

- **분기 커버리지**(branch coverage)

  - 코드 커버리지보다 더 정확

  - 라인 기반이 아니라 `if`, `switch` 등 제어문에 중점을 둠
    $$
    분기\,커버리지\,= \,{통과\,분기\over 전체\,분기\,수}
    $$



### 1.3.3 커버리지 지표에 대한 문제점

- 테스트 스위트의 품질 결정에 있어 **커버리지 지표는 한계가 있다.**
  - 테스트 대상 시스템의 **모든 가능 결과를 검증한다는 보장이 없음**
  - **외부 라이브러리** 코드 경로를 고려 가능한 지표가 없음



### 1.3.4 특정 커버리지 숫자를 목표로 하기

- **커버리지 지표는, 지표일 뿐 목표가 되어선 안 된다!**
- 커버리지 지표는 좋은 부정 지표지만 나쁜 긍정 지표다.



## 1.4 무엇이 성공적인 테스트 스위트를 만드는가?

- **스위트 내 각 테스트를 하나씩 따로 평가하는 것**이 가장 신뢰성 있는 품질 측정법
  - 이러한 평가는 자동화된 방식으로 확인이 불가하며
  - 개인의 판단에 따름
- 성공적인 테스트 스위트의 특징
  - 개발 주기에 통합돼 있음
  - 코드베이스에서 가장 중요한 부분만을 대상으로 함
  - 최소 유지비로 최대 가치를 끌어냄



### 1.4.1 개발 주기에 통합돼 있음

- 테스트는 끊임 없이 수행되어야 함
  - 모든 테스트는 개발 주기에 포함되어야 하며,
  - 이상적으로는 코드가 변경될 때마다 실행되어야 함



### 1.4.2 코드베이스에서 가장 중요한 부분만을 대상으로 함

- 검증되는 코드의 질에 따라 테스트의 정도가 달라져야 함
  - 중요한 부분일수록 테스트 작성에 노력을 기울이고
  - 덜 중요한 부분은 간략하게 혹은 간접적으로 검증하라.
- 각 부분에 따른 가치
  - **비즈니스 로직(도메인 모델): 일반적으로 가장 중요**
  - 그 외
    - 인프라 코드
    - DB, 서드파티 시스템 등 외부 서비스 및 종속성
    - 모든 것을 하나로 묶는 코드
- **이를 위해서 도메인 모델을 다른 중요하지 않은 부분과 분리해야 한다!**



### 1.4.3 최소 유지비로 최대 가치를 끌어냄

- 단위 테스트에서 가장 어려운 부분
- **가치가 유지비를 상회하는 테스트만 스위트에 유지하라!** 이를 위해,
  - 가치 있는 테스트를 식별,
    - 식별 기준이 필요(frame of reference)
  - 가치 있는 테스트를 작성해야.
    - 코드 설계 기술



# 2장 단위 테스트란 무엇인가

## 2.1 '단위 테스트'의 정의

- **단위 테스트의 주요 속성**
  - 작은 코드 조각(단위)을 검증하고,
  - 빠르게 수행하고,
  - **격리된 방식으로 처리하는 자동화된 테스트: 논쟁점!**

- 단위 테스트에 대한 두 해석 & 접근방식

  - **고전파(classical school)**
    - 단위 테스트와 TDD에 원론적으로 접근하는 방식
    - 디트로이트파(Detroit school), 고전주의자(classicist)
    - 켄트 백의 "테스트 주도 개발"이 대표적

  - **런던파(London school)**
    - 런던의 프로그래밍 커뮤니티에서 시작
    - 목 주의자(mockist): 멸칭
    - 스티브 프리먼(Steve Freeman), 냇 프라이스(Nat Pryce)의 "Growing Object-Oriented Software, Guided by Tests"
      - 번역서: [테스트 주도 개발로 배우는 객체 지향 설계와 실천](https://www.aladin.co.kr/shop/wproduct.aspx?ItemId=27490110)
      - 두 저자는 jMock과 nMock 라이브러리 개발

- **단위 테스트의 세 번째 속성 중 "격리(isolation)"에 대한 해석이 두 학파의 근원적 차이다.**
  - 이 책의 저자는 고전파를 선호



### 2.1.1 격리 문제에 대한 런던파의 접근

- 런던파의 격리 해석

  - 테스트 대상 시스템을 협력자(collaborator)에게서 격리하는 것

  - 하나의 클래스가 다른 클래스에 의존하면 의존성을 모두 테스트 대역(test double)로 대체해야 함

  - 도식화

    - **Before**

      ```mermaid
      flowchart LR
      	SUT(테스트 대상 시스템) --> D1((의존성1))
      	SUT(테스트 대상 시스템) --> D2((의존성2))
      ```

    - **After**

      ```mermaid
      flowchart LR
      	SUT(테스트 대상 시스템) --> D1((테스트 대역1))
      	SUT(테스트 대상 시스템) --> D2((테스트 대역2))
      	style D1 stroke:#f66,stroke-width:2px, stroke-dasharray: 5 5
      	style D2 stroke:#f66,stroke-width:2px, stroke-dasharray: 5 5
      ```

- **장점**

  - 테스트 실패 시 잘못된 부분을 확실히 알 수 있음: **무조건 테스트 대상 시스템이 잘못된 것**
  - 객체 그래프를 분할할 수 있음: **복잡한 의존성을 가진 코드베이스를 테스트하기 좋음**
    - 테스트 대역이 없을 경우 테스트용 의존성들을 구성해야 함
    - 의존성들은 또 다른 의존성을 갖기에 
      **의존성들을 모두 대체하는 것은 사실상 객체 그래프를 다시 형성하는 것과 같음**
  - 테스트 범위를 간단하게 설정할 수 있음
    - 예시: 하나의 클래스 당 하나의 단위 테스트를 작성하는 방식



#### 고전파 테스트와 런던파 테스트 예제

- **AAA 패턴**

  - Arrange(준비) - Act(실행) - Assert(검증)

- **고전파 테스트**

  - 코드

    ```java
    @DisplayName("고전파 테스트")
    class ClassicStyleTest {
    
    	@Test
    	void 재고가_충분하면_구매는_성공함() {
    		//준비
    		StoreImpl store = new StoreImpl();
    		store.addInventory(SHAMPOO, 10);
    		Customer customer = new Customer();
    
    		//실행
    		boolean success = customer.purchase(store, SHAMPOO, 5);
    
    		//검증
    		assertThat(success).isTrue();
    		assertThat(store.getInventory(SHAMPOO)).isEqualTo(5);	//상점 제품 다섯 개 감소
    	}
    
    	@Test
    	void 재고가_부족하면_구매는_실패함() {
    		//준비
    		StoreImpl store = new StoreImpl();
    		store.addInventory(SHAMPOO, 10);
    		Customer customer = new Customer();
    
    		//실행
    		boolean success = customer.purchase(store, SHAMPOO, 15);
    
    		//검증
    		assertThat(success).isFalse();
    		assertThat(store.getInventory(SHAMPOO)).isEqualTo(10);	//상점 제품 수량 변화 없음
    	}
    }
    ```

  - 해설

    - 준비
      - 테스트 대상 시스템(SUT; System Under Test)로 `Customer`
      - 협력자로 `Store`
      - **협력자가 필요한 이유**
        - 테스트 메서드 컴파일을 위해 매개변수로 `Store` 인스턴스를 필요로 함
        - 결과적으로 상점 제품 수량이 감소할 수 있기에 검증 필요
    - **협력자를 대체하지 않고, 운영용 인스턴스를 사용함!**
      - `Customer`에 이상이 없더라도 `Store` 문제로 단위 테스트 실패 가능
        -> **격리되어 있지 않음!**

- **런던파 테스트**

  - 코드

    ```java
    @DisplayName("런던파 테스트")
    class LondonStyleTest {
    
    	@Test
    	void 재고가_충분하면_구매는_성공함() {
    		//준비
    		Store storeMock = mock(Store.class);
    		when(storeMock.hasEnoughInventory(SHAMPOO, 5)).thenReturn(true);
    		Customer customer = new Customer();
    
    		//실행
    		boolean success = customer.purchase(storeMock, SHAMPOO, 5);
    
    		//검증
    		assertThat(success).isTrue();
    		verify(storeMock, times(1)).removeInventory(SHAMPOO, 5);
    	}
    
    	@Test
    	void 재고가_부족하면_구매는_실패함() {
    		//준비
    		Store storeMock = mock(Store.class);
    		when(storeMock.hasEnoughInventory(SHAMPOO, 5)).thenReturn(false);
    		Customer customer = new Customer();
    
    		//실행
    		boolean success = customer.purchase(storeMock, SHAMPOO, 5);
    
    		//검증
    		assertThat(success).isFalse();
    		verify(storeMock, times(0)).removeInventory(SHAMPOO, 5);
    	}
    }
    ```

  - 해설

    - *Store` 인스턴스를 테스트 대역의 일종인 **목으로 대체**
    - **구체 클래스인 StoreImpl이 아닌 인터페이스인 Store을 목으로 만들었음!**
      - 구체 클래스도 목으로 만들 수는 있지만, **안티 패턴임!**

- **비교**

  - 고전파 테스트에서는 **상태를 검증**함

  - 런던파 테스트에서는 **상호 작용(호출)을 검증**함



### 2.1.2 격리 문제에 대한 고전파의 접근

- 런던파의 테스트 대역 처리가 갖는 함의: **무엇이 단위 테스트의 대상인가?**
  - 각각의 클래스를 격리해야 한다면 테스트 단위(Unit)는
    **단일 클래스이거나 해당 클래스 내의 메서드임**
  - 격리 방식으로 인해 이 이상 큰 단위가 될 수는 없음
  - 경우에 따라 조금씩 다를 수는 있지만 기본 지침은 **한 번에 한 클래스를 테스트!**
- **격리에 대한 고전파의 해석**
  - 단위 테스트간의 격리를 의미
  - 테스트 실행 순서 따위가 테스트 결과에 영향을 끼치지 않게끔 격리
  - **공유 의존성이 없다면, 클래스 여럿을 묶어서 테스트해도 된다!**
  - **함의: 테스트 대역을 남용하지 말자!**
    - 테스트 대역은 테스트 간 의존성을 해소하는 데 사용됨



#### 의존성

##### 의존성의 종류

- **공유 의존성(shared dependency)**
  - 테스트 간 공유되고, 서로 결과에 영향을 끼칠 수 있는 수단을 제공하는 의존성
  - 대표적인 예
    - 정적 가변 필드(static mutable field)
    - DB
  
- **비공개 의존성(private dependency)**
  - 공유하지 않는 의존성
  
- **프로세스 외부 의존성(out-of-process-dependency)**
  - 애플리케이션 실행 프로세스 외부에서 실행되는 의존성
  - 아직 메모리에 없는 데이터에 대한 프록시
  - 일반적으로는 공유 의존성이지만 예외 있음
    - DB는 프로세스 외부 && 공유 의존성
    - (테스트 각각에 대해 실행된) 도커 컨테이너는 외부 && 비공개 의존성
    - 프로세스 외부의 불변 의존성은 공유 의존성이 아님
      - 어차피 수정 불가능한 값이기에 서로 영향을 끼칠 수 없기 때문

- 주의: 공유 의존성은 테스트 대상 클래스(단위) 간이 아니라 단위 테스트 간에 공유됨

  - 싱글톤 의존성은 단일하지만, 각 테스트 마다 새 인스턴스를 생성하기에 비공개 의존성

  - 설정 클래스는 단일하고, 모든 인스턴스에서 사용하지만 각 테스트에서 새 인스턴스를 만들 수 있음



##### 휘발성 의존성

- 휘발성 의존성(volatile dependency): 둘 중 하나 이상의 속성을 가짐
  - developer’s machine by default에 더하여 런타임 환경의 설치 및 구성을 요구
    - DB, API 서비스
    - 추가 설정 필요, 기본 설치되어 있지 않음
  - 비결정적 동작(nondeterministic behavior)를 포함
    - 난수 생성기, 날짜, 시간 반환 클래스 등
    - 멱등하지 않은 동작
- 휘발성 의존성과 공유 의존성의 비교 사례
  - DB의존성: 공유 의존성 && 휘발성 의존성
  - 파일 시스템
    - 모든 개발자 머신에 설치됨 && 결정적으로 작용: 휘발성 아님
    - 단위 테스트가 서로를 방해할 수 있기에 공유 의존성
  - 난수 생성기
    - 비결정적: 휘발성
    - 테스트 별 별도 인스턴스 제공 가능: 비공개 의존성



##### 공유 의존성은 테스트 실행 속도를 늦춘다

- 공유 의존성은 대부분의 경우 실행 프로세스 외부에 있고
- 비공개 의존성의 대부분은 프로세스 외부로 벗어나지 않기에
- 공유 의존성의 대한 호출은 일반적으로 비공개 의존성에 대한 호출보다 오래 걸림
- **단위 테스트는 빠르게 실행되어야 하기에 공유 의존성을 가진 테스트는 통합 테스트 영역으로 넘어감**



## 2.2 단위 테스트의 런던파와 고전파

| 분류       | 격리 주체   | 단위의 크기                  | 테스트 대역 사용 대상      |
| ---------- | ----------- | ---------------------------- | -------------------------- |
| **런던파** | 단위        | 단일 클래스                  | 불변 의존성 외 모든 의존성 |
| **고전파** | 단위 테스트 | 단일 클래스 또는 클래스 세트 | 공유 의존성                |



### 2.2.1 고전파와 런던파가 의존성을 다루는 방법

- **값 객체와 테스트 대역**

  - 각각의 identity가 존재하지 않고 내용에 의해서만 식별되는 것들
  - enum, 상수값(5, 7 등)
  - 런던파도 값 객체는 테스트 대역으로 대체하지 않음

- 교체 대상 도표

  ```mermaid
  flowchart RL
  subgraph 협력자 런던파에서 교체 대상
  
  	direction BT
  	subgraph 고전파에서 교체 대상
  		A((공유 의존성))
  	end
  	
  	B((변경 가능한 의존성))
  end
  C((의존성)) --> A
  C-->D
  D(비공개 의존성)-->B
  E((값 객체))
  D-->E
  ```

- **협력자와 의존성 비교**
  - 협력자(collaborator)
    - 공유하거나 변경 가능한 의존성
  - 의존성
    - 값 / 값 객체의 경우 의존성이지만 협력자는 아님



## 2.3 고전파와 런던파의 비교

- **런던파의 장점**
  - 입자성(granularity): 테스트가 세밀하기에(fine-grained) 한 번에 한 클래스만 확인
  - 클래스 그래프가 커져도 테스트하기 쉬움: 모든 협력자가 테스트 대역으로 대체되기 때문
  - 테스트가 실패한 경우 어떤 기능이 실패했는지 확실하게 알 수 있음

- 그럼에도 저자는 고전파를 선호함
  - 취약성(fragility) 때문
  - 목을 사용하는 테스트는 고전적인 테스트에 비해 불안정한 경향이 있음



### 2.3.1 한 번에 한 클래스만 테스트하기

- 클래스를 단위로 간주하게 되는 이유
  - 객체 지향 프로그래밍에서 클래스는 보통 원자 빌딩 블록(atomic building block)으로 간주됨
  - 이 성향이 이어져서 테스트에서도 클래스를 단위로 간주하게 된 것
- **좋은 코드 입자성을 위해서는 클래스가 아니라 동작 단위를 검증해야 함**
  - 코드 단위가 아니라 동작 단위를 검증하는 것이 좋은 테스트
  - 비즈니스적으로 의미 있다고 인식되는 것을 검증해야
  - 구현이 아니라, 동작을 검증해야 함!



### 2.3.2 상호 연결된 클래스의 큰 그래프를 단위 테스트하기

- 의존성 그래프가 복잡하게 얽혀 있을 경우 목은 도움이 된다.
- 하지만 **복잡한 클래스 그래프가 되지 않게 만드는 데 집중하는 것이 더 중요하다.**
  - 목을 이용한 방식은 이 중요 문제를 숨기기만 한다는 문제가 있다.



### 2.3.3 버그 위치 정확히 찾아내기

- 런던파 테스트의 경우 SUT에 문제가 있는 테스트만 테스트 실패한다.
- 반면 고전파 테스트의 경우 버그의 정확한 위치를 찾아내는 작업이 필요하다.
  - 테스트를 정기적으로 실행하는 것은 버그의 원인을 바로 찾게 해준다.
    - 이 경우 마지막으로 가한 수정이 문제임을 명확하게 알기 때문이다.
  - 특정 버그가 테스트 하나만이 아니라 여러 테스트에 영향을 끼친다면 버그를 발생시킨 코드 조각이 가치 있음을 알려주기도 한다.



### 2.3.4 고전파와 런던파 사이의 다른 차이점

- **테스트 주도 개발(TDD; Test-Driven-Development)를 통한 시스템 설계 방식**
  - 테스트 주도 개발 프로세스
    - 실패 케이스 작성
    - 테스트가 통과하게 만듦
    - 코드를 리팩토링
  - **런던파**
    - 하향식 TDD(단위 테스트 방식의 귀결)
    - 상위 레벨 테스트부터 시작
    - 목을 이용하여 협력자 차단하면서 하나씩 집중적으로 만들 수 있음
  - **고전파**
    - 일반적으로는 상향식 TDD
    - 도메인 모델을 시작, 계층을 쌓아가면서 최종 사용자가 사용할 수 있는 결과물까지 진행

- **과도한 명세(over-specification) 문제**
  - 테스트가 SUT의 구현 세부 사항에 결합되는가
  - 런던파 테스트의 경우 고전파에 비해 구현 세부사항에 상대적으로 더 결합되는 성향이 있음



## 2.4 두 분파의 통합 테스트

- **통합 테스트의 정의에 대한 런던파의 견해**
  - 실제 협력자 객체를 사용하는 모든 테스트는 통합 테스트
- **통합 테스트의 정의에 대한 고전파의 견해**
  - 단위 테스트의 정의: 고전파 해석
    - 작은 코드 조각: **단일 동작 단위를 검증**
    - 빠르게 수행
    - 격리된 방식: **다른 테스트와 별도로** 처리
  - 통합 테스트는 단위 테스트의 정의 중 하나를 충족하지 않는 테스트



### 2.4.1 통합 테스트의 일부인 엔드 투 엔드 테스트

- **엔드 투 엔드 테스트(end-to-end  test)**

  - 통합 테스트의 일부
  - 모든 외부 애플리케이션을 포함한 시스템을 최종 사용자 관점에서 검증 
  - 차이점: 엔드 투 엔드 테스트는 일반적으로 의존성을 더 많이 포함

- 비교

  - 일반적으로 통합 테스트는 프로세스 외부 의존성을 **1~2개만** 가지고 작동

  - 엔드 투 엔드 테스트는 프로세스 외부 의존성을 **전부 또는 대다수** 갖고 작동

- UI; User Interface 테스트 == GUI; Graphic User Interface 테스트 == 기능 테스트(functional test)
- 엔드 투 엔드 테스트는 가장 비용이 많이 들기 때문에 빌드 프로세스 후반에 실행함이 좋음
  - 개발자 머신이 아닌 빌드 서버에서만 실행할 수도 있음
  - 엔드 투 엔드 테스트에서도 처리하지 못한 외부 의존성이 존재할 수 있음
  - 통합 테스트와 엔드 투 엔드 테스트의 경계가 흐리며
  - 테스트 대역을 사용할 필요성이 있음을 기억해야
