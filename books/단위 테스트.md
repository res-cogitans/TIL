# 단위 테스트(Unit Testing)

- ## 생산성과 품질을 위한 단위 테스트 원칙과 패턴

- ### 블라디미르 코리코프 지음, 임준혁 옮김



# Part 1. 더 큰 그림

# 1장 단위 테스트의 목표

## 1.1 단위 테스트 현황

- 단위 테스트는 이제 선택이 아닌 필수
- 단위 테스트는 단순히 테스트를 작성하는 것보다 큰 범주의 일임
  - 단순히 테스트 프레임워크나 Mocking library를 배우는, 기술적인 부분만 있는 게 아님
  - 최대한 이득을 얻도록 노력해야 함
    - 테스트에 드는 노력을 최소화하고
    - 테스트로 인한 이득을 최대화해야 함
- 어떤 단위 테스트가 좋은지 고민해야 함



## 1.2 단위 테스트의 목표

- **단위 테스트의 부수 효과**: 더 나은 설계를 도움

  - 단위 테스트는 더 나은 설계로 이어짐

    - 하지만 이는 부정 지표로서만 의미 있음
    - 즉, 단위 테스트하기 쉬운 코드라고 해서 좋은 코드는 아닐 수 있음

  - 단위 테스트하기 용이함과 좋은 코드의 상관관계
    $$
    모든\,코드조각\,c에\,대하여,\,단위테스트하기\,쉬움Ec,\,좋은\,코드임\,Gc라\,할\,때\\
    \quad \neg Ec \rightarrow \neg Gc\,이다. \,즉\,Gc \rightarrow Ec\,이다.\\
    \quad 역은\,성립하지\,않는다.
    $$

  - 단위 테스트하기 어려운 경우 주 원인은 강한 결합도(tight coupling)

- **단위 테스트의 주 목표: 소프트웨어 프로젝트의 지속 가능한 성장을 가능하게 하는 것**
  - **지속성과 확장성을 기반으로, 장기적으로 개발 속도를 유지하게 함**
  - **소프트웨어 엔트로피(software entropy)**
    - 프로젝트 진행에 따라 개발 속도가 빠르게 감소하는 현상
    - 소프트웨어에서는 품질을 떨어트리는 코드 형태로 엔트로피가 나타남
  - 테스트는 소프트웨어 엔트로피를 낮출 수 있음
    - 코드 베이스의 신뢰성을 지키고 코드의 안정화를 도움
    - 기능 확장 및 리팩토링에 도움
      - 테스트가 안전망 역할을 수행, 회귀에 대한 보험을 제공
        - 회귀(regression)
          - 코드 수정 등 사건 이후에 기능이 잘못 작동하는 것
          - 소프트웨어 버그와 동의어
      - 기능 도입, 리팩토링 이후에도 기존 기능이 잘 작동하는 지 확인 가능
  - 단점: **초반에 노력이 필요**
    - 하지만, 프로젝트 후반의 소프트웨어 엔트로피를 줄여주기에 장기적으로는 비용적 이득



### 1.2.1 좋은 테스트와 좋지 않은 테스트를 가르는 요인

- 잘못 만든 테스트와 개발 속도
  - 잘못 만든 테스트도 초반에는 침체 단계에 도달하는 것을 막아줌
  - 하지만 거시적인 관점에서는 큰 차이가 없음: 결국에는 침체 단계에 도달하게 됨

- 테스트에도 품질이 있음
  - 안 좋은 테스트는
    - 잘못된 경고를 발생시키며
    - 회귀 오류를 알아내는 데 도움이 되지 않음
    - 유지보수가 어렵고 느림
  - **테스트의 품질을 신경 쓰지 않고 무작정 많은 테스트를 만드는 것은 부적절**
- 테스트의 유지 비용
  - 다음 활동들에 필요한 시간에 따라 결정됨
    - 기반 코드를 리팩토링할 때 테스트도 리팩토링
    - 각 코드 변경 시 테스트 실행
    - 테스트가 잘못된 경고를 발생시킬 때 처리
    - 기반 코드 동작을 이해하기 위해 테스트를 읽는 데 시간을 투자
- **지속 가능한 프로젝트 성장을 위해 고품질 테스트에만 집중하라**
  - **테스트의 가치(품질)와 유지 비용 모두를 고려하여 좋은 테스트를 판별**
  - 고품질 테스트만 테스트 스위트에 남기자

- 제품 코드 대 테스트 코드
  - 테스트가 많다고 꼭 좋은 것이 아님
  - 테스트 코드도 코드임
  - 때문에 테스트 코드에도 책임이 따름



## 1.3 테스트 스위트 품질 측정을 위한 커버리지 지표

- **커버리지 지표**

  - 테스트 스위트가 소스 코드를 얼마나 실행하는지 백분율로 표시

  - 높을 수록 좋지만, 높다고 테스트 스위트의 품질이 좋음을 보장하지는 않음
    - 이 경우에도 **커버리지 지표는 좋은 코드의 필요조건이다. 역은 성립하지 않는다.**



### 1.3.1 코드 커버리지 지표에 대한 이해

- 코드 커버리지(code coverage) = 테스트 커버리지(test coverage)
  $$
  코드\,커버리지\,= \,{실행\,코드\,라인\,수\over 전체\,라인\,수}
  $$

  - 한계
    - 단순 라인 커버 비율만 측정하기에,
      **커버리지는 오르지만, 실질적인 검증 효과는 동일할 수 있음**



### 1.3.2 분기 커버리지 지표에 대한 이해

- **분기 커버리지**(branch coverage)

  - 코드 커버리지보다 더 정확

  - 라인 기반이 아니라 `if`, `switch` 등 제어문에 중점을 둠
    $$
    분기\,커버리지\,= \,{통과\,분기\over 전체\,분기\,수}
    $$



### 1.3.3 커버리지 지표에 대한 문제점

- 테스트 스위트의 품질 결정에 있어 **커버리지 지표는 한계가 있다.**
  - 테스트 대상 시스템의 **모든 가능 결과를 검증한다는 보장이 없음**
  - **외부 라이브러리** 코드 경로를 고려 가능한 지표가 없음



### 1.3.4 특정 커버리지 숫자를 목표로 하기

- **커버리지 지표는, 지표일 뿐 목표가 되어선 안 된다!**
- 커버리지 지표는 좋은 부정 지표지만 나쁜 긍정 지표다.



## 1.4 무엇이 성공적인 테스트 스위트를 만드는가?

- **스위트 내 각 테스트를 하나씩 따로 평가하는 것**이 가장 신뢰성 있는 품질 측정법
  - 이러한 평가는 자동화된 방식으로 확인이 불가하며
  - 개인의 판단에 따름
- 성공적인 테스트 스위트의 특징
  - 개발 주기에 통합돼 있음
  - 코드베이스에서 가장 중요한 부분만을 대상으로 함
  - 최소 유지비로 최대 가치를 끌어냄



### 1.4.1 개발 주기에 통합돼 있음

- 테스트는 끊임 없이 수행되어야 함
  - 모든 테스트는 개발 주기에 포함되어야 하며,
  - 이상적으로는 코드가 변경될 때마다 실행되어야 함



### 1.4.2 코드베이스에서 가장 중요한 부분만을 대상으로 함

- 검증되는 코드의 질에 따라 테스트의 정도가 달라져야 함
  - 중요한 부분일수록 테스트 작성에 노력을 기울이고
  - 덜 중요한 부분은 간략하게 혹은 간접적으로 검증하라.
- 각 부분에 따른 가치
  - **비즈니스 로직(도메인 모델): 일반적으로 가장 중요**
  - 그 외
    - 인프라 코드
    - DB, 서드파티 시스템 등 외부 서비스 및 종속성
    - 모든 것을 하나로 묶는 코드
- **이를 위해서 도메인 모델을 다른 중요하지 않은 부분과 분리해야 한다!**



### 1.4.3 최소 유지비로 최대 가치를 끌어냄

- 단위 테스트에서 가장 어려운 부분
- **가치가 유지비를 상회하는 테스트만 스위트에 유지하라!** 이를 위해,
  - 가치 있는 테스트를 식별,
    - 식별 기준이 필요(frame of reference)
  - 가치 있는 테스트를 작성해야.
    - 코드 설계 기술