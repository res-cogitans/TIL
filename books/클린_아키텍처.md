# 클린 아키텍처

[TOC]

## 들어가기 전에

### 추천사

- 소프트웨어는 프랙털 구조다. 더 작은 컴포넌트들의 구성으로 이루어진다.

- 건축물과 다르게 소프트웨어는 물리적 규모 및 한계가 덜하다.

  - 프로세서 속도, 네트워크 대역폭, 메모리 및 스토리지의 크기 정도의 제약만 있다.

- 좋은 아키텍처는 ***변경이 쉽다***.

  - 변경이 쉬우려면 앞으로 어떤 변화가 있을 지 예측해야 한다.

  - 과거(지금까지 아키텍처의 구성)을 이해하는 것은 어렵다.

    - 과거에 구성된 아키텍처에 매몰될 경우,
      이 **강력하고 안정된 아키텍처**가 변경 자체를 거부하게 된다.

  - 미래(어떤 변경이 있을지)를 예측하는 일은 명확하지 않다.

    - 앞으로의 변경 용이성에 지나치게 집착할 경우
      **추측성 일반화(speculative generality)**의 냄새를 풍기게 된다: 예산을 초과하는 부수적 복잡성(accidental complexity)으로 가득차게 된다.

  - 가장 **깔끔한(clean) 길**을 추구해야 한다.

    - 완전한 예측, 완벽한 구조가 불가능함을 인정하고, 불완전한 지식을 바탕으로 행동해 나간다.

    - ***아키텍처는 종착지가 아니라 여정에 가깝다.***

    - ***아키텍처는 고정된 산출물이 아니라 계속되는 탐구 과정에 가깝다.***

    - 이를 이해해야 더 좋은 아키텍처가 만들어진다.

      > 아키텍처는 구현과 측정을 통해 증명해야 하는 가설이다.
      >
      > - 톰 길브(Tom Gilb)



### 서문

- ***소프트웨어 아키텍처의 규칙은 보편적이다.***
  - 하드웨어가 아무리 변하더라도,
  - 어떤 다른 분야의 소프트웨어를 다룰 때라도, 동일한 규칙이 적용될 수 있다.
- ***소프트웨어를 구성하는 것들이 변하지 않았기 때문이다.***
  - 고급 언어가 등장하고, 객체지향 프로그래밍 등 여러 프로그래밍 패러다임이 발생하였지만
  - **코드는 여전히 순차(sequence), 분기(selection), 반복(iteration)의 집합체일 뿐**이다.
- 소프트웨어 아키텍처의 규칙은 프로그램의 구성요소를 정렬하고 조립하는 방법에 대한 규칙이다.
  - 구성요소가 변하지 않는다면, 그것을 정렬하는 규칙도 변하지 않는다.



## 01부 소개

- 프로그램을 동작하게 만드는 일은 어렵지 않다.
  하지만 프로그램을 제대로 만드는 일은 어렵다.
- 제대로 된 소프트웨어는 효율적이다: 유지보수가 쉽고 확장과 변경에 용이하다.



### 1장 설계와 아키텍처란?

- 설계(design)과 아키텍처(architecture)의 구분?

  - 사실 둘의 구분은 무의미하다.

    - 아키텍처는 저수준 세부사항이 아닌 고수준의 무언가를 지칭하는 데 쓰이는 반면
      설계는 저수준 구조, 결정사항 등을 의미하는 경우가 많다.

    - 하지만 저수준의 설계와 고수준의 아키텍처는 단절 없이 이어져 있고, 분리해서 생각하기 힘들다.

      > 고수준에서 저수준으로 향하는 의사결정의 연속성만이 있을 뿐이다.

- 소프트웨어 설계의 목표는 시스템 구축 및 유지보수에 최소의 인력을 투입할 수 있게끔 만드는 것이다.
- 소프트웨어의 규모가 커지면서 갈수록 그 효율성이 떨어지는 경우가 많다.
  - 코드를 그때그때 정리하지 않고 미루면, 이 기술적 부채가 누적되어 생산성은 0으로 수렴하게 된다.
  - 개발 조직에 있어 최선의 선택은 이러한 부채를 일으키지 않기 위해서
    소프트웨어의 아키텍처의 품질을 심각하게 고민하는 것이다.
  - 이를 위해서는 좋은 소프트웨어 아키텍처에 대한 이해가 선행되어야 한다.



## 2장 두 가지 가치에 대한 이야기

- 모든 소프트웨어 프로그램이 이해 당사자에게 제공하는 두 가지 가치: 행위(behavior), 구조(structure)



### 행위

- 기능 명세서나 요구사항 문서를 구체화할 수 있게 한다.
- 요구사항을 만족하도록 코드를 작성한다.
- 요구사항을 위배하면 디버깅한다.
- 많은 프로그래머들이 이 행위에 대한 고려만이 자신의 일이라고 생각하지만, 이는 잘못된 인식이다.



### 아키텍처

- 소프트웨어는 그 이름대로 부드러움(soft)을 지니도록 만들어졌다: 변경하기 쉬워야 한다.
- 변경사항을 반영하는데 드는 어려움은 
  **변경되는 범위(scope)에 비례하지만, 변경사항의 형태와는 무관해야 한다.**
- 아키텍처가 특정 형태를 선호할수록, 새로운 기능을 아키텍처에 맞추기 힘들어진다.
- 따라서 아키텍처는 형태에 독립적이어야 한다.



### 더 높은 가치

- 많은 사람들은 기능이 일단 작동하는 것이 우선시되어야 한다고 생각하지만,
  기능이 일단 작동만 하지만 비용 문제로 인해서 거의 변경이 불가능한 상태의 소프트웨어가 나올 수도 있다.
- 변경에 용이한 소프트웨어는 지금 기능 작동이 잘 안 되더라도, 작동할 수 있게끔 쉽게 변경할 수 있다.
- 일단 동작하는 소프트웨어가 아니라, 변경하기 쉬운 소프트웨어를 추구해야 한다.



### 아이젠하워 메트릭스

- 긴급한 문제는 중요하지 않으며, 중요한 문제는 긴급하지 않다.
- 소프트웨어에 있어서는
  - 행위는 긴급하지만 중요도가 항상 높은 것은 아니다.
  - 아키텍처는 중요하지만 긴급한 경우는 드물다.



# 02부 벽돌부터 시작하기: 프로그래밍 패러다임

## 3장 패러다임 개요

### 구조적 프로그래밍

> 구조적 프로그래밍은 제어 흐름의 직접적인 전환에 대해 규칙을 부과한다.

- 최초로 적용된 프로그래밍
- 1968년에 에츠허르 비버 데이크스트라(Edsger Wybe Dijkstra)가 발견
- 무분별한 `goto`문은 프로그램 구조에 해로움을 주장
- `if/then/else`와 `do/while/until`로 대체



### 객체 지향 프로그래밍

> 객체 지향 프로그래밍은 제어흐름의 간접적인 전환에 대해 규칙을 부과한다.

- 1966년에 올레 요한 달(Ole Johan Dahl)과 크리스텐 니가드(Kristen Nygaard)에 의해 등장
- `ALGOL`의 함수 호출 스택 프레임을 힙으로 옮기면, 함수 호출 종료 이후에도 함수 내 지역변수가 더 오랫동안 유지될 수 있음을 발견: 클래스 생성자
  - 지역변수 -> 인스턴스 변수
  - 중첩 함수 -> 메서드
- 함수 포인터를 규칙에 따라 활용하여 다형성이 등장



### 함수형 프로그래밍

> 함수형 프로그래밍은 할당문에 대해 규칙을 부과한다.

- 알론조 처치(Alonzo Church)의 람다 계산법 고안
  - 이에 영향을 받아 1958년에 존 매카시(John McCarthy)가 `LISP` 만듦
- 불변성(immutability): 심볼(symbol)의 값이 변경되지 않음
  - 함수형 언어에는 할당문이 없다!



### 생각할 거리

- 각 패러다임은 공통적으로 프로그래머에게서 **권한을 박탈**한다. 새 권한을 부여하지는 않는다.
- 패러다임은 무엇을 해야할 지가 아니라 무엇을 해선 안 되는지를 알려준다.
  - 각각은 `goto `문, 함수 포인터, 할당문을 가져갔으며,
    이 외에 가져갈만한 것은 없기 때문에  (제약을 통한)새로운 프로그래밍 패러다임은 없을 것으로 생각된다.
- 세 가지 패러다임을 함수, 컴포넌트 분리, 데이터 관리와 연관지어 생각해보자.
  - 다형성: 아키텍처의 경계를 넘나드는 수단
  - 함수형 프로그래밍: 데이터의 위치와 접근 방식 규칙 부과
  - 구조적 프로그래밍: 모듈 기반 알고리즘



## 4장 구조적 프로그래밍

### 증명

- 데이크스트라가 직면한 문제 상황: 프로그램 세부 사항이 너무 많아서, 프로그래밍 실패가 종종 발생함
- 대안: 증명(proof)
  - 유클리드 계층구조를 프로그래밍에 도입하고자 함
    - 유클리드 계층구조: 공리(axiom), 증명을 통해 참임이 밝혀진 정리(theorem), 정리를 증명하는 데 필요한 보조정리(lemma), 정리를 통해 도출되는 따름정리(corollary)로 구성
    - 검증된 것을 기반으로 새로운 것을 증명
  - 입증된 구조와 코드를 결합시켜, 코드가 올바르다는 사실을 스스로 증명하게끔 만듦
  - 이를 위해서는 단순 알고리즘에 대한 증명 작성 기법을 보여야 했음
    - 이 과정에서 `goto`문이 모듈의 재귀적 분해에 방해가 되는 경우가 있음을 발견(분할 정복을 불가하게 함)
    - `goto`문을 사용하더라도 문제가 되지 않는 경우들의 경우 `if/then/else`와 `do/while`과 같은 분기와 반복이라는 단순한 재귀 구조로 수렴된다.
- 순차 실행(sequential execution) + `goto` 없는 제어 구조
  - 뵘(Boehm)과 야코피니(Jacopini)가 2년 먼저 발견
    - 모든 프로그램은 **순차(sequence), 분기(selection), 반복(iteration)**의 세 가지 구조만으로 표현할 수 있다.
  - 모듈을 증명 가능하게 하는 제어 구조 = 모든 프로그램을 만들 수 있는 제어 구조의 최소 집합
  - 데이크스트라의 증명 방식
    - 순차: 단순한 열거법을 이용해 증명
    - 분기: 열거법을 재정의하는 방식으로 처리
      - 분기를 통한 각 경로를 열거, 각 경로가 수학적으로 적절한 결과를 만들어낼 경우 신뢰할만한 증명
    - 반복: 귀납법(induction) + 열거법 사용하여 증명



### 해로운 성명서

- **"goto문의 해로움(Go To Statement Considered Harmful)"**
  - 1968 CACM; Communications of the ACM 3월호에 실림
  - 당시 많은 논쟁을 불러일으켰지만, 
    10년 이상이 흐르면서, 프로그래밍 언어에서 `goto`문은 추방되고, 데이크스트라가 옳음이 밝혀짐
  - 현대의 프로그래머는 모두 구조적 프로그래머
    - 자바의 `break`이나 예외는 `goto`문과 유사한 부분이 있지만 제어 흐름에 대한 전환에 한계가 있음(<-> 코트란, 코볼)
    - `goto`를 여전히 지원하는 언어의 경우에도 `goto`문의 목적지는 보통 현재 함수 안으로 한정됨



### 기능적 분해

- 구조적 프로그래밍을 통해 재귀적 분해가 가능
  - 모듈을 고수준의 기능들로, 각 기능은 저수준의 함수로 분해하는 식
  - 분해된 기능은 구조적 프로그래밍의 제한된 제어 구조를 통해 표현 가능
  - 이를 기반으로 구조적 분석(structured analysis), 구조적 분석(structured design): 1970 ~ 1980 유행
  - 대규모 시스템은 모듈과 컴포넌트로 분해, 모듈과 컴포넌트는 더 작은 기능으로 세분



### 엄밀한 증명은 없었다

- 하지만 프로그램 관점에서 데이크스트라가 의도했던 증명을 통한 유클리드 계층구조가 수립되지는 못 했다.
- 대부분의 경우 기능 하나하나에 대한 엄밀한 증명이 이득이 된다고 여기지 않았다.
- 유클리드식 증명이 아닌 과학적 방법(scientific method)을 통한 증명은 성공했다.



### 과학이 구출하다

- 과학은 증명은 불가하지만 반증은 가능하다. (칼 포퍼의 과학철학 참고)
- 현재로서는 반증할 수 없는 서술이라면 그 동안은 참으로 본다.



### 테스트

> "테스트는 버그가 있음을 보여줄 뿐, 버그가 없음을 보여줄 수는 없다."
>
> - 데이크스트라

- 위는 소프트웨어 개발이 수학적인 구조가 아니라 과학과 유사한 무엇임을 보여준다.
- 단 위와 같은 과학적 검증 방법은 입증 가능한 형태의 프로그램에만 적용 가능하다:
  즉 `goto`문을 제약 없이 사용하는 등의 프로그램에는 테스트를 아무리 많이 시도하더라도 올바르다고 보기 어렵다.



### 결론

- 구조적 프로그래밍은 **프로그래밍에서 반증 가능한 단위를 만들어낼 수 있다**는 면에서 의미 있다.
- 따라서 아키텍처의 관점에서 기능적 분해는 중요한 실천법이다.
- 소프트웨어 아키텍트는 모듈, 컴포넌트, 서비스가 쉽게 반증 가능하도록(= 테스트하기 쉽도록) 만들기 위해 노력해야 하며, 이 부분에서 구조적 프로그래밍 개념이 유효하다.
