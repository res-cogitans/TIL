# Test-Driven Development By Example
- TDD 수련에 도움이 되는 문제
	- 알고리즘 중심의 문제
	- 자동판매기 테스터 (인터렉티브 shell 포함)
	- 계산기
	- 엘리베이터 시뮬레이션(Discreet Event Simulation)
	- 웹 게시판
	- 멀티 채팅 프로그램
## 저자의 글
- 테스트 주도 개발: 클린 코드 작성을 위한 자동화된 테스트가 이끄는 개발 방식
> 작동하는 깔끔한 코드(clean code that works). -론 제프리즈(Ron Jeffries)
- 규칙 2가지
	- 오직 자동화된 테스트가 실패할 경우에만 새로운 코드를 작성한다.
	- 중복을 제거한다.
- 위 규칙의 기술적 함의
	- 매 결정사항에 대해 피드백을 제공하는 실행 가능한 코드를 기반으로 하는 유기적인 설계를 해야 한다.
	- 직접 테스트를 작성해야 한다.
	- 개발 환경은 작은 변화에도 빠르게 반응할 수 있어야 한다.
	- 응집도는 높고 결합도는 낮은 컴포넌트들로 구성하여 테스트를 용이하게 만든다.
- 귀결되는 프로그래밍 순서
	- 빨강: 실패하는 작은 테스트를 작성
	- 초록: 빨리 테스트가 통과하게끔 만듦
	- 리팩토링: 중복을 제거

## 1부 화폐 예제
### 1장. 다중 통화를 지원하는 Money 객체 
### 2장. 타락한 객체
- TDD <-> 아키텍처 주도 개발: 깔끔한 코드를 먼저 해결하고 작동하는 부분을 해결하면서 허둥거림
	- 아키텍처 주도 개발?

- 어떤 구현이 올바른가에 대한 우리 추측이 완벽하지 못한 것과 마찬가지로 올바른 인터페이스에 대한 추측 역시 절대 완벽하지 못하다.
- 최대한 빨리 초록색을 보기 위해 취할 수 있는 3 전략 중 2
	- 가짜로 구현하기: 상수 반환, 단계적으로 변수로 변환 (분명하지 않은 상황)
	- 명백한 구현 사용하기: 실제 구현을 입력

- 설계상의 결함을 그 결함으로 인해 실패하는 테스트로 변환

### 3장. 모두를 위한 평등
- 값 객체 패턴(value object pattern)
	- 객체의 인스턴스 변수가 생성자를 통해서 일단 설정된 후에는 결코 변하지 않음
	- 별칭 문제에 대해 걱정할 필요가 없다
	- 암시
		- 모든 연산은 새 객체를 반환해야 한다
			- 하지만 동일 value를 가진(equals) 객체의 경우 새로이 생성하지 않고 기존의 객체를 반환하는 방식이 좋지 않을까?
				- 이 경우 equals() 오버라이딩은 필요 없어지지 않을까?
		- equals()를 구현하라
			- 해시 테이블의 키가 될 때, hashCode() 구현해야
- 인스턴스 변수를 public으로 작성하였다가 private로 바꾸는 방식을 사용함
	- 생성 시점에서 private로 작성한 것이 아니라 public으로 시작해서 개선하는 방법을 택했다는 점이 흥미롭다.

### 4장. 프라이버시
- `assertEquals(15, product.amount)`에서
`assertEquals(new Dollar(15), five.times(3)`로 변경하게 되면
assert는 int 값을 비교하는 것이 아니라 Dollar 값을 비교하게 된다.
이는 Dollar 클래스의 equals() 테스트가 실패한다면 위의 곱셈 테스트 또한 실패함을 암시한다: 위험 요소

### 5장. 솔직히 말하자면
- 새로운 Franc 클래스를 구현하기 위해서 단순하게 기존 코드를 복사하는 방식을 사용했다.
- 이는 좋은 설계를 위한 원칙을 명확하게 위반하는 것이지만
- 테스트 주도 개발의 원칙에 따라 일단 돌아가게 만들고, 그 다음에 수정을 가하도록 한다.
- 좋은 코드는 돌아가게 만든 뒤, 중복 제거를 통해 만들어 나간다.

### 6장. 돌아온 '모두를 위한 평등'
- 복사를 통해 만든 Franc 클래스 인스턴스 사이의 테스트는 존재하지 않는다.
- "애초에 그곳에 있어야 했던 테스트"가 없는 코드에서 TDD를 하는 상황이다. 잘못된 리팩토링을 놓칠 수 있다.
- 때문에 있으면 좋을 것 같은 테스트를 작성하라.
	- 지나치게 애매모호한 지침이다. 새 코드가 발생하는 시점에서 테스트를 작성해야 하지 않을까?
- 불필요한 구현을 제거하기 전에 Dollar와 Franc의 equals()의 구현을 일치시켰다.

### 7장. 사과와 오렌지
- 더 많은 동기가 있기 전에는 더 많은 설계를 도입하지 않기로 했다.

### 8장. 객체 만들기
```java
public void testMultiplication() {
    Money five = Money.dollar(5);
    assertEquals(new Dollar(10), five.times(2);
    ...
}
```
- 팩토리 메서드 dollar()는 Dollar를 반환하지만 위 테스트에서는 상위 클래스인 Money로 반환했다. 하위 클래스의 존재를 테스트에서 분리(decoupling)함으로써 어떤 모델 코드에도 영향을 주지 않고 상속 구조를 마음대로 변경할 수 있게 되었다.
- 하위 클래스가 사라지면 몇몇 클래스는 불필요한 여분의 것이 된다는 것을 인식했다. 하지만 일단 그냥 뒀다.

### 9장. 우리가 사는 시간
### 10장. 흥미로운 시간
- 디버깅을 위해서 테스트 없이 toString() 메서드 작성했다.
- 변경이 잘 작동하는가를 테스트를 통해 검증했다.
- 테스트가 실패했을 때는 그 실패 상황 자체를 분석하여 테스트로 사용할 수 있다.

### 11장. 모든 악의 근원
- 상위클래스로 바로 통합하지 않고 하위클래스의 기능과 참조를 하나씩 없애나갔다.
- 구조 변화에 맞게 테스트를 삭제해나간다.

### 12장. 드디어, 더하기
- TDD는 작업 단계의 크기를 유동적으로 변경할 수 있다.
	- 새로운 기능을 구현할 때는 가짜 구현을 한 이후에 변경해 나갈 수도 있지만
	- 구현이 명확할 경우 바로 진짜 구현으로 들어갈 수도 있다.
	- 이 속도는 상황에 맞춰 유연히 변경해야 하는 것이다.
- imposter
	- 가지고 있는 객체가 원하는 대로 동작하지 않을 경우
	- 외부 프로토콜은 같으면서 내부 구현은 다른 것을 만들어서 문제를 해결
```java
public void testSimpleAddition() {
    ...
    Money reduced = bank.reduce(sum, "USD");
    assertEquals(Money.dollar(10), reduced);
}
```
- 왜 bank가 reduce()의 수행 책임을 맡는가?
	- reduced Expression은 현 업무의 핵심이 되는데, 핵심이 되는 객체 다른 부분에 대해 가능한 한 모르는 것이 좋기 때문이다.
	- Expression과 유관한 오퍼레이션이 많기 때문에, 분리가 필요하다.

### 13장. 진짜로 만들기
- 모든 중복이 제거되기 전까지는 테스트를 통과한 것으로 치지 않았다.
- Money.plus()를 Money가 아닌 Expression(Sum)으로 반환하였다.
	- 다중 통화간 합산이 있을 수 있기 때문에 그렇다.
	- 동일 통화 간 합산의 경우는 별도의 최적화를 해 주면 된다.
- 의문 사항: augend + addend라는 명명법은 과연 적절할까? 원어민 화자조차 글을 작성하면서야 알 정도의 단어로 변수를 명명하는 것은 전달능력이 부족해 보인다.
- 의문사항: 왜 reduce를 Bank와 Sum 모두에 규정하고 그것을 연이어 호출하는지?
- 클래스를 명시적으로 검사하는 코드가 있을 경우 다형성을 활용하여
	- Sum의 reduce(String) 말고도
	- Money도 reduce(String) 구현하여
	- 인터페이스에 reduce(String) 구현하는 식으로 코드 정리가 가능하다.
- Expression의  reduce(String to) 메서드와
	Bank(Expression source, String to)가 함께 있는 식으로 동일 명칭, 다른 매개변수 메서드가 존재하는 경우
	- 자바에서는 이 둘의 차이점을 드러내기 쉽지 않다.
	- 파이썬의 경우 매개 변수의 이름을 명시화할 수 있다.

### 14장. 바꾸기
