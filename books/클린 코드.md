# 클린 코드
- 애자일 소프트웨어 장인 정신
- 로버트 C. 마틴

# 2장 의미 있는 이름
- 의도를 분명히 밝혀라
- 그릇된 정보를 피해라
	- 자주 쓰이는 용어를 다른 의미로 규정해선 안 된다.
		- 목록을 다룬다고 해서 List 자료형이 아닌 것을 list라 명명해서는 안 된다.
	- 유사한 이름을 사용하지 않아야 한다.
	- 유사한 개념은 유사한 표기법을 사용한다.
- 의미 있게 구분하라
	- 연속된 숫자를 덧붙이거나 불용어(noise word)를 사용하는 방식은 부적절하다.
		- a가 있어서 붙인 a1, a2나 class가 있어서 붙인 klass 등은 정보를 전달하지 못 한다.
		- 이름이 다르다면, 의미도 달라야 한다.
		- 변수명에 xVariable이 있다면 그것은 동어반복적일 뿐이다. x와 xVariable 사이에 정보 차이는 존재하지 않는다.
- 발음하기 쉬운 이름을 사용하라
	- 프로그래밍은 사회 활동이다.
- 검색하기 쉬운 이름을 사용하라
	- 지나치게 짧은 이름은 눈에 띄지 않으며 검색되기 어렵다.
	- 검색하기 쉬운 이름이 상수보다 좋다.
	- 이름 길이는 범위 크기에 비례해야 한다.
		- 간단한 메서드의 로컬 변수 정도가 되어야 한 문자 이름을 쓴다.
- 인코딩을 피하라
	- 인코딩 규칙을 추가적으로 익히는 부담
	- 인코딩한 이름은 발음이 힘들고 오타가 발생하기 쉽다.
	- 자료형을 이름에 명시할 경우 이름이나 타입을 유연하게 변경하기 힘들게 하며, 불일치시 잘못된 정보를 준다.
	- 헝거리안 표기법은 이름 길이 제한이나 자료형 검사가 부족한 시절의 산물일 뿐이다.
	- 멤버 변수의 경우 접두어를 붙이지 말고, 클래스나 함수 자체를 작게 만들어라.
	- 인터페이스 클래스와 구현 클래스
		- 인코딩은 인터페이스가 아니라, 구현 클래스에 붙이는 편이 낫다.
- 자신의 기억력을 자랑하지 마라
	- 이름을 독자가 아는 이름으로 변환해서 읽어야 하면 좋은 코드가 아니다.
	- 한 글자 변수명이 대표적이다.
		- 다만 반복문의 i, j, k는 괜찮다. (l은 안 된다!)
		- 루프 범위가 작고 다른 이름과 충돌하지 않을때만 사용하라!
- 클래스 이름
	- 명사나 명사구를 사용.
	- Manager, Processor, Data, Info 등의 단어는 피해라. [의문점]
- 메서드 이름
	- 동사나 동사구를 사용.
	- 자바빈 표준에 따른 접두사
		- 접근자(Accessor) - get
		- 변경자(Mutator) - set
		- 조건자(Predicate) - is
	- 생성자 오버로딩 시에 정적 팩토리 메서드를 사용 -> 이름을 통한 정보 전달
- 기발한 이름은 피하라
- 한 개념에 한 단어를 사용하라
	- get, fetch, retrieve가 혼재되는 상황
- 말장난을 하지 마라
	- 한 단어를 두 가지 목적으로 사용하지 마라.
	- 다른 개념에는 다른 단어를 사용하라.
- 해법 영역에서 가져온 이름을 사용하라
	- 모든 이름을 도메인에서 가져오지는 말자.
	- 프로그래머가 읽을 코드기에 프로그래밍 용어를 사용하는 것이 전달력이 좋을 수 있다.
- 문제 영역에서 가져온 이름을 사용하라
	- 적절한 프로그래밍 용어가 없다면 문제 영역에서 이름을 가져오라. 프로그래머가 전문가에게 의미를 묻는 식으로 파악 가능하다.
	- 문제 영역과 관련 깊은 코드라면 문제 영역에서 이름을 가져와라.
		- 해법 영역과 문제 영역의 분리
		- Repository에서는 프로그래밍 용어에 가까운 표현을 쓰지만
		- Service에서는 비즈니스 모델에 가까운 표현이 적합
- 의미 있는 맥락을 추가하라
	- 클래스, 함수, 이름 공간에 변수를 넣어 맥락을 부여하라.
	- 마지막 수단으로나 접두어를 고려하라.
- 불필요한 맥락을 없애라
	- 의미가 분명한 한에서 짧은 이름이 좋다.
- 마치면서
	- 좋은 이름의 선택은
		- 설명 능력
		- 문화적 배경
		- 교육 문제
		와 유관

# 3장 함수

- 작게 만들어라!
	- 블록과 들여쓰기
		- if/else/while문 등에 들어가는 블록은 한 줄이어야 한다. 2단을 넘어서지 마라!
		- 중첩 구조가 생길만큼 함수가 커져서는 안 된다.
	
- 한 가지만 해라!
  > 함수는 한 가지를 해야 한다. 그 한 가지를 잘 해야 한다. 그 한 가지만을 해야 한다.
  - 지정된 함수 이름 단계에서 추상화 수준이 하나인 단계만 수행하라!
  - 그저 이름만 다른 표현이 아니라 의미 있는 이름으로 다른 함수를 추출할 수 있다면 그 함수는 여러 작업을 하는 것이다.
  - 함수 내 섹션
  	- 한 가지 작업만 하는 함수는 자연스럽게 섹션으로 나누기 어렵다.

- 함수 당 추상화 수준은 하나로!
  - 함수가 한 가지 작업만 하기 위해서는 위해서는 함수 내 모든 문장의 추상화 수준이 동일해야 한다.
  - 근본 개념과 세부 사항이 분리되지 않으면 이해가 힘들며, 더 복잡하게 세부사항이 추가되기 쉽다.
  - 위에서 아래로 코드 읽기: 내려가기 규칙
  	- 위에서 아래로 프로그램을 읽으면 추상화 수준이 한 번에 한 단계씩 내려가야 한다.
  	- TO문단을 읽듯이 프로그램이 읽혀야 한다.

- Switch 문
  - switch문이나 if/else가 다수인 문은 작게 만들기 어렵다.
  - 대신 다형성을 이용하여 각 switch문을 저차원 클래스에 숨기고 반복하지 않아야 한다.
  - 추상 팩토리 내에 switch문을 숨기는 방법이 가능하다.
  - switch문은 다형적 객체 생성 코드에서만 단 한번 쓰고 마는 것이 이상적이다.

- 서술적인 이름을 사용하라!
  - 함수가 작고 단순할수록 서술적인 이름을 고르기도 쉬워진다.
  - 길고 서술적인 이름이 짧고 어려운 이름이나 길고 서술적인 주석보다 좋다.

- 함수 인수
  - 적을 수록 좋다!

  - 인수는 개념 이해를 어렵게 한다.

  - 테스트 작성에서도 인수가 없는 편이 낫다.

  - 출력 인수는 입력 인수보다 어렵다.

  - 많이 쓰는 단항 형식
    - 인수에 질문을 던지는 형식 `boolean fileExists("MyFile")`

    - 인수를 변환해 결과를 반환하는 형식 `InputStream fileOpen("MyFile")`

    - 주로 위 두 가지를 사용

    - 이벤트 함수

      - 출력 인수 없음
      - 입력 인수로 시스템 상태 변경
      - 이벤트임을 명확히 드러내야

    - 이 외의 경우 단항 함수는 피한다.

    - ##### 플래그 인수
    	- 함수로 boolean 값 넘김
    	- 한 번에 여러가지를 한 다는 의미 -> 쓰지 마라
    	
    - ##### 이항 함수
    	- 일반적으로 단한 함수 보다 이해 힘들다. 가급적 단항 함수로 바꾸자.
    	- 좌표와 같이 한 값을 표현하는 두 요소의 경우 적절하다.
    	- `assertEquals(expected, actual)`조차 사실은 헷갈린다.
    	
    - ##### 삼항 함수
    	- 더 이해하기 힘들다.
    	- `assertEquals(1.0, amount, .001)` 같이 이해를 돕는 드문 경우도 있다.
    	
    - ##### 인수 객체
    	- 인수가 2-3개 필요하다면 일부를 클래스 변수로 선언할 가능성을 검토
    	- 변수를 묶을 때는 이름을 짓게 되므로 개념을 표현하여 명료히 하는 것이다.
    	
    - ##### 인수 목록
    	- 인수 개수가 가변적인 함수의 경우, 가변 인수 전체를 List형 인수 하나로 취급할 수 있다.
    	- `public String format(String format, Object ... args)` 이는 사실상 이항 함수다.
    	
    - ##### 동사와 키워드
    	- 단항 함수는
    		- 함수와 인수가 동사/명사 쌍을 이루어야 한다.
    			- `writeField(name)`
    	- 함수 이름에 키워드를 추가하는 방식
    		- 함수명에 인수명을 넣음으로써 인수 순서를 기억할  필요를 없앤다.
    			- `assertEqualls`대신 `assertExpectedEqualsActual`을 쓰는 식으로

- 부수 효과를 일으키지 마라!
	- 부수효과는 함수가 약속한 바를 벗어난 작업을 하는 "거짓말"이다.
	- 많은 경우 시간적인 결합(temporal coupling)이나 순서 종속성(order dependency)을 초래한다.
		- 굳이 이런 결합이 필요하다면 함수명에 명시해야 한다.
		- 부수 효과로 숨겨진 사항이기에 문제 상황 발생시 파악도 어렵다.
	- ##### 출력 인수
		- this 등 해당 객체의 상태를 변경시키는 방식을 택해서 변경함이 이롭다.
	
- 명령과 조회를 분리하라!
  - 함수는 수행(객체 상태 변경)이나 응답(객체 정보 반환) 둘 중 하나만 해야 한다.
  - `public boolean set(String attribute, String value)`의 경우
  	- set은 동사적 의미로 의도되었지만
  	- 검사를 위해 if 절 안에 있을 경우 형용사로 읽혀 버린다.

- 오류 코드보다 예외를 사용하라!
  - 명령 함수가 오류 코드를 반환하는 경우, 명령을 표현식으로 사용하여 if문에 넣을 수 있다. -> 이는 위와 같은 명령과 조회의 분리에 혼동을 준다.

  - 오류 코드를 반환할 경우 오류코드를 바로 처리해야 하기 때문에 중첩된 코드를 야기한다.

  - ##### Try/Catch블록 뽑아내기

       - try/catch 자체가 정상 동작과 오류 동작을 섞으며, 코드에 혼란을 불러일으키기 쉽기 때문에 별도 함수로 뽑아내는 것이 이롭다.
      - 모든 예외를 처리하게 하고, 별도의 로그 전달 메서드를 사용하면 이후 try 블록에서 호출되는 함수는 예외를 처리하지 않아도 되서 깔끔해진다.

  - ##### 오류 처리도 한 가지 작업이다.
    - 따라서 오류를 처리하는 함수는 오류만 처리해야 한다.
  - ##### Error.java 의존성 자석
    - 오류 코드를 정의하는 것은 의존성 자석 클래스를 만드는 것이다.
    - 오류 코드를 변경시 관련 클래스 모두가 재컴파일/재배치되어야 한다.
    - 새 오류 코드를 추가하기 보다는 기존 오류코드를 재사용하고,
    - 오류 코드 대신 예외를 사용하면 아예 재컴파일 없이 새 예외를 추가할 수도 있다.
    	- Exception 클래스 파생 예외를 새로이 추가하면 된다: OCP활용의 예시

- 반복하지 마라!
  - 중복은 코드 길이를 늘리며, 수정시 동시에 손 봐야 하는 부분도 늘려서 오류 발생 활률을 높인다.
  - 그런 이유로 AOP; Aspect Oriented Programming, COP; Component Oriented Programming, RDB에서의 정규 형식(정규화?) 등 프로그래밍 전반에서 중복을 줄이려는 노력이 나왔다.
- 구조적 프로그래밍
  - 데이크스트라의 구조적 프로그래밍 원칙 - 단일 입/출구 원칙(single entry-exit rule)
  	- 함수, 모든 블록에서 입구와 출구는 하나만 있어야 한다.
  	- return은 하나, continue와 break는 지양, goto는 결코 사용해선 안 된다.
  - 그러나 위의 규율은 매우 큰 크기의 함수에서만 통용될 규칙이다.
  	- 함수를 작게 만든다면 오히려 return, break, continue 사용이 의도를 표현하기 쉽다. 
  	- goto의 경우 큰 함수에서만 의미 있기에 피하자.
- 함수를 어떻게 짜죠?	
  - 글쓰기처럼 서툰 초안을 가다듬어 가면 서 좋은 함수로 만들어나가야 한다.
  - 그러나 초기에도 단위 테스트 케이스를 꼭 만들어야하며, 이후에도 이는 중요하다.
- 결론
  - 모든 시스템은 도메인 특화 언어(DSL; Domain Specific Language)로 만들어진다.
  - 함수는 이 언어에서 동사며
  - 클래스는 명사다.
  - 프로그래밍은 명확하게 규정된 함수와 클래스로 이야기를 풀어내는 것과 같다.

# 4장 주석
- 주석은 실패를 만회하기 위해 사용하는 것이다.
- 주석보다 코드로 의도를 표현하는 것이 더 좋다.
- 부정확한 주석은 없는 것만 못하다.
- 주석은 코드만큼 유지보수되기 힘들며, 오래 되었을수록 위험하다.



- #### 주석은 나쁜 코드를 보완하지 못한다.

- #### 코드로 의도를 표현하라!

- #### 좋은 주석
	- ##### 법적인 주석
		- 소스 파일 첫 머리에 들어가는 저작권 정보나 소유권 정보 등
		- 무작정 열거하지 말고 표준 라이선스나 외부 문서를 참조하는 것이 좋다.
	- ##### 정보를 제공하는 주석
		- 함수의 목적과 반환값을 설명 -> 함수명에 명시하는 것이 더 낫다
		- 정규표현식을 설명 -> 변환하는 별도의 클래스를 만들어 코드를 옮기는 것이 더 낫다
	- ##### 의도를 설명하는 주석
	- ##### 의미를 명료하게 밝히는 주석
		- 인수나 반환값이 표준 라이브러리나 변경하지 못하는 코드에 속한다면 유용
		- 그릇된 주석을 달더라도 검증이 힘들기에 위험한 주석이기도 하다. 주의할 것!
	- ##### 결과를 경고하는 주석
		- 특정 테스트케이스를 꺼야 하는 경우(JUnit4 이후로는 `@Ignore`로 가능)
		- 쓰레드에 안전하지 않은 경우를 경고해주는 경우
	- ##### TODO 주석
		- 필요하지만 당장 구현하기 어려운 업무
		- 하지만 주기적으로 정리하는 것이 좋다.
	- ##### 중요성을 강조하는 주석
	- ##### 공개 API에서 Javadocs
	
- #### 나쁜 주석
	- ##### 주절거리는 주석
	- ##### 같은 이야기를 중복하는 주석
	- ##### 오해할 여지가 있는 주석
	- ##### 의무적으로 다는 주석
	- ##### 이력을 기록하는 주석
		- 관리 프로그램이 할 일이다.
	- ##### 있으나 마나 한 주석
	- ##### 무서운 잡음
	- ##### 함수나 변수로 표현할 수 있다면 주석을 달지 마라
	- ##### 위치를 표시하는 주석
		- 가독성을 낮춤
		- 자주 사용하지 않아야 주의 환기 가능
	- ##### 닫는 괄호에 다는 주석
	- ##### 공로를 돌리거나 저자를 표시하는 주석
	- ##### 주석으로 처리한 코드
		- 관리 프로그램이 대신 기억한다.
	- ##### HTML 주석
	- ##### 전역 정보
		- 주석은 근처에 있는 코드만 기술해야 한다.
		- 대상 코드의 변화가 대상 주석의 변화와 함께 가는 수준이어야.
	- ##### 너무 많은 정보
	- ##### 모호한 관계
		- 주석에 설명이 필요하면 안 된다.
	- ##### 함수 헤더
		- 주석으로 헤더를 추가한 함수보다 짧고 명료한 함수가 더 좋다.
	- ##### 비공개 코드에서 Javadocs

# 5장 형식 맞추기
- #### 형식을 맞추는 목적
	- 코드 형식은 의사소통의 일환이다.
	
- #### 적절한 행 길이를 유지하라
	- 큰 파일보다 작은 파일이 이해하기 쉽다.
	- ##### 신문 기사처럼 작성하라
		- 첫 부분일수록 고차원 개념과 알고리즘을, 아래로 갈수록 세부 내역 및 저차원 함수를 다룬다.
	- ##### 개념은 빈 행으로 분리하라
		- 행 묶음이 각 개념을 나타내고, 빈 행이 그것을 구별하게 하라.
	- ##### 세로 밀집도
		- 서로 밀접한 행은 세로로 인접해야 한다.
	- ##### 수직 거리
		- 밀접한 개념은 세로로 가까이 있어야 한다. -> 가급적 같은 파일에 두자
		- protected 변수를 피해야 하는 이유다.
		- ###### 변수 선언
			- 변수는 사용 위치에 최대한 가까이 선언해야 한다.
			- 지역 변수는 함수 첫 부분에
			- 루프 제어 변수는 루프 문 내부에
			- 긴 함수에서는 블록 상단이나 루프 직전에 변수를 선언하기도
		- ###### 인스턴스 변수
			- 클래스 맨 처음에 선언
			- 변수 간에 서로 세로로 거리를 두지 않음
			- C++의 경우 클래스 마지막에 선언: 가위 규칙(scissors rule)
		- ####### 종속 함수
			- 호출 관계인 함수는 세로로 가까이 배치한다.
			- 호출 함수를 호출되는 함수보다 먼저 배치하는 것이 좋다.
			- 호출되는 함수 안에서 상수를 사용해야 하는 경우 상수를 호출되는 함수 안에서 사용하는 방법도 있지만, 호출하는 함수 쪽에서 인수로 보내는 방식이 더 좋은 경우가 있다(목록 5-5참조). 알아야 할 상수가 저차원 함수에 묻히지 않게 하기 위함이다.
	
- #### 개념적 유사성
	- 개념적 친화도가 높을수록 코드를 가까이 배치한다. 개념적 친화도가 높은 요인으로는:
		- 함수 호출, 변수 사용으로 인한 직접적인 종속성
		- 비슷한 동작을 수행하는 일련의 함수
			- assertTrue와 assertFalse
	- ##### 세로 순서
		- 고차원 함수가 먼저, 저차원 함수가 나중에
		- 중요 개념일수록 앞으로, 세부 사항은 뒤에서
	
- #### 가로 형식 맞추기

	- 기본적으로 짧은 행이 바람직하다. (최대 120자)
	- ##### 가로 공백과 밀집도
		- 밀접성을 기준으로 가로 공백을 줄 지 정한다.
		- 함수명과 괄호 사이에는 공백을 넣지 않는다. 함수와 인수는 서로 밀접하기 때문이다.
		- 연산자 우선순위를 강조하기 위해 공백을 사용한다. 단 승수의 경우 우선순위가 높기에 공백을 없앤다.
	- 가로 정렬
		- 가로 정렬은 엉뚱한 부분을 강조해 코드의 진짜 의도를 가린다.
		- 선언문과 할당문을 일부러 정리하지 말자. 만일 정리가 필요할 정도로 길다면 클래스를 쪼갤 생각을 해보자.
	- ##### 들여쓰기
		- ###### 들여쓰기 무시하기
			- 간단하거나 짧은 반복/조건문, 함수 등에서도 들여쓰기를 사용하라.
	- ##### 가짜 범위
			- 빈 while이나 for문의 경우에도 ;를 들여 써 주자.

- #### 팀 규칙
	- 단일한 팀 규칙을 따라라.
	
	

# 6장 객체와 자료 구조

- 의문: 왜 멤버 변수를 private로 설정하면서 getter, setter를 public하게 제공하는가?
- #### 자료 추상화
	- 구체적인 클래스
	 ```java
	public class Point {
	    public double x;
	    public double y;
	}
	 ```
	- 추상적인 클래스(인터페이스)
	```java
	public interface Point {
	    double getX();
	    double getY();
	    void setCartesian(double x, double y);
	    double getR();
	    double getTheta();
	    void setPolar(double r, double theta);
	}
	```
	- 후자의 경우
		- 데카르트 좌표계 / 극좌표계 중 무엇을 쓰는 지도 모름
		- 그럼에도 자료구조가 명백하게 표현됨
		- 자료구조에 더해서, 접근 정책을 강제
			- 설정 시에는 두 개 동시
			- 읽을 때는 개별적으로
	- 전자의 경우
		- 데카르트 좌표계
		- 접근 정책
			- 개별적으로 get, set
		- 구현을 노출함(public)
		- **변수 사이에 함수 계층이 있다고 해서 구현이 저절로 감춰지는 것은 아니다!**
			- 위의 x, y를 private로 선언한다고 해도 getter, setter를 제공하면 어차피 구현을 외부로 노출하는 것이다.
			- 구현을 감추려면 추상화가 필요하다!
			- 추상 인터페이스를 제공해 사용자가 구현을 모른 채 자료의 핵심을 조작할 수 있어야 한다.
- #### 자료/객체 비대칭
	- 객체는 추상화 뒤로 자료를 숨긴 채 자료를 다루는 함수만 공개한다.
	- 자료구조는 자료를 그대로 공개하며 별다른 함수는 제공하지 않는다.
	> (자료 구조를 사용하는) 절차적인 코드는 기존 자료 구조를 변경하지 않으면서 새 함수를 추가하기 쉽다. 반면, 객체 지향 코드는 기존 함수를 변경하지 않으면서 새클래스를 추가하기 쉽다.

	반면

	> 절차적인 코드는 새로운 자료 구조를 추가하기 어렵다. 그러려면 모든 함수를 고쳐야 한다. 객체 지향 코드는 새로운 함수를 추가하기 어렵다. 그러려면 모든 클래스를 고쳐야 한다.
	- 객체와 자료구조는 근본적으로 양분되며, 상호 보완적인 특질이 있다.
		- 함수를 추가할 상황이 많다면 자료구조
		- 클래스를 추가할 일이 많다면 객체
	- 객체만이 만능이 아니라 단순한 자료 구조와 절차적인 코드가 가장 적합한 상황도 있다.
- #### 디미터 법칙
	- 모듈은 자신이 조작하는 객체의 내부 구현에 대해서 몰라야 한다.
	- 객체는 조회 함수로 내부 구조를 공개하면 안 된다.
	- 클래스 C의 메서드 f는 다음과 같은 객체의 메서드만 호출해야 한다:
		- 클래스 C
		- f가 생성한 객체
		- f 인수로 넘어온 객체
		- C 인스턴스 변수에 저장된 객체
	- 반면 위의 메서드가 반환하는 객체의 메서드는 호출해선 안 된다.
	- ##### 기차 충돌 train wreck
		- `final String outputDir = ctxt.getOptions().getScratchDir().getAbsolutePath();`
		- ctxt, Options, ScratchDir가 자료구조인가, 객체인가에 따라 디미터 법칙 위반 여부가 달라짐
			- 내부 구조를 숨겨야 하는 객체라면 위반이지만
			- 내부 구조를 노출하는 자료구조라면 위반이 아니다.
		- 조회 함수가 아니라 공개 변수라면 디미터 법칙을 생각할 이유도 없다.
			- 자료구조는  함수 없이 공개변수만 포함하고
			- 객체는 비공개 변수와 공개 함수를 포함하는 구조로 짠다면 명확
			- 다만 자바빈 표준처럼 단순 자료구조에도 getter/setter를 정의하라는 프레임워크/표준이 존재한다.
	- ##### 잡종 구조
		- 절반은 객체, 절반은 자료구조인 잡종 구조
		- 자료구조/객체의 단점을 모은 구조
		- 어떤 측면에서건 수정 및 추가가 어려움
	- ##### 구조체 감추기
		- 자료구조가 아니라 객체가 기차 충돌의 형태를 띌 경우 수정될 필요가 있다.
		- 객체는 "뭔가를 해야"하지, "속을 드러내서는" 안 된다.
- #### 자료 전달 객체
	- 자료전달객체(DTO; Data Transfer Object)
	- 공개 변수만 있고 함수가 없는 클래스
	- DB통신, 소켓에서 받은 메시지 구문 분석에 유용
	- 일반적인 Bean구조의 경우 비공개 변수를 getter/setter로 접근하는 방식 취하지만 특별한 의미는 없다.
	- ##### 활성 레코드
		- DB 테이블 등에서 자료를 직접 변환한 결과, 탐색함수 추가 가능, 특수한 DTO
		- 활성 레코드에 비즈니스 로직을 추가하는 것은 잡종 구조를 야기, 지양해야한다.
		- 활성 레코드는 자료구조로 취급하고 별도의 클래스로 비즈니스를 다룬다.

# 7장 오류처리
- 적절한 오류 처리가 이루어지지 않으면 코드가 난잡해진다.
- #### 오류 코드보다 예외를 사용하라
	- 오류플래그나 오류 코드를 사용하면 바로 처리해야 하기 때문에 코드가 난잡
- #### Try-Catch-Finally 문부터 작성하라
	- 강제로 예외를 일으키는 테스트 케이스 작성 후 테스트를 통과하게 코드를 작성한다면 TDD 방식으로 코드 작성 용이하다.
	- try 블록의 트랜잭션 범위부터 구현하게 되므로 트랜잭션 본질을 유지하기 용이하다.
- #### 미확인unchecked 예외를 사용하라
	- 확인된 예외는 OCP를 위반한다.
		- 하위 단계에서 예외를 던지면 상위 단계의 catch 블록에 예외를 정의하게 된다.
		- 이는 하위 단계의 코드 수정이 상위 단계 메서드 선언부 수정을 요구하게 만든다.
	- 매우 중요한 라이브러리가 아닌 이상 모든 예외를 잡으려 하는 것은 의존성이라는 더 큰 비용을 야기한다.
- #### 예외에 의미를 제공하라
	- 자바는 모든 예외에 호출 스택을 제공하지만 이것만으로는 실패한 코드 의도 파악에 부족하다.
	- 오류 메시지를 사용하라.
		- 실패한 연산명, 실패 유형도 언급한다.
		- catch 블록에서 로그 기능을 활용하라.
- #### 호출자를 고려해 예외 클래스를 정의하라
	- Wrrapper 클래스
	  		- 외부 API 사용시 감싸라 -> 의존성을 낮출 수 있어서 타 라이브러리로 변경하기 용이하다.
	    		- API 호출 대신 테스트 코드를 넣는 식으로 테스트가 용이하다.

- #### 정상 흐름을 정의하라
	- 비즈니스 로직과 예외 처리가 분리된 코드
		- 좋은 코드지만 오류감지가 밀려나게 된다.
		- catch 부분에서 중단된 로직을 처리하는 방식이 로직을 알아보기 힘들게 만들기도 한다.
			- 이 경우 특수 사례 패턴: 클래스나 객체가 예외적인 상황을 캡슐화하여 처리하는 방식을 사용하라.
- #### null을 반환하지 마라
	- null 확인이 너무 많은 코드는 적절치 않다.
	- null을 반환하는 대신 예외를 던지거나 특수 사례 객체를 반환하라.
	- null 대신 빈 리스트를 반환하는 것이 그 예다.
- #### null을 전달하지 마라
	- 정상적인 인수로 null을 기대하는 API가 아니라면 메서드로 null을 전달하는 코드는 피해라.
	- 예외를 던지거나 assert를 이용하거나, 방법은 많지만 그냥 전달하지 않는 것이 최선이다.
- #### 결론
	- 읽기 좋을뿐만 아니라 안정성이 높은 코드가 좋은 코드다.
	- 오류 처리와 프로그램 논리를 분리하면 더 튼튼하고 깨끗한 코드가 작성된다. 이는 독립적인 추론을 가능케 하며, 유지보수성을 높인다.



# 8장 경계
- #### 외부 코드 사용하기
	- 시스템 경계의 문제 발생 원인
		- 인터페이스(패키지, 프레임워크) 제공자는 적용성을 최대한 넓히려 한다.
		- 반면 사용자는 자신의 요구에 집중하는 인터페이스를 원한다.
	- `java.utill.Map`의 경우
		- 다수의 기능, 특히 함부로 호출하면 위험한 `clear()` 등의 기능이나 클라이언트에게 불필요한 기능들이 제공된다는 문제점
		- 인터페이스의 변경이 발생하면 관련 코드를 대대적으로 수정해야 하는 문제 발생
			- 자바5의 제네릭스 지원으로 인한 레거시 코드 수정 문제
		- Map을 사용하는 클래스를 미리 Wrapper 클래스로 감싸, `get()` 사용시에 형변환을 하게끔 캡슐화하여 Map 인터페이스의 변화로 인한 문제를 피할 수 있다.
		- 이런 방식은 외부 프로그램에 필요한 규칙만 제공하여 그 프로그램들이 설계 및 비즈니스 규칙을 준수하게 만들 수 있다.
	- 해결방안
		- 위와 같은 캡슐화
		- Map과 같은 경계 인터페이스를 함부로 넘기지 않는다.
			- 이용하는 클래스나 클래스 계열 밖으로 노출되지 않게끔 한다.
			- 공개 API의 인수로 넘기거나 반환값으로 사용하지 않는다.
- #### 경계 살피고 익히기
	- 문제
		- 외부 코드는 생산성을 높여준다.
		- 하지만 외부 코드를 익히기도, 통합하기도 어렵다.
		- 외부 라이브러리의 사용법을 불명확하게 알고 있거나, 우리 쪽 문제인지 라이브러리 문제인지 알지 못 해 디버깅에 어려움을 겪는 문제 발생
	- 학습 테스트
		- 간단한 테스트 케이스를 먼저 작성해서 외부 코드를 익힘
		- 사용하고자 하는 방식대로 외부 API를 홈출함으로써, 통제된 환경에서의 API를 내가 잘 이해하는지를 확인
		- API를 사용하려는 목적에 초점을 맞춤
-  #### log4j 익히기
- #### 학습 테스트는 공짜 이상이다
	- 학습 테스트는 새 피키지를 배우는 데 드는 비용을 감소시켜준다.
	- 버전이 업데이트 될 때 발생 가능한 호환성 문제를 학습 테스트가 바로 밝혀준다.
	- 학습 테스트와 별개로 실제 코드를 통해 인터페이스를 사용하는 테스트 케이스도 당연히 필요하다. 이 경계 테스트는 새 버전으로 이전하는 데 도움이 된다.
- #### 아직 존재하지 않는 코드를 사용하기
	- 모른것과 아는 것을 분리하고, 아는 것부터 시작한다.
	- 모르는 영역은
		- 자체적으로 인터페이스를 정의한 후
		- 적절히 Fake 클래스를 사용하다가
		- 어댑터 패턴을 통해 다른 팀에서 완성된 API에 맞춰나간다.
- #### 깨끗한 경계
	- 경계에 위치하는 코드는 명확히 분리하며 기대치에 대한 테스트 케이스를 작성한다.
	- 외부 패키지의 세부 내용을 알아, 의존하지 말고 통제 가능한 우리 코드에 의존하라.

# 9장 단위 테스트
#### TDD 법칙 세 가지
1. 실패하는 단위 테스트를 작성할 때까지 실제 코드를 작성하지 않는다.
2. 컴파일은 실패하지 않으면서 실행이 실패하는 정도로만 단위 테스트를 작성한다.
3. 현재 실패하는 테스트를 통과할 정도로만 실제 코드를 작성한다.
- 개발과 테스트가 약 30초 주기로 묶이게 된다.
- 방대한 테스트 코드가 관리 문제를 유발하기도 한다.
#### 깨끗한 테스트 코드 유지하기
- 테스트 코드의 품질은 중요하다.
- 테스트 코드의 품질이 낮다면, 테스트 코드 작성, 유지, 보수에 드는 시간이 오래 걸린다.
##### 테스트는 유연성, 유지보수성, 재사용성을 제공한다.
- 테스트 커버리지가 높을수록 변경 시 발생하는 버그를 잡아내기에 용이하다.
- 따라서 테스트는 변경, 확장의 버팀목이 된다.
#### 깨끗한 테스트 코드
- 테스트 코드에서 가장 중요한 것은 가독성
- 이를 위해 명료성, 단순성, 표현력이 필요
- 테스트코드는 본론에 도립해 진짜 필요한 자료 유형과 함수만 사용한다.
##### 도메인에 특화된 테스트 언어
- DSL; Domain Specific Language
- 시스템 조작 API를 사용하지 않고
- 그 API 위에 함수, 유틸리티 구현 후 사용
- 가독성을 높여주는 테스트 언어가 됨
##### 이중 표준
- 테스트 API의 표준은 실제 코드의 표준과는 다르다.
- 성능 요구사항보다는 간결함, 표현력에 더 집중하라
#### 테스트 당 assert 하나
- assert문이 하나만 있을 경우 결론이 하나기에 이해가 쉽고 빠르다.
- given-when-then 관례
- assert를 하나씩만 사용하면 중복 코드가 많아진다.
- template method패턴으로 중복 제거 가능
	- given/when을 부모클래스에, then을 자식클래스에 둔다.
	- 혹은 @Before함수가 given/when을, @Test 함수가 then을 담당하게 할 수도 있다.
##### 테스트 당 개념 하나
- 개념 별로 테스트를 분리할 경우 테스트 코드가 의도하는 일반 규칙이 잘 드러난다.
- assert문은 최소로 사용하고, 테스트 당 개념 하나만 다뤄라.
#### F.I.R.S.T
- Fast: 빨라야 자주 돌리고 쉽게 정리한다.
- Independent: 의존성은 연쇄적 실패를 야기하기에 원인 진단이 어렵다.
- Repeatable: 환경을 이유로 테스트 실패를 변명할 수 없어야 하며, 어떤 환경에서도 테스트에 지장이 있어선 안 된다.
- Self-Validating: 테스트는 부울 값으로 결과를 내야 한다. 테스트 스스로 성공이나 실패를 가늠해야 한다.
- Timely: 테스트는 적시에 작성해야 한다. 단위 테스트는 실제 코드를 구현하기 전에 구현한다. 테스트하기 쉬운 코드를 짜기 위함이다.

# 10장 클래스
#### 클래스 체계
- 변수 목록
	- static public
	- static private
	- private
- 함수 목록
	- public
	- private: 자신을 호출하는 public 함수 직후에
##### 캡슐화
- 경우에 따라 변수나 유틸리티 함수를 protected로 선언, 테스트 코드 등에서 사용할 수 있다.
- 그러나 캡슐화를 푸는 것은 언제나 최후의 수단이 되어야 한다.
#### 클래스는 작아야 한다!
- 함수의 경우는 물리적인 행 수가 크기의 척도라면
- 클래스의 경우 책임이 그 기준이다.
- 메서드가 적더라도 클래스의 책임이 클 수 있다.
- 클래스명은 클래스 책임을 기술해야 한다.
	- 클래스 이름에 모호한 명칭: Processor, Manager, Super 등이 있거나
	- if, and, or, but 등이 있으면
	- 클래스 책임이 너무 많은지 생각해봐야 한다.
##### 단일 책임 원칙
- 단일 책임 원칙(SRP; Single Responsibility Principle)
	- 클래스나 모듈 변경의 근거-책임은 단 하나여야 한다.
	- 책임 파악은 추상화 파악과 같다.
	- 추상화 작업을 통해 재사용성이 높은 코드를 얻을 수 있다.
##### 응집도(cohesion)
- 클래스의 메서드와 변수가 서로 의존적이며 논리적인 단위로 묶일 수록 높다.
- 응집도가 높아질수록 변수와 메서드를 새 클래스로 쪼개 줄 필요가 있다.
##### 응집도를 유지하면 작은 클래스 여럿이 나온다
- 함수를 빼낼 때, 사용 변수를 인수로 넘기지 말아라.
- 해당 변수를 멤버변수로 승격한다면 인수가 없는 함수를 만들 수 있고, 다시 쪼개기 쉬워진다.
#### 변경하기 쉬운 클래스
- SRP, OCP
##### 변경으로부터 격리
- 구현에 의존하는 클래스는 변화에 따라 문제 발생
- 인터페이스와 추상 클래스를 사용하여 구현이 미치는 영향을 격리
- 상세한 구현에 의존하는 코드는 테스트가 어려움
- 동일 인터페이스를 구현하는 테스트 코드를 짜는 것이 좋다.
- 위와 같이 시스템의 결합도를 낮추면 유연성과 재사용성이 높아짐
- 결합도를 최소화하면 DIP를 준수하는 클래스가 나옴

# 11장 시스템
- 추상화, 관심사 분리
- 높은 추상화 수준, 즉 시스템 수준에서도 깨끗함을 유지하는 법?
#### 시스템 제작과 시스템 사용을 분리하라
> 소프트웨어 시스템은 (애플리케이션 객체를 제작하고 의존성을 서로 '연결'하는) 준비 과정과 (준비 과정 이후에 이어지는) 런타임로직을 분리해야 한다.
- 관심사(concern) 분리
	- 시작 단계: 모든 어플리케이션에 해당하는 관심사
	- 초기화 지연(Lazy Initialization) / 계산 지연(Lazy Evaluation)
		```java
		public Service getService() {
			if (service == null) {
				service = new MyServiceImpl(...);
			}
			return service;
		}
		```
		- 성능상의 이점 얻으며, 시작 속도가 빨라짐
		- null 포인터 반환하지 않음
		- 위 코드 자체의 문제점
			- MyServiceImpl과 생성자 인수에 의존
			- service 필드에 테스트 전용 객체를 할당해야함
			- 런타임 로직에 생성 로직을 섞어놔서, null인지에 따라 모든 시행 경로를 테스트해야 한다. -> SRP 위반
			- MyServiceImpl이 모든 상황에 적합할지에 대한 의문
		- 설정 논리는 실행 논리와 분리 -> 모듈성
##### Main 분리
- 시스템 생성과 사용을 분리
	- 생성과 관련된 코드는 main과 그것이 호출하는 모듈로
	- 애플리케이션은 객체를 사용할 뿐
##### 팩토리
- 객체가 생성되는 시점을 애플리케이션이 결정해야 할 경우
- 추상 팩토리 패턴을 이용, 애플리케이션이 생성 시점은 결정하지만 구체적인 생성은 모름
##### 의존성 주입
- IoC기법을 의존성 관리에 적용
- (생성을 분리하여) SRP 준수 도움
- main 루틴이나 특수 컨테이너가 이를 담당
- 진정한 의존성 주입은 클래스가 의존성을 해결하려 시도하지 않고, 완전히 수동적 입장에 있다.
- DI 컨테이너에서도 초기화 지연이 사용되기도 한다.
#### 확장
> '처음부터 올바르게' 시스템을 만들 수 있다는 믿음은 미신이다. 대신에 우리는 오늘 주어진 사용자 스토리에 맞춰 시스템을 구현해야 한다. 내일은 새로운 스토리에 맞춰 시스템을 조정하고 확장하면 된다. 이것이 반복적이고 점진적인 애자일 방식의 핵심이다.
- TDD, 리팩토링, 그로 인한 클린 코드는 코드 레벨에서 시스템 조정과 확장을 돕는다.
- 시스템 레벨에서는 "단순한 아케텍처를 복잡한 아키텍처로 조금씩 키울 수 없다는 현실"에 유의할 필요가 있다.
- 관심사 분리를 통해 점진적 발전 가능성을 열 수 있다.
##### 횡단 관심사(cross-cutting)
- AspectOrientedProgramming
	- 회단 관심사에 대처해 모듈성을 확보하는 방법론
	- AOP의 관점(aspect)
#### 자바 프록시
- JDK 동적 프록시는 인터페이스만 지원
	- CGLIB, ASM, Javassist 등 바이트 코드 처리 라이브러리 필요
#### 순수 자바 AOP 프레임워크
#### AspectJ 관점
#### 테스트 주도 시스템 아키텍처 구축
> 최선의 시스템 구조는 각기 POJO (또는 다른) 객체로 구현되는 모듈화된 관심사 영역(도메인)으로 구성된다. 이렇게 서로 다른 영역은 해당 영역 코드에 최소한의 영향을 미치는 관점이나 유사한 도구를 사용해 통합한다. 이런 구조 역시 코드와 마찬가지로 테스트 주도 기법을 적용할 수 있다.
- BDUF; Big Design Up Front를 추구할 필요가 없다.
	- 심리적 저항감, 초기 아키텍처의 영향으로 수정 어려움
	- 물리적 수정이 어려운 건축에서는 BDUF가 어울리지만, 소프트웨어는 관점 분리로 변화 용이
- BDUF를 배제한다고 해서 방향성 없이 프로젝트를 시작하는 것은 아니다.
#### 의사 결정을 최적화하라
- 모듈, 관심사 분리는 지엽적 관리 및 결정을 가능케 한다.
- 마지막까지 정보를 모아 최선의 결정을 내려라
#### 명백한 가치가 있을 때 표준을 현명하게 사용하라
> 표준을 사용하면 아이디어와 컴포넌트를 재사용하기 쉽고, 적절한 경험을 가진 사람을 구하기 쉬우며, 좋은 아이디어를 캡슐화하기 쉽고, 컴포넌트를 엮기 쉽다. 하지만 때로는 표준을 만드는 시간이 너무 오래 걸려 업계가 기다리지 못한다. 어떤 표준은 원래 표준을 제정한 목적을 잊어버리기도 한다.
#### 시스템은 도메인 특화 언어가 필요하다
- JMock은 DSL; Domain-Specific Language의 좋은 자바 API의 예다.
- 좋은 DSL은 도메인 개념과 구현 코드 사이의 의사소통 간격을 좁혀준다.
- DSL은 추상화 수준을 매우 끌어올린다.
- DSL의 사용은 모든 추상화 수준과 모든 도메인을 POJO로 표현할 수 있다.

# 12장 창발성(創發性)
- 켄트 백의 단순한 설계 규칙 4가지(중요도 순)
	1. 모든 테스트를 실행한다.
	2. 중복을 없앤다.
	3. 프로그래머 의도를 표현한다.
	4. 클래스와 메서드 수를 최소로 줄인다.
#### 단순한 설계 규칙1: 모든 테스트를 실행하라
- 모든 테스트를 통과하는 시스템 -> 테스트 가능한 시스템 -> 검증이 가능한 시스템
- 테스트 가능한 시스템을 의도하면 설계 품질이 높아진다.
	- SRP를 준수하는 클래스는 테스트가 훨씬 더 쉽다.
	- 결합도를 낮출수록 테스트가 쉽다.
		- DIP원칙 적용, DI, 인터페이스, 추상화를 적용
#### 단순한 설계 규칙 2~4: 리팩터링
- 테스트 케이스 작성 이후에는 점진적 리팩터링
- 테스트 케이스 덕택에 코드 수정 및 추가로 인한 기능 손상을 감지할 수 있다.
- 중복을 없애고, 의도를 표현하고, 클래스와 메서드 수를 줄이는 등 더 나은 품질을 위한 제 작업
#### 중복을 없애라
- 소규모 재사용은 시스템 복잡도를 크게 줄인다.
- TEMPLATE METHOD 패턴: 고차원 중복 제거용으로 용이
#### 표현하라
- 처음부터 코드를 명백하게 짜는 것이 유지보수 비용과 유관 문제들을 줄일 수 있다.
	- 좋은 명명
	- 최소화된 함수와 클래스
	- 표준 명칭: 디자인 패턴의 명칭 등
	- 단위 테스트 케이스
#### 클래스와 메서드 수를 최소로 줄여라
- 기본원칙도 극단적일 경우 실이 더 많다.
- 실용적 방식을 선택하라

# 13장 동시성
- 동시성과 깔끔한 코드는 양립이 어려움
#### 동시성이 필요한 이유?
- 동시성은 결합(coupling)을 없애는 전략: 결합분리(decoupling)
	- 무엇(what)과 언제(when)을 분리
		- 단일 스레드 프로그램은 무엇과 언제가 밀접
		- 단일 스레드 프로그램은 흔히 정지점(breakpoint) 기반으로 디버깅
	- 결합 분리는 프로그램을 단일 거대 루프가 아니라
	협력 프로그램 여럿으로 만든다.
	- 이는 시스템 이해를 돕고, 문제 분리를 돕는다.
	- 예시) 웹 / EJB 컨테이너와 서블릿
- 동시성의 필요성
	- 구조적 이점
	- 특히, 성능적 요구사항
##### 미신과 오해
- 동시성에 대한 오해
	- 동시성은 항상 성능을 높여준다.
	- 동시성을 구현해도 설계는 변하지 않는다.
	- 웹 / EJB 컨테이너를 사용하면 동시성을 이해할 필요가 없다.
- 동시성에 대한 사실
	- 동시성은 다소 부하를 유발한다.
	- 동시성은 복잡하다.
	- 일반적으로 동시성 버그는 재현하기 어렵다.
	- 동시성을 구현하려면 흔히 근본적인 설계 전략을 재고해야 한다.
#### 난관
- 시퀀스 필드값을 공유하는 경우, 동일 값을 가지게 되는 상황이 존재한다.
#### 동시성 방어 원칙
##### 단일 책임 원칙(SRP; Single Responsibility Principle)
- 동시성 코드는 다른 코드와 분리하라
	- 별도의 변경 주기를 갖고
	- 다른 종류의 난점을 가지며
	- 더 어렵고 복잡하기 때문이다.
##### 따름 정리(계, 귀결, corollary): 자료 범위를 제한하라
- 공유 객체를 사용하는 코드 내 임계영역(critical section)을 synchronized 키워드로 보호하라.
- 동시에, 임계영역은 최소화하라: 임계영역이 많을수록
	- 임계영역 보호를 빼먹을 수 있으며
	- 임계영역 확인을 위한 비용이 발생하며
	- 버그 탐색이 어렵기에
- 따라서 자료를 캡슐화하고 공유 자료를 최소화하라
##### 따름 정리: 자료 사본을 사용하라
- 공유 자료 자체를 피하는 것이 최선이다.
- 사본 생성으로 인한 비용과 동기화로 인한 비용을 비교해볼 필요가 있다. (일반적으로는 사본을 이용해 동기화를 피하는 것이 이득이다.)
##### 따름 정리: 스레드는 가능한 독립적으로 구현하라
- 다른 스레드와 자료를 공유하지 않는 스레드를 구현한다.
- 비공유 출처의 자료를 로컬 변수에 저장하며
- 각각이 각 요청 단위만 처리하게 된다면
- 타 스레드와 동기화할 필요가 없어진다.
- 단, 이 방법으로 동일 DB 연결과 같은 자원 공유를 피해갈 수는 없다.
- 독자적인 스레드로, 가능하면 다른 프로세서에서, 돌려도 괜찮도록 자료를 독립적인 단위로 분할하라.
#### 라이브러리를 이해하라
- 자바5의 동시성 관련 기능들
	- thread-safe 컬렉션
	- 서로 무관한 작업시에 사용하는 excetutor 프레임워크
	- 가능하다면 스레드가 blocking 되지 않는 방법 사용
	- 일부 클래스 라이브러리는 thread-safe하지 않음
##### 스레드 환경에 안전한 컬렉션
- `java.util.concurrent` 패키지
	- thread-safe
	- 성능도 좋음
- 대표적으로 ConcurrentHashMap
- 그 외에는 ReentrantLock, Semaphore, CountDownLatch
#### 실행 모델을 이해하라
- 스레드 관련 용어들
	- 한정된 자원(Bound Resource): DB연결, 길이가 일정한 읽기/쓰기 버퍼 등
	- 상호 배제(Mutual Exclusion): 한 번에 한 스레드만 공유 자료/자원을 사용할 수 있는 경우
	- 기아(Starvation): 한 스레드나 여러 스레드가 오랫동한 혹은 영원히 자원을 기다림
	- 데드락(Deadlock): 여러 스레드가 서로 끝나기를 기다림. 서로 필요 자원을 점유하고 있기에 모두 진행 불가
	- 라이브락(Livelock): 락을 거는 단계에서 각 스레드가 서로 방해. 스레드는 진행하려 하지만 공명(resonance)으로 인해 오랫동안 혹은 영원히 진행 불가
- 다중 스레드의 실행 모델들은 다음과 같다:
##### 생산자-소비자(Producer-Consumer)
- 생산자 스레드가 정보를 생성해 버퍼나 대기열(queue)에 넣는다.
	- 생상자는 빈 대기열을 요하며
	- 대기열을 채운 후 소비자 스레드에 신호를 보낸다.
- 소비자 스레드가 대기열에서 정보를 가져와 사용한다.
	- 소비자는 채워진 정보가 필요하며
	- 대기열을 읽어들인 후 대기열에 빈 공간이 있다는 신호를 생산자 스레드에 보낸다.
- 대기열은 한정된 자원이다.
- 양 쪽 다 작업 진행 가능함에도 신호를 기다릴 가능성이 존재한다.
##### 읽기-쓰기(Readers-Writers)
- 읽기 스레드는 공유 자원을 정보원으로 사용하고
- 쓰기 스레드는 공유 자원을 이따금 갱신한다.
- 처리율(throughput)
	- 처리율을 강조하면 기아현상 발생하거나 오래된 정보가 쌓임
	-  갱신 허용은 처리율에 영향을 미친다.
		- 읽기/쓰기 스레드가 공유 자원을 사용하는 중 간섭하지 않기 위한 균형이 필요하다.
		- 일반적으로는 읽기 스레드가 쓰기 스레드를 기다리다가 처리율이 저하한다.
- 해결 전략
	- 한 쪽 스레드가 없을 때까지 다른 스레드가 버퍼를 기대리는 방식
	- 읽기 우선은 기아상태 유발을, 쓰기 우선은 처리율 하락의 문제가 있다.
##### 식사하는 철학자들(Dining Philosophers)
- 스레드와 자원 분배 문제의 예시
#### 동기화하는 메서드 사이에 존재하는 의존성을 이해하라
- 동기화 메서드 사이에 의존성 존재시 식별하기 어려운 버그 발생
- 공유 객체 하나 당 메서드 하나만 사용할 것
- 여러 메서드가 필요한 경우 해결법:
	- 클라이언트에서 잠금: 클라이언트에서 첫 메서드를 호출하기 전에 서버를 잠그고, 마지막 메서드를 호출할 때까지 잠금 유지
	- 서버에서 잠금: "잠금 - 모든 메서드 실행 - 잠금 해제"하는 메서드 구현, 클라이언트로 이 메서드 호출
	- 연결(Adapted) 서버: 잠금을 수행하는 중간 단계 생성, 기존 서버와 별도
#### 동기화하는 부분을 작게 만들어라
- synchronized 키워드
	- 락
		- 동일 락으로 감싼 코드 영역은 한 번에 한 스레드만 실행 가능
		- 스레드 지연, 부하 가중
	- 락이 많을수록 성능상 문제가 발생하지만, 임계영역은 동시성 문제를 막기 위해 꼭 락으로 보호 해줘야 한다.
		- 따라서 임계영역을 보호하되, 최소화(수적으로도, 크기 측면에서도)해야 한다.
- 동기화하는 부분을 가능한 작게 만들어라

#### 올바른 종료 코드는 구현하기 어렵다

