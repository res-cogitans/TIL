# 클린 코드
- 애자일 소프트웨어 장인 정신
- 로버트 C. 마틴

# 2장 의미 있는 이름
- 의도를 분명히 밝혀라
- 그릇된 정보를 피해라
	- 자주 쓰이는 용어를 다른 의미로 규정해선 안 된다.
		- 목록을 다룬다고 해서 List 자료형이 아닌 것을 list라 명명해서는 안 된다.
	- 유사한 이름을 사용하지 않아야 한다.
	- 유사한 개념은 유사한 표기법을 사용한다.
- 의미 있게 구분하라
	- 연속된 숫자를 덧붙이거나 불용어(noise word)를 사용하는 방식은 부적절하다.
		- a가 있어서 붙인 a1, a2나 class가 있어서 붙인 klass 등은 정보를 전달하지 못 한다.
		- 이름이 다르다면, 의미도 달라야 한다.
		- 변수명에 xVariable이 있다면 그것은 동어반복적일 뿐이다. x와 xVariable 사이에 정보 차이는 존재하지 않는다.
- 발음하기 쉬운 이름을 사용하라
	- 프로그래밍은 사회 활동이다.
- 검색하기 쉬운 이름을 사용하라
	- 지나치게 짧은 이름은 눈에 띄지 않으며 검색되기 어렵다.
	- 검색하기 쉬운 이름이 상수보다 좋다.
	- 이름 길이는 범위 크기에 비례해야 한다.
		- 간단한 메서드의 로컬 변수 정도가 되어야 한 문자 이름을 쓴다.
- 인코딩을 피하라
	- 인코딩 규칙을 추가적으로 익히는 부담
	- 인코딩한 이름은 발음이 힘들고 오타가 발생하기 쉽다.
	- 자료형을 이름에 명시할 경우 이름이나 타입을 유연하게 변경하기 힘들게 하며, 불일치시 잘못된 정보를 준다.
	- 헝거리안 표기법은 이름 길이 제한이나 자료형 검사가 부족한 시절의 산물일 뿐이다.
	- 멤버 변수의 경우 접두어를 붙이지 말고, 클래스나 함수 자체를 작게 만들어라.
	- 인터페이스 클래스와 구현 클래스
		- 인코딩은 인터페이스가 아니라, 구현 클래스에 붙이는 편이 낫다.
- 자신의 기억력을 자랑하지 마라
	- 이름을 독자가 아는 이름으로 변환해서 읽어야 하면 좋은 코드가 아니다.
	- 한 글자 변수명이 대표적이다.
		- 다만 반복문의 i, j, k는 괜찮다. (l은 안 된다!)
		- 루프 범위가 작고 다른 이름과 충돌하지 않을때만 사용하라!
- 클래스 이름
	- 명사나 명사구를 사용.
	- Manager, Processor, Data, Info 등의 단어는 피해라. [의문점]
- 메서드 이름
	- 동사나 동사구를 사용.
	- 자바빈 표준에 따른 접두사
		- 접근자(Accessor) - get
		- 변경자(Mutator) - set
		- 조건자(Predicate) - is
	- 생성자 오버로딩 시에 정적 팩토리 메서드를 사용 -> 이름을 통한 정보 전달
- 기발한 이름은 피하라
- 한 개념에 한 단어를 사용하라
	- get, fetch, retrieve가 혼재되는 상황
- 말장난을 하지 마라
	- 한 단어를 두 가지 목적으로 사용하지 마라.
	- 다른 개념에는 다른 단어를 사용하라.
- 해법 영역에서 가져온 이름을 사용하라
	- 모든 이름을 도메인에서 가져오지는 말자.
	- 프로그래머가 읽을 코드기에 프로그래밍 용어를 사용하는 것이 전달력이 좋을 수 있다.
- 문제 영역에서 가져온 이름을 사용하라
	- 적절한 프로그래밍 용어가 없다면 문제 영역에서 이름을 가져오라. 프로그래머가 전문가에게 의미를 묻는 식으로 파악 가능하다.
	- 문제 영역과 관련 깊은 코드라면 문제 영역에서 이름을 가져와라.
		- 해법 영역과 문제 영역의 분리
		- Repository에서는 프로그래밍 용어에 가까운 표현을 쓰지만
		- Service에서는 비즈니스 모델에 가까운 표현이 적합
- 의미 있는 맥락을 추가하라
	- 클래스, 함수, 이름 공간에 변수를 넣어 맥락을 부여하라.
	- 마지막 수단으로나 접두어를 고려하라.
- 불필요한 맥락을 없애라
	- 의미가 분명한 한에서 짧은 이름이 좋다.
- 마치면서
	- 좋은 이름의 선택은
		- 설명 능력
		- 문화적 배경
		- 교육 문제
		와 유관

# 3장 함수

- 작게 만들어라!
	- 블록과 들여쓰기
		- if/else/while문 등에 들어가는 블록은 한 줄이어야 한다. 2단을 넘어서지 마라!
		- 중첩 구조가 생길만큼 함수가 커져서는 안 된다.
	
- 한 가지만 해라!
  > 함수는 한 가지를 해야 한다. 그 한 가지를 잘 해야 한다. 그 한 가지만을 해야 한다.
  - 지정된 함수 이름 단계에서 추상화 수준이 하나인 단계만 수행하라!
  - 그저 이름만 다른 표현이 아니라 의미 있는 이름으로 다른 함수를 추출할 수 있다면 그 함수는 여러 작업을 하는 것이다.
  - 함수 내 섹션
  	- 한 가지 작업만 하는 함수는 자연스럽게 섹션으로 나누기 어렵다.

- 함수 당 추상화 수준은 하나로!
  - 함수가 한 가지 작업만 하기 위해서는 위해서는 함수 내 모든 문장의 추상화 수준이 동일해야 한다.
  - 근본 개념과 세부 사항이 분리되지 않으면 이해가 힘들며, 더 복잡하게 세부사항이 추가되기 쉽다.
  - 위에서 아래로 코드 읽기: 내려가기 규칙
  	- 위에서 아래로 프로그램을 읽으면 추상화 수준이 한 번에 한 단계씩 내려가야 한다.
  	- TO문단을 읽듯이 프로그램이 읽혀야 한다.

- Switch 문
  - switch문이나 if/else가 다수인 문은 작게 만들기 어렵다.
  - 대신 다형성을 이용하여 각 switch문을 저차원 클래스에 숨기고 반복하지 않아야 한다.
  - 추상 팩토리 내에 switch문을 숨기는 방법이 가능하다.
  - switch문은 다형적 객체 생성 코드에서만 단 한번 쓰고 마는 것이 이상적이다.

- 서술적인 이름을 사용하라!
  - 함수가 작고 단순할수록 서술적인 이름을 고르기도 쉬워진다.
  - 길고 서술적인 이름이 짧고 어려운 이름이나 길고 서술적인 주석보다 좋다.

- 함수 인수
  - 적을 수록 좋다!

  - 인수는 개념 이해를 어렵게 한다.

  - 테스트 작성에서도 인수가 없는 편이 낫다.

  - 출력 인수는 입력 인수보다 어렵다.

  - 많이 쓰는 단항 형식
    - 인수에 질문을 던지는 형식 `boolean fileExists("MyFile")`

    - 인수를 변환해 결과를 반환하는 형식 `InputStream fileOpen("MyFile")`

    - 주로 위 두 가지를 사용

    - 이벤트 함수

      - 출력 인수 없음
      - 입력 인수로 시스템 상태 변경
      - 이벤트임을 명확히 드러내야

    - 이 외의 경우 단항 함수는 피한다.

    - ##### 플래그 인수
    	- 함수로 boolean 값 넘김
    	- 한 번에 여러가지를 한 다는 의미 -> 쓰지 마라
    	
    - ##### 이항 함수
    	- 일반적으로 단한 함수 보다 이해 힘들다. 가급적 단항 함수로 바꾸자.
    	- 좌표와 같이 한 값을 표현하는 두 요소의 경우 적절하다.
    	- `assertEquals(expected, actual)`조차 사실은 헷갈린다.
    	
    - ##### 삼항 함수
    	- 더 이해하기 힘들다.
    	- `assertEquals(1.0, amount, .001)` 같이 이해를 돕는 드문 경우도 있다.
    	
    - ##### 인수 객체
    	- 인수가 2-3개 필요하다면 일부를 클래스 변수로 선언할 가능성을 검토
    	- 변수를 묶을 때는 이름을 짓게 되므로 개념을 표현하여 명료히 하는 것이다.
    	
    - ##### 인수 목록
    	- 인수 개수가 가변적인 함수의 경우, 가변 인수 전체를 List형 인수 하나로 취급할 수 있다.
    	- `public String format(String format, Object ... args)` 이는 사실상 이항 함수다.
    	
    - ##### 동사와 키워드
    	- 단항 함수는
    		- 함수와 인수가 동사/명사 쌍을 이루어야 한다.
    			- `writeField(name)`
    	- 함수 이름에 키워드를 추가하는 방식
    		- 함수명에 인수명을 넣음으로써 인수 순서를 기억할  필요를 없앤다.
    			- `assertEqualls`대신 `assertExpectedEqualsActual`을 쓰는 식으로

- 부수 효과를 일으키지 마라!
	- 부수효과는 함수가 약속한 바를 벗어난 작업을 하는 "거짓말"이다.
	- 많은 경우 시간적인 결합(temporal coupling)이나 순서 종속성(order dependency)을 초래한다.
		- 굳이 이런 결합이 필요하다면 함수명에 명시해야 한다.
		- 부수 효과로 숨겨진 사항이기에 문제 상황 발생시 파악도 어렵다.
	- ##### 출력 인수
		- this 등 해당 객체의 상태를 변경시키는 방식을 택해서 변경함이 이롭다.
	
- 명령과 조회를 분리하라!
  - 함수는 수행(객체 상태 변경)이나 응답(객체 정보 반환) 둘 중 하나만 해야 한다.
  - `public boolean set(String attribute, String value)`의 경우
  	- set은 동사적 의미로 의도되었지만
  	- 검사를 위해 if 절 안에 있을 경우 형용사로 읽혀 버린다.

- 오류 코드보다 예외를 사용하라!
  - 명령 함수가 오류 코드를 반환하는 경우, 명령을 표현식으로 사용하여 if문에 넣을 수 있다. -> 이는 위와 같은 명령과 조회의 분리에 혼동을 준다.

  - 오류 코드를 반환할 경우 오류코드를 바로 처리해야 하기 때문에 중첩된 코드를 야기한다.

  - ##### Try/Catch블록 뽑아내기

       - try/catch 자체가 정상 동작과 오류 동작을 섞으며, 코드에 혼란을 불러일으키기 쉽기 때문에 별도 함수로 뽑아내는 것이 이롭다.
      - 모든 예외를 처리하게 하고, 별도의 로그 전달 메서드를 사용하면 이후 try 블록에서 호출되는 함수는 예외를 처리하지 않아도 되서 깔끔해진다.

  - ##### 오류 처리도 한 가지 작업이다.
    - 따라서 오류를 처리하는 함수는 오류만 처리해야 한다.
  - ##### Error.java 의존성 자석
    - 오류 코드를 정의하는 것은 의존성 자석 클래스를 만드는 것이다.
    - 오류 코드를 변경시 관련 클래스 모두가 재컴파일/재배치되어야 한다.
    - 새 오류 코드를 추가하기 보다는 기존 오류코드를 재사용하고,
    - 오류 코드 대신 예외를 사용하면 아예 재컴파일 없이 새 예외를 추가할 수도 있다.
    	- Exception 클래스 파생 예외를 새로이 추가하면 된다: OCP활용의 예시

- 반복하지 마라!
  - 중복은 코드 길이를 늘리며, 수정시 동시에 손 봐야 하는 부분도 늘려서 오류 발생 활률을 높인다.
  - 그런 이유로 AOP; Aspect Oriented Programming, COP; Component Oriented Programming, RDB에서의 정규 형식(정규화?) 등 프로그래밍 전반에서 중복을 줄이려는 노력이 나왔다.
- 구조적 프로그래밍
  - 데이크스트라의 구조적 프로그래밍 원칙 - 단일 입/출구 원칙(single entry-exit rule)
  	- 함수, 모든 블록에서 입구와 출구는 하나만 있어야 한다.
  	- return은 하나, continue와 break는 지양, goto는 결코 사용해선 안 된다.
  - 그러나 위의 규율은 매우 큰 크기의 함수에서만 통용될 규칙이다.
  	- 함수를 작게 만든다면 오히려 return, break, continue 사용이 의도를 표현하기 쉽다. 
  	- goto의 경우 큰 함수에서만 의미 있기에 피하자.
- 함수를 어떻게 짜죠?	
  - 글쓰기처럼 서툰 초안을 가다듬어 가면 서 좋은 함수로 만들어나가야 한다.
  - 그러나 초기에도 단위 테스트 케이스를 꼭 만들어야하며, 이후에도 이는 중요하다.
- 결론
  - 모든 시스템은 도메인 특화 언어(DSL; Domain Specific Language)로 만들어진다.
  - 함수는 이 언어에서 동사며
  - 클래스는 명사다.
  - 프로그래밍은 명확하게 규정된 함수와 클래스로 이야기를 풀어내는 것과 같다.

# 4장 주석
- 주석은 실패를 만회하기 위해 사용하는 것이다.
- 주석보다 코드로 의도를 표현하는 것이 더 좋다.
- 부정확한 주석은 없는 것만 못하다.
- 주석은 코드만큼 유지보수되기 힘들며, 오래 되었을수록 위험하다.



- #### 주석은 나쁜 코드를 보완하지 못한다.

- #### 코드로 의도를 표현하라!

- #### 좋은 주석
	- ##### 법적인 주석
		- 소스 파일 첫 머리에 들어가는 저작권 정보나 소유권 정보 등
		- 무작정 열거하지 말고 표준 라이선스나 외부 문서를 참조하는 것이 좋다.
	- ##### 정보를 제공하는 주석
		- 함수의 목적과 반환값을 설명 -> 함수명에 명시하는 것이 더 낫다
		- 정규표현식을 설명 -> 변환하는 별도의 클래스를 만들어 코드를 옮기는 것이 더 낫다
	- ##### 의도를 설명하는 주석
	- ##### 의미를 명료하게 밝히는 주석
		- 인수나 반환값이 표준 라이브러리나 변경하지 못하는 코드에 속한다면 유용
		- 그릇된 주석을 달더라도 검증이 힘들기에 위험한 주석이기도 하다. 주의할 것!
	- ##### 결과를 경고하는 주석
		- 특정 테스트케이스를 꺼야 하는 경우(JUnit4 이후로는 `@Ignore`로 가능)
		- 쓰레드에 안전하지 않은 경우를 경고해주는 경우
	- ##### TODO 주석
		- 필요하지만 당장 구현하기 어려운 업무
		- 하지만 주기적으로 정리하는 것이 좋다.
	- ##### 중요성을 강조하는 주석
	- ##### 공개 API에서 Javadocs
	
- #### 나쁜 주석
	- ##### 주절거리는 주석
	- ##### 같은 이야기를 중복하는 주석
	- ##### 오해할 여지가 있는 주석
	- ##### 의무적으로 다는 주석
	- ##### 이력을 기록하는 주석
		- 관리 프로그램이 할 일이다.
	- ##### 있으나 마나 한 주석
	- ##### 무서운 잡음
	- ##### 함수나 변수로 표현할 수 있다면 주석을 달지 마라
	- ##### 위치를 표시하는 주석
		- 가독성을 낮춤
		- 자주 사용하지 않아야 주의 환기 가능
	- ##### 닫는 괄호에 다는 주석
	- ##### 공로를 돌리거나 저자를 표시하는 주석
	- ##### 주석으로 처리한 코드
		- 관리 프로그램이 대신 기억한다.
	- ##### HTML 주석
	- ##### 전역 정보
		- 주석은 근처에 있는 코드만 기술해야 한다.
		- 대상 코드의 변화가 대상 주석의 변화와 함께 가는 수준이어야.
	- ##### 너무 많은 정보
	- ##### 모호한 관계
		- 주석에 설명이 필요하면 안 된다.
	- ##### 함수 헤더
		- 주석으로 헤더를 추가한 함수보다 짧고 명료한 함수가 더 좋다.
	- ##### 비공개 코드에서 Javadocs

# 5장 형식 맞추기
- #### 형식을 맞추는 목적
	- 코드 형식은 의사소통의 일환이다.
- #### 적절한 행 길이를 유지하라
	- 큰 파일보다 작은 파일이 이해하기 쉽다.
	- ##### 신문 기사처럼 작성하라
		- 첫 부분일수록 고차원 개념과 알고리즘을, 아래로 갈수록 세부 내역 및 저차원 함수를 다룬다.
	- ##### 개념은 빈 행으로 분리하라
		- 행 묶음이 각 개념을 나타내고, 빈 행이 그것을 구별하게 하라.
	- ##### 세로 밀집도
		- 서로 밀접한 행은 세로로 인접해야 한다.
	- ##### 수직 거리
		- 밀접한 개념은 세로로 가까이 있어야 한다. -> 가급적 같은 파일에 두자
		- protected 변수를 피해야 하는 이유다.
		- ###### 변수 선언
			- 변수는 사용 위치에 최대한 가까이 선언해야 한다.
			- 지역 변수는 함수 첫 부분에
			- 루프 제어 변수는 루프 문 내부에
			- 긴 함수에서는 블록 상단이나 루프 직전에 변수를 선언하기도
		- ###### 인스턴스 변수
			- 클래스 맨 처음에 선언
			- 변수 간에 서로 세로로 거리를 두지 않음
			- C++의 경우 클래스 마지막에 선언: 가위 규칙(scissors rule)
		- ####### 종속 함수
			- 호출 관계인 함수는 세로로 가까이 배치한다.
			- 호출 함수를 호출되는 함수보다 먼저 배치하는 것이 좋다.
			- 호출되는 함수 안에서 상수를 사용해야 하는 경우 상수를 호출되는 함수 안에서 사용하는 방법도 있지만, 호출하는 함수 쪽에서 인수로 보내는 방식이 더 좋은 경우가 있다(목록 5-5참조). 알아야 할 상수가 저차원 함수에 묻히지 않게 하기 위함이다.
- #### 개념적 유사성
	- 개념적 친화도가 높을수록 코드를 가까이 배치한다. 개념적 친화도가 높은 요인으로는:
		- 함수 호출, 변수 사용으로 인한 직접적인 종속성
		- 비슷한 동작을 수행하는 일련의 함수
			- assertTrue와 assertFalse
	- ##### 세로 순서
		- 고차원 함수가 먼저, 저차원 함수가 나중에
		- 중요 개념일수록 앞으로, 세부 사항은 뒤에서
- #### 가로 형식 맞추기
	- 