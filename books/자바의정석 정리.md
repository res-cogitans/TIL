﻿# 자바
- 자바로 작성한 프로그램은 운영체제에 독립적
- JVM은 운영체제 종속적
- 자바는 가비지컬렉터(garbage collector) 사용
- 자바 멀티 쓰레드의 스케줄링은 자바 인터프리터가 담당
- 동적 로딩(Dynamic Loading) 지원
	- 필요한 시점에 클래스를 로딩
	- 일부 클래스가 변경되어도 전체 애플리케이션을 컴파일하지 않아도 됨
- JVM(Java Virtual Machine)
	- 자바 애플리케이션은 JVM을 거쳐 OS로
	- 운영체제에 맞게 컴파일된 것이 아닌, 실행시에 해석(interpret) -> 속도 감소
	- JIT 컴파일러: 바이트코드(컴파일된 자바 코드)를 바로 하드웨어의 기계어로 치환해줌 -> 속도 향상
- JDK의 bin
	- javac.exe: 자바 컴파일러. 자바 소스코드 -> 바이트코드 컴파일
	- java.exe: 자바 인터프리터. 바이트코드를 해석하고 실행
	- javap: 역어셈블러. 컴파일된 클래스 파일은 원 소스로 변환
	- javadoc.exe: 소스파일 주석을 이용하여 자바 api 문서와 같은 형식의 문서 자동생성
	- jar.exe: 압축프로그램. 클래스파일 + 프로그램 실행 관련 파일을 하나의 jar파일로 압축하거나 해제
- JDK: 자바개발도구(Java Developmemt Kit): JRE + 개발에 필요한 실행 파일(javac.exe 등)
- JRE: 자바 실행 환경(Java Runtime Environment): JVM + 클래스 라이브러리(Java API)
- 소스파일의 이름은 public class의 이름과 일치해야 한다(한 파일에 다수의 클래스가 존재할 경우 유의) -> 하나의 소스파일에 두 개 이상의 public class 는 존재하지 않는다.
- 자바 프로그램의 실행 과정
	- 실행에 필요한 .class 파일 로드
	- 클래스파일 검사
	- 지정된 클래스에서 main 메서드 호출

# 변수
- 기본형(Primitive Type): booleanm char, byte, short, int, long, float, double
- 참조형(Reference Type): 메모리 주소(1byte단위)를 값으로 가짐
- 참조형 
- 자바는 메모리 연산이 불가, 실제 연산은 기본형 변수 사이에서 발생
- 메모리 주소 값은 기본적으로 4byte, JVM이 64bit면 8byte
- float의 정밀도는 7자리, double의 정밀도는 15자리
- 상수는 final 변수, 리터럴은 그 자체로 값을 의미하는 것
- 리터럴의 접미사 L, f, d(생략가능)
- 리터널의 접두사 0x,0X(16진수), 0(8진수)
- p나 e를 이용한 표현도 가능
### printf()
- 줄바꿈은 `\n` 대신 `%n`을 사용하자 - OS에 따라 다른 lfrn 문제 피해갈 수 있다.
- 지시자는 java.utill.Formatter 참조

## 진법
- ENIAC: 10진법으로 설계되었으나 전기회로의 전압 불안정으로 전압을 10단계로 나누는 데에는 한계가 있었음.
- EDVAC: 0과 1로 나누어 동작하게 설계
### 비트와 바이트
- bit: binary digit)
- byte: 8bit
- word: CPU가 한 번에 처리할 수 있는 단위
	- 32bit CPU에서는 1 word = 32bit(4byte)
	- 64bit CPU에서는 1 word = 64bit(8byte)

### 실수의 진법변환
- 10진 소수점 수를 2진 소수점수로 변환
	- 소수부가 0이 될 때까지 2를 계속 곱한다.
	- 정수부를 위에서 아래로 순서대로 적고 0.을 앞에 붙인다.
	- 정수부가 있을 경우 정수부를 따로 변환

### 2의 보수법
**n의 보수**
- 어떤 수에 대한 $n$의 보수는 $a$에 더했을 때 $n$이 되는 수이다. 어떤 수 $a$에 대한 $n$의 보수를 $k$라고 하면 
$$
k + a =n\\
k=n-a
$$
여기서 $a$와 $k$는 $n$의 보수의 관계에 있다.

**2의 보수**
- 10진수 2~10~는 2진수로는 10~2~다. 10~2~는 자리 올림이 발생하고 0이 되는 수로, 2의 보수 관계인 두 수를 더하면 (자리올림이 발생하고) 0이 된다.
- 예를 들어, 1011~2~와 0100~2~는 2의 보수 관계이다.

**음의 정수의 2진수 표현**
1. 음의 정수의 절대값을 2진수로 변환
2. 이 수의 2의 보수를 구함
예시) $-13_{10}$을 변환
$$
-13_{10} \rightarrow 13_{10} \rightarrow 1101_2 \rightarrow 0011_2
$$

### 2의 보수 구하기
1. 뺄셈을 이용
	- 예를 들어 $1001_2$의 2의 보수를 구하려면, $10000_2 - 1001_2$의 값($=0111$을 구하면 된다.
2. 1의 보수를 이용
$$
2의 보수 = 1의보수 +1
$$
	- 1의 보수 = 해당 수에서 0과 1을 반전시키기만 하면 된다.
	- 예를 들어 $1001_2$의 2의 보수는 1의 보수인 $0110_2 + 0001_2 = 0111_2$이다.

## 기본형(primitive type)
### 논리형 boolean
- 기본값은 false
- 크기는 1byte
- true와 false를 값으로 가짐, 대소문자 유의

### 문자형 char
- 정확히는 문자의 유니코드가 저장된다. ($C 언어$의 char)
- 문자 리터럴 대신 문자 유니코드를 직접 저장할 수 있음. 즉
	- `char textA = 'A';`는
	- `char textAUnicode = 65;`와 동일하다.
- 크기는 2 byte = 16bit 로, 0~65535(2^16^-1)범위 나타냄

**인코딩과 디코딩(encoding & decoding)**
- 인코딩: 'A'->65
- 디코딩: 65->'A'

**ASCII**
- American Standard Code for Information Interchange
- 7bit 부호
- 첫 32개 문자는 제어 문자(control character): 출력 불가
- 확장 ASCII
	- 1bit 추가하여 문자 추가 정의
	- ISO Latin 1 = ISO 8859-1
	- Code Page, CP: 지역에 따른 확장 아스키(한글 윈도우: CP 949, 영문 윈도우: CP 437
- Unicode
	- 초기에 모든 문자를 2byte(16bit)로 표현하려고 했으나 21bit로 확장
		- 추가된 문자들의 경우 char가 아니라 int를 사용해서 표현해야 한다.
	- 유니코드 문자 셋(character set): 유니코드에 포함시키려는 문자들의 집합
	- 유니코드 인코딩: 문자 셋에 번호를 붙인 것
		- UTF-8, UTF-16, UTF-32등 있음
		- 자바는 UTF-16 사용
		- UTF-8은 1~4byte의 가변 크기 문자 표현, UTF-16은 2byte 고정 크기 문자 표현
			- UTF-16은 고정 크기로 인해 다루기는 편하나 용량이 더 커지고, UTF-8은 그 반대
			- 전송 속도가 중요한 인터넷에서는 UTF-8 인코딩 문서가 늘고 있는 추세
		- 첫 128자는 아스키와 동일



# 08장 예외처리
- 에러의 분류
	- 컴파일 에러
	- 런타임 에러
		- 예외와 에러로 구분, 둘 다 Throwable을 상속
	- 논리적 에러

### 예외
- RuntimeException에 속한 클래스들과, 그렇지 않은 것들로 구별 가능
	- RuntimeException에 속하는 것들은 프로그래머의 실수로 발생하는 것들(unchecked exception)
		- 컴파일러가 예외처리를 확인하지 않음
	- 그 외의 Exception들은 사용자의 실수와 같은 외적 원인으로 발생하는 것들(checked exception)
		- 컴파일러가 예외처리를 확인

### 예외처리
- 예외를 처리하지 못할 경우
	- 프로그램은 비정상 종료되며
	- 처리하지 못한 예외(uncaught exception)은 JVM의 예외처리기(UncaughtExceptionHandler)가 받아서 예외 원인을 출력
- 예외 관련 메서드
	- `printStackTrace()`:  예외 발생 당시 Call Stack에 있던 메서드 정보, 예외 메시지를 출력
	- `getMessage()`: 예외 인스턴스에 저장된 메시지를 얻음
	- `printStackTrace(PrintStream s)`나 `printStackTrace(PrintWriter s)`를 사용시 파일에 저장 가능
- 멀티 catch 블럭
	```java
	try{
	    ...
	} catch (ExceptionA | ExceptionB e) {
	    e.printStackTrace();
	}
	```
	- 위와 같이 여러 종류의 예외를 '|' 기호 사용하여 연결, 코드를 줄일 수 있음
	- 위 경우 개별 예외에만 규정된 메서드만 호출 가능
		- ExceptionA에만 규정된 메서드 사용하고 싶을 경우 타입 검사 및 형변환이 필요
- throws: 메서드에 예외 선언
	- 이 메서드를 사용하는 경우 예외 처리할 것을 강제(예외처리를 떠맡김)
	- 단, RuntimeException의 경우 일반적으로 명시하지 않음
