# 모던 자바스크립트 Deep Dive

[TOC]

# 01장 프로그래밍

- 컴퓨팅적 사고(Computational thinking)
  - 문제 해결을 위해 컴퓨터에게 요구사항을 전달하는 것이 프로그래밍
  - 컴퓨터의 관점에서 문제를 사고(Computational thinking)해야

- 의미(Semantics)와 문법(Syntax)

  - 문법에 맞다고 해도 의미 없을 수 있음

  - 언어의 의미는 문맥에 있는 것이지 문법에 있는 것이 아님

    > Colorless green ideas sleep furiously.
    >
    > 노엄 촘스키의 예시

  - 프로그래밍 언어에서도 위는 통용

    > const number = 'string';

    - 문법적으로는 옳으나, 숫자라는 이름의 변수에 문자가 할당됨: 의미적으로 옳지 않음
      - 프로그래밍에서의 의미: **요구사항의 실현(문제의 해결)**



# 02장 자바스크립트란?

## 2.1 자바스크립트의 탄생

- 1995
  - 넷스케이프 커뮤니케이션즈(Netscape communications)에서 도입
  - 브라우저에서 동작하는 경량 프로그래밍 언어
  - 브렌던 아이크(Brendan Eich) 개발
- 1996
  - 브라우저인 넷스케이프 내비게이터(Netscape Navigator)2에 탑재
  - 모카(Mocha)로 명명(1996.03)
  - 라이브스크립트(LiveScript)로 명명(1996.09)
  - 자바스크립트(JavaScript)로 최종 명명(1996.12)



## 2.2 자바스크립트의 표준화

- 1996.08

  - JScript
    - 자바스크립트의 파생
    - 마이크로소프트가 IE 3.0에 탑재
  - JScript와 자바스크립트 간 표준화가 이루어지지 못함 -> **크로스 브라우징 이슈**

- 1996.11

  - ECMA 인터네셔널에 넷스케이프가 자바스크립트 표준화를 요청

- 1996.07: **ECMA-262**

  - 표준화된 자바스크립트 초판(ECMAScript 1) Specification 완성

  - 상표권으로 인해 ECMAScript로 명명

- 1999: ECMAScript 3(**ES3**)

- 2009: ECMAScript 5(**ES5**): HTML5와 함께 등장

- 2015: ESMAScript 6(**ES6**)
  - let/const 키워드, 화살표 함수, 클래스, 모듈 등 도입



### 버전 별 특징

| 버전 | 출시연도 | 특징                                                         |
| ---- | -------- | ------------------------------------------------------------ |
| ES1  | 1997     | 초판                                                         |
| ES2  | 1998     | ISO/IEC 16262 표준 규격                                      |
| ES3  | 1999     | 정규 표현식, try ... catch                                   |
| ES5  | 2009     | HTML5와 함께 등장<br />JSON, strict mode, 접근자 프로퍼티, 프로퍼티 어트리뷰트 제어,<br />향상된 배열 조작(forEach, map, filter, reduce, some, every) |
| ES6  | 2015     | let / const, 클래스, 화살표 함수, 템플릿 리터럴, 디스트럭처링 할당,<br />스프레드 문법, rest 파라미터, 심벌, 프로미스, Map / Set, 이터러블, for ... of,<br />제너레이터, Proxy, 모듈 import / export |
| ES7  | 2016     | 지수(**)연산자, Array.prototype.includes, String.prototype.includes |
| ES8  | 2017     | async/await, Object 정적 메서드(Object.values, Object.entries, Object.getOwnPropertyDescriptors) |
| ES9  | 2018     | Object rest / spread 프로퍼티, Promise.prototype.finally, async generator,<br />for await ... of |
| ES10 | 2019     | Object.fromEntries, Array.prototype.flat, Array.prototype.flatMap,<br />optional catch binding |
| ES11 | 2020     | String.prototype.matchAll, BigInt.globalThis, Promise.allSettled, null 병합 연산자,<br />옵셔널 체이닝 연산자, for ... in enumeration order |



## 2.3 자바스크립트 성장의 역사

### 2.3.1 Ajax

- **Ajax; Asynchronous JavaScript and XML**
  - 자바스크립트를 이용, 서버와 브라우저가 비동기 방식으로 데이터를 교환할 수 있는 통신
  - 1999년 XMLHttpRequest라는 이름으로 등장
- 필요한 부분만 렌더링할 수 있게 되었음
  - 화면 깜박임 해결
  - 성능 향상



### 2.3.2 jQuery

- **DOM; Document Object Model**을 손쉽게 제어
- 크로스 브라우징 이슈 다소 해결
- 2006년 등장



### 2.3.3 V8 자바스크립트 엔진

- 2008년 등장, 구글 제공
- 빠른 성능
  - 서버 로직을 클라이언트 로직으로 다수 이동시킴



### 2.3.4 Node.js

- 라이언 달(Ryan Dahl)이 2009년 발표
- V8 자바스크립트 엔진으로 빌드된 자바스크립트 런타임 환경(runtime environment)

- 브라우저 이외의 환경에서도 자바스크립트가 동작할 수 있음
  - 기존에는 브라우저의 자바스크립트 엔진에서만 동작
- 다수의 빌트인(built-in) API 제공
- 비동기 I/O 지원, 단일 스레드(single thread) 이벤트 루프 기반 동작
  - 요청 처리 성능이 좋음
  - 따라서 I/O가 빈번한 SPA; Single Page Application에 유용
  - CPU 사용률이 높은 애플리케이션에는 부적합



### 2.3.5 SPA 프레임워크

- 웹 어플리케이션 개발을 위한 프레임워크 등장
- CBD; Component Based Development 방법론에 의거한 SPA가 대중화되면서
  다음 프레임워크들이 등장:
  - Angular
  - React
  - Vue.js
  - Svelte



## 2.4 자바스크립트와 ECMAScript

- ECMAScript
  - 자바스크립트 표준 사양: ECMA-262를 뜻함
- 자바스크립트
  - ECMAScript + 브라우저가 별도 지원하는 클라이언트 사이드 Web API:
    - DOM, BOM, Canvas, XMLHttpRequest, fetch, requestAnimationFrame, SVG, Web storage, Web Component, Web Worker 등
- 클라이언트 사이드 Web API
  - 월드 와이드 웹 콘소시엄(W3C; World Wide Web Consortium)에서 관리
  - https://developer.mozilla.org/ko/ 에서 사양 확인



## 2.5 자바스크립트의 특징

- 웹 브라우저에서 동작하는 프로그래밍 언어
- 영향을 받은 언어들
  - 기본 문법: C, Java
  - 프로토타입: Self
  - 일급 함수: Scheme
- 인터프리터 언어
  - 모던 자바스크립트 엔진들은 처리 속도 개선을 이룸
    - 크롬 V8, 파이어폭스 SpiderMonkey, 사파리 JavaScriptCore, 마이크로소프트 엣지 Chakra
    - 모던 브라우저의 인터프리터들은 일부 소스코드를 컴파일하고 실행하기에 성능 개선
- 멀티 패러다임 프로그래밍 언어
  - 명령헝(imperative)
  - 함수형
  - 프로토타입 기반(prototype-based) 객체지향 프로그래밍



# 03장 자바스크립트 개발 환경과 실행 방법

## 3.1 자바스크립트 실행 환경

- 자바스크립트 실행 환경이면 **ECMAScript는 공통적으로 호환되지만, 다른 부분에서 차이가 있음**

- 자바스크립트 엔진을 내장한 환경들
  - 브라우저
    - 웹 페이지를 브라우저 화면에 렌더링하기 위함
    - DOM API 등 Client-side API들을 제공
      - DOM, BOM, Canvas, XMLHttpRequest, fetch, requestAnimationFrame, SVG, Web Storage, Web Component, Web Worker, ...
      - DOM API: HTML 요소를 파싱, 객체화한 것
  - Node.js
    - 브라우저 외부에서 자바스크립트 실행 환경을 제공
    - 파일 시스템 등 Node.js Host API들을 제공
      - 단 브라우저의 경우 Web API인 FileReader 객체를 이용하여 읽기는 가능
    - 기본적으로 DOM API를 제공하지 않지만 웹 크롤링을 위해 DOM 라이브러리를 이용하기도 함



## 3.2 웹 브라우저

- 구글 크롬 브라우저
  - ECMAScript 사양 준수
  - 가장 높은 시장 점유율
  - V8 자바스크립트 엔진: Node.js에서도 사용



### 3.2.1 개발자 도구

- 크롬에서 제공하는 DevTools

  - F12 or Ctrl + Shift + I

  - 주요 기능

    | 패널        | 설명                                                         |
    | ----------- | ------------------------------------------------------------ |
    | Elements    | 로딩된 웹 페이지의 DOM과 CSS를 편집, 렌더링된 뷰를 확인 가능<br />편집된 내용이 저장되지는 않음 |
    | Console     | 로딩된 웹 페이지의 에러 확인<br />console.log의 실행 결과 확인 |
    | Sources     | 로딩된 웹 페이지의 자바스크립트 코드 디버깅                  |
    | Network     | 로딩된 웹 페이지에 관한 네트워크 요청 정보와 성능 확인       |
    | Application | 웹 스토리지, 세션, 쿠키 확인, 실행                           |



### 3.2.2 콘솔

- REPL; Read Eval Print Loop: 입력 수행 출력 반복 환경으로도 사용 가능
  - 직접 자바스크립트 코드를 입력해 결과를 확인 가능



## 3.3 Node.js

- 프로젝트 규모가 커질 경우 프레임워크, 라이브러리, 툴들을 도입하기 위해
  Node.js + npm이 필요

- NPM; Node Package Manager
  - 자바스크립트 패키지 매니저
  - 패키지 저장소 + 관리를 위한 CLI 환경 제공

- Node.js REPL
  - `node`를 터미널에 입력하여 실행 가능
  - `node 파일명` 형태로 `.js` 파일 실행 가능



## 3.4 비주얼 스튜디오 코드

- 확장 플러그인
  - Code Runner
    - Ctrl + Alt + N으로 파일 실행 가능
  - Live Server
    - 수정사항을 바로 브라우저에 반영해주는 플러그인
    - 가상 서버를 가동



# 04장 변수

- 자바스크립트는 개발자의 직접적인 메모리 제어를 허용하지 않음
- 변수
  - 하나의 값을 저장하기 위해 확보한 메모리 공간
  - 메모리 공간을 식별하기 위해 붙인 이름

- 변수명은 식별자임
  - 식별자는 값 자체가 아니라 메모리 주소를 기억하고 있음
  - 변수, 함수, 클래스의 이름은 모두 식별자



## 4.3 변수 선언

- 변수 선언 방식
  - var
  - let(ES6 이후 도입)
  - const(ES6 이후 도입)
- var
  - 블록 레벨 스코프를 지원하지 않고, 함수 레벨 스코프를 지원
  - var는 deprecated 되진 않았지만, 권장되지는 않음

- 자바스크립트 엔진의 변수 선언

  - 변수명을 등록하고, 메모리 공간을 확보

  - **값이 할당되지 않은 메모리 공간은 비어 있지 않고,**
    **`undefined`가 암묵적 할당됨!!!**

  - 변수 선언의 단계

    - 선언 단계: 변수명을 등록, 엔진에 변수의 존재를 알림

    - 초기화 단계: 메모리 공간 확보, `undefined` 할당

  - `var` 사용한 변수 선언은 **선언과 초기화가 동시에 진행됨!**
  - `ReferenceError`: 선언하지 않은 식별자에 접근하려 하면 발생



## 4.4 변수 선언의 실행 시점과 변수 호이스팅

```javascript
console.log(score);		// undefined 출력됨

var score;				// 변수 선언
```

- **변수 선언보다 변수 참고가 먼저 일어나지만 `ReferenceError`가 발생하지 않음**
- **변수 선언은 런타임이 아니라 그 이전에 실행되기 때문임**
- 자바스크립트 엔진의 실행 순서
  - 소스코드 실행 준비
    - 소스코드 평가 과정: 모든 선언문을 먼저 실행
      - `var`, `let`, `function*`, `class`로 선언하는 모든 식별자들이 해당
  - 선언문을 제외한 소스코드를 한 줄씩 순차적으로 실행

- **변수 호이스팅(variable hoisting)**
  - 인터프리터가 변수 및 함수의 메모리 공간을 선언 전에 미리 할당하는 것
  - 선언들을 함수 유효 범위의 최상단에 선언함

- 주의사항
  - `var` 변수 및 함수의 선언만 해당, **할당은 해당되지 않음!**
  - **`let`, `const`, 함수표현식의 경우 호이스팅 발생하지 않음!**



## 4.5 값의 할당

- 자바스크립트의 경우 선언과 할당을 하나의 statement로 단축 표현해도
  선언과 할당을 2개의 statement로 나누어 실행한다.

  - 즉, 다음 둘의 실행은 동일하다.

    ```javascript
    var score;
    score = 80;
    ```

    ```javascript
    var score = 80;
    ```

- **주의! 실행 시점**

  - 변수 선언: 런타임 이전에 실행(`undefined`로 초기화)
  - 값의 할당: 런타임 실행

- 변수에 값을 할당할 때는 `undefined`가 할당된 메모리 공간을 지우고 그 자리에 할당하는 것이 아님
- **새로운 메모리 공간을 확보, 새 값을 할당함!**



## 4.6 값의 재할당

- `var`로 선언한 변수는 값을 재할당할 수 있음
  - 엄밀히 따지면 `var` 변수는 `undefined`로 초기화되기에 
    처음으로 값을 할당하는 것도 재할당임
  - 재할당할 경우 기존 메모리 공간을 건드리지 않고, 새 메모리 공간 확보하여 값 할당
  - 재할당으로 인해 필요 없어진 값은 GC에 의해 메모리에서 자동 해제됨
- `const` 키워드를 사용하면 재할당 불가: 상수 표현 가능
  - `const`는 상수 이외의 목적으로도 사용 가능



## 4.7 식별자 네이밍 규칙

- camelCase
  - 변수명, 함수명에 사용
- PascalCase
  - 생성자 함수, 클래스명



# 05장 표현식과 문

## 5.1 값

- 값(value)
  - 식(표현식, expression)이 평가되어 생성된 결과
  - 모든 값은 데이터 타입을 가지며 2진수 형태로 메모리에 저장됨



## 5.2 리터럴

- 리터럴(literal)

  - 사람이 이해할 수 있는 문자 or 약속된 기호를 이용해 값을 생성하는 표기법(notation)

  - 자바스크립트 엔진은 런타임에 리터럴을 평가해 값을 생성

  - 다양한 리터럴

    | 리터럴             | 예시                             | 비고                          |
    | ------------------ | -------------------------------- | ----------------------------- |
    | 정수 리터럴        | 100                              |                               |
    | 부동소수점 리터럴  | 10.5                             |                               |
    | 2진수 리터럴       | 0b01000001                       | 0b로 시작                     |
    | 8진수 리터럴       | 0o101                            | ES6에서 도입<br />prefix = 0o |
    | 16진수 리터럴      | 0x41                             | ES6에서 도입<br />prefix = 0x |
    | 문자열 리터럴      | 'Hello', "World"                 |                               |
    | 불리언 리터럴      | true, false                      |                               |
    | null 리터럴        | null                             |                               |
    | undefined 리터럴   | undefined                        |                               |
    | 객체 리터럴        | { name: 'Lee', address: 'Seoul'} |                               |
    | 배열 리터럴        | [ 1, 2, 3]                       |                               |
    | 함수 리터럴        | function() {}                    |                               |
    | 정규 표현식 리터럴 | /[A-Z]+g                         |                               |

    

## 5.3 표현식

- 표현식
  - 값으로 표현될 수 있는 statement
  - 표현식이 평가되면 새로운 값을 생성하거나 기존 값을 참조
  - 리터럴은 값으로 평가됨 -> 리터럴도 표현식

- 값으로 평가될 수 있는 문은 모두 표현식
- 표현식은 값처럼 사용할 수 있음



## 5.4 문

- 문(statement)
  - 프로그램을 구성하는 기본 단위
  - 최소 실행 단위
  - 여러 토큰(token)으로 구성
    - 토큰
      - 문법적인 의미를 가지며, 문법적으로 나눌 수 없는 코드의 기본 요소
      - 코드의 문법적 원자
      - 키워드, 식별자, 연산자, 리터럴, 세미콜론, 마침표 등
  - 명령문이라고도 부름
  - 선언문, 할당문, 조건문, 반복문 등으로 구별 가능



## 5.5 세미콜론과 세미콜론 자동 삽입 기능

- 세미콜론은 문의 종료를 나타냄

  - 자바스크립트 엔진은 세미콜론으로 문이 종료한 위치를 파악, 순차적으로 각각의 문을 실행
  - 코드 블록 뒤에는 세미콜른을 붙이지 않음
    - 코드 블록은 자체 종결성(self closing)을 갖기 때문

- 문의 끝에 붙이는 세미콜론은 Optional

  - 세미콜론 자동 삽입 기능(ASI; automatic semicolon insertion)

    - 자바스크립트 엔진은 ASI를 암묵적으로 수행하여
      소스코드 해석 시에 문의 끝으로 예측되는 지점에 자동적으로 세미콜론을 붙임

  - 개발자가 ASI 이해하지 못 하면 예상치 못한 작동이 발생

    ```javascript
    function foo() {
        return
        	{}
    }
    ```

    - 위의 경우 ASI의 해석은 return ; {}; 인데,
    - 개발자의 경우 return {};으로 예상하고 작성했을 수도 있음



## 5.6 표현식인 문과 표현식이 아닌 문

- 표현식은 문의 일부이거나, 그 자체로 문일 수 있음
  - 변수에 할당 가능한가로 구별 가능
- 표현식인 문
  - 값으로 평가되기에 변수에 할당 가능
- 표현식이 아닌 문
  - 값으로 평가되지 않기에 변수에 할당 불가

- 완료 값(completion value)
  - 표현식이 아닌 문의 경우 `undefined`를 출력하는데, 이를 완료 값이라 함
  - 표현식의 평가 결과가 아니기에 할당할 수도, 참조할 수도 없음



# 06장 데이터 타입

- ES6의 데이터 타입

  - 원시 타입

    | 타입      | 설명                                           |
    | --------- | ---------------------------------------------- |
    | number    | 정수와 실수 구별 없이 모두 숫자 타입임         |
    | String    | 문자열                                         |
    | boolean   | true, false                                    |
    | undefined | var로 선언된 변수에 암묵적 할당되는 값         |
    | null      | 값이 없음을 의도적으로 명시할 경우 사용하는 값 |
    | symbol    | ES6에서 추가됨                                 |

  - 객체 타입

    - 객체, 함수, 배열 등이 있음



## 6.1 숫자 타입

- 숫자타입의 값은 배정밀도 64bit 부동소수점 형식을 따름
  - 모든 수를 실수로 처리
  - 때문에 정수 값 끼리 나누더라도 실수 값이 나올 수 있음
  - 일괄적으로 10진수로 해석됨
    - 2진수, 8진수, 16진수로 표현해도 동일한 값으로 해석됨
- 특수 값
  - Infinity: 양의 무한
  - -Infinity: 음의 무한
  - NaN: 산술 연산 불가(not-a-number)
    - **NaN의 대소문자 구별에 주의하자!**



## 6.2 문자열 타입

- 0개 이상의 16비트 유니코드(UTF-16) 문자
- `''`, `""`, 혹은 백틱(``)으로 표현
  - 작은 따옴표(`''`)가 가장 일반적
  - 토큰과 구별하기 위해 따옴표로 감쌈
  - 자바와 달리 원시 타입임
  - 변경 불가능한 값(immutable value)



## 6.3 템플릿 리터럴

- 템플릿 리터럴(template literal)
  - ES6부터 도입된 문자열 표기법
  - 다양한 기능 제공
    - 멀티라인 문자열(multi-line string)
    - 표현식 삽입(expression interpolation)
    - 태그드 템플릿(tagged template)
  - 일반 문자열로 변환되어 처리
  - 백틱(``)으로 표현됨



### 6.3.1 멀티라인 문자열

- 일반 문자열의 경우 개행이 허용되지 않음

  - 이스케이프 시퀀스(escape sequence) 사용해야 표현 가능

    | 이스케이프 시퀀스 | 의미                                                         |
    | ----------------- | ------------------------------------------------------------ |
    | \0                | null                                                         |
    | \b                | 백스페이스                                                   |
    | \f                | 폼 피드(Form Feed): 프린터로 출력할 경우<br />다음 페이지의 시작 지점으로 이동 |
    | \n                | 개행(LF; Line Feed): 다음 행으로 이동                        |
    | \r                | 개행(CR; Carriage Return): 커서를 처음으로 이동              |
    | \t                | 탭(수평)                                                     |
    | \v                | 탭(수직)                                                     |
    | \uXXXX            | 유니코                                                       |
    | `\'`              | 작은 따옴표                                                  |
    | `\"`              | 큰따옴표                                                     |
    | `\\`              | 백슬래시                                                     |

- 템플릿 리터럴 내에서는 
  이스케이프 시퀀스를 사용하지 않고도 줄바꿈 허용되며 공백도 그대로 적용



## 6.3.2 표현식 삽입

- 문자열은 `+` 문자열 연산자로 연결 가능

  - 피연산자 중 하나 이상이 문자열일 경우 문자열 연산자로 동작

- 표현식 삽입을 이용한 문자열 삽입

  ```javascript
  var first = "Hanbin";
  var last = "Lee";
  
  console.log(`My name is ${first} ${last}`);
  ```

  - `${}`로 표현식을 감싸서 사용
    - 평가 결과가 문자열이 아니라도 문자열로 타입 강제 변환됨
  - 템플릿 리터럴 내에서만 가능



## 6.5 undefined 타입

- 자바스크립트 엔진이 `var` 변수를 초기화할 때 사용하는 값
  - 초기화되지 않은 변수임을 알 수 있음
  - 개발자가 직접 할당할 경우 위와 같은 구별이 어렵기에
    직접 할당하지 말자
  - 값이 없음을 명시하고 싶다면 `null`을 할당해야



## 6.6 null 타입

- 대소문자 구별에 주의
- 값의 의도적 부재(intentional absence)를 표현할 때 사용됨
  - GC 수행됨



## 6.7 심벌 타입

- 불변 원시 타입 값

- `Symbol` 함수를 호출해 생성

  - 외부에 노출되지 않으며 중복되지 않는 유일무이한 값

- 예제

  ```javascript
  // 심벌 값 생성
  var key = Symbol('key');
  console.log(typeof key); //symbol 출력됨
  
  // 객체 생성
  var obj = {};
  
  // 이름이 충돌할 위험이 없는 유일무이한 값인 심벌을 프로퍼티 키로 사용
  obj[key] = 'value';
  console.log(obj[key]);	// value 출력됨
  ```



## 6.8 객체 타입

- 자바스크립트는 객체 기반 언어
- 원시 자료형 외에는 모두 객체임



## 6.9 데이터 타입의 필요성

### 6.9.1 데이터 타입에 의한 메모리 공간의 확보와 참조

- 자바스크립트 엔진은 데이터 타입에 따라 정해진 크기의 메모리 공간을 확보
- **ECMAScript 사양에서 문자열 / 숫자 타입 외의 경우, 데이터 타입의 크기를 명시적 규정하지는 않음**
  - 숫자, 문자열을 제외한 경우 자료형 크기는 **자바스크립트 엔진의 구현에 따라 달라질 수 있음**
  - 숫자의 경우 배정밀도 64비트 부동소수점 = 8바이트 이기에 숫자 값의 크기는 8바이트

- 값을 참조할 때도 한 번에 읽어 들이는 메모리 셀의 개수(바이트 수)를 알아야 하기에 자료형이 필요
- 심벌 테이블
  - 컴파일러 / 인터프리터는 심벌 테이블 자료 구조를 통해
    식별자를 키로 바인딩된 값의 메모리 주소, 데이터 타입, 스코프 등을 관리



### 6.9.2 데이터 타입에 의한 값의 해석

- 같은 값이라도 문자열로 읽을 것인지, 숫자로 읽을 것인지 등을 판단하기 위함



## 6.10 동적 타이핑

### 6.10.1 동적 타입 언어와 정적 타입 언어

- 자바는 동적 타입 언어

- 정적 타입 언어(static/strong type language)
  - 명시적 타입 선언(explicitg type declaration)
    - 변수를 선언할 때 변수 타입을 사전에 선언
  - 변수의 타입을 변경할 수 없음
  - 선언한 타입에 맞는 값만 할당 가능
  - 컴파일 시점에 타입 체크를 수행(해당 타입에 맞는 값을 할당했는가)
    - 타입 체크를 통과하지 못할 경우 실행 자체가 불가
- 자바스크립트의 경우: 동적 타입 언어(dynamic/weak type language)
  - 변수를 선언할 때 타입을 선언하지 않음
  - `typeof` 연산자를 사용해서 확인해보면
    - 같은 변수의 타입이라도 다른 값을 할당하면 계속 다른 타입을 가짐
    - `typeof` 연산자는, 엄밀히 말해서 **변수의 데이터 타입이 아니라 **
      **변수에 할당된 값의 데이터 타입을 반환함**
  - 값을 할당하는 시점에 변수의 타입이 동적으로 결정됨
    - 타입 추론(type inference)
  - 변수의 타입은 언제든지 변경 가능
    - 동적 타이핑(dynamic typing)
  - **요약**
    - **변수는 타입을 갖지 않지만, 값은 타입을 갖는다**
    - **변수에 할당된 값에 의해 변수의 타입이 동적으로 결정된다**



### 6.10.2 동적 타입 언어와 변수

- 동적 타입 언어는 편리하지만 단점도 있음
  - 값을 확인하기 전에는 타입을 확신할 수 없음
  - 유연성은 높지만 신뢰성은 낮음
    - 개발자의 의도와 상관 없이 자바스크립트 엔진에 의해 타입이 자동 변환되기도 함,
      위와 같은 신뢰성 하락을 더 심화
- 변수 사용시 주의사항
  - 변수는 필요할 때만 제한적으로 사용해야
    - 동적 타입 언어의 변수는 타입 오류를 발생시킬 확률이 높기에
      변수의 수 자체를 최소화해야 함
  - 변수의 유효 범위(스코프)를 좁게 만들어야
  - 전역 변수를 최대한 자제
    - 의도치 않은 값 변경될 수 있으며
    - 전체 코드에 영향을 주기 쉬움
    - 프로그램의 복잡성을 높이며, 흐름 추적이 어렵게 되며, 오류 원인을 찾기 힘들게 함
  - 변수보다는 상수를 사용
  - 변수명을 적절하게 명명



# 07장 연산자

- 연산자(operator)
  - 하나 이상의 표현식을 대상으로 연산을 수행해 하나의 값을 만듦
  - 피연산자(operand)
    - 값으로 평가될 수 있는 표현식
    - 연산자 표현식(피연산자  + 연산자)도 포함



## 7.1 산술 연산자

- 산술 연산자(arithmatic operator)
- 연산이 불가능한 경우 `NaN`을 반환



### 7.1.1 이항 산술 연산자

- binary arithmatic operator
  - 두 개의 피연산자
  - 피연산자의 값을 변경하는 부수 효과(side effect)가 없음

- +, -, *, /, %



### 7.1.2 단항 산술 연산자

- unary arithmatic operator

| 단항 산술 연산자 | 의미                                                         | 부수효과 |
| ---------------- | ------------------------------------------------------------ | -------- |
| ++               | 증가                                                         | O        |
| --               | 감소                                                         | X        |
| +                | 효과 없음<br />숫자 타입이 아닌 피연산자에 적용될 경우 숫자 타입으로 변환하여 반환 | X        |
| -                | 양수 <-> 음수 변환<br />+ 연산자처럼 숫자 타입으로 변환, 반환 | X        |

- `++`/`--`연산자는 부수 효과가 있음
  - 전위(prefix), 후위(postfix) 증가/감소 연산자 구별



### 7.1.3 문자열 연결 연산자

- `+` 연산자

  - 피연산자 중 하나 이상이 문자열인 경우 문자열 연결 연산자로 동작

- 암묵적 타입 변환(implicit conversion) / 타입 강제 변환(typo coersion)

  ```javascript
  // true는 1로 변환됨
  1 + true;	// -> 2
  // false는 0으로 변환됨
  1 + false;	// -> 1
  // null은 0으로 변환됨
  1 + null;	// -> 1
  // undefined는 숫자로 타입 변환되지 않음
  1 + undefined;	// -> NaN
  +undefined;		// -> NaN
  ```



## 7.2 할당 연산자

- assignment operator
  - 우항 피연산자 평가 결과를 좌항 변수에 할당
  - 좌항 값이 변하는 부수 효과 있음
    - =, +=, -=, *=, /=, %=

- **할당문은 표현식인 문이다**

  - 할당된 값으로 평가된다.

    ```javascript
    var x;
    
    console.log(x = 10);	// 10 출력됨!
    ```

    

## 7.3 비교 연산자

- 비교 결과를 불리언 값으로 반환



### 7.3.1 동등/일치 비교 연산자

- 동등 비교(loose equality) / 일치 비교(strict equality) 구별 필요

| 비교 연산자 | 의미        | 사례    | 설명                       | 부수 효과 |
| ----------- | ----------- | ------- | -------------------------- | --------- |
| ==          | 동등 비교   | x == y  | x와 y의 값이 같음          | X         |
| ===         | 일치 비교   | x === y | x와 y의 값과 타입이 같음   | X         |
| !=          | 부동등 비교 | x != y  | x와 y의 값이 다름          | X         |
| !==         | 불일치 비교 | x !== y | x와 y의 값이나 타입이 다름 | X         |

- 동등 비교의 겨웅 암묵적 타입 변환을 이용해서 타입을 일치시키고 비교

- **동등 비교 연산자의 복잡성**

  ```javascript
  '0' == '';			// -> false
  0 == '';			// -> true
  0 == '0';			// -> true
  false == 'false'	// -> false
  false == '0';		// -> true
  false == null;		// -> false
  false == undefined	// -> false
  ```

  - 가능하면 동등 비교 연산자를 쓰지 말자!
  - 일치 비교 연산자(===) 쓰자!

- **일치 비교 연산자와 NaN**

  ```javascript
  NaN == NaN;	// -> false;
  ```

  - 위의 경우 `false` 리턴하기에 `NaN` 검사하려면
    빌트인 함수 `Number.isNaN`을 사용하자.

- 양의 0과 음의 0

  ```javascript
  0 === -0;	// -> true
  0 == -0		// -> true
  ```

- `Object.is`

  - `0`과 `NaN`과 같은 평가가 복잡한 문제를 다음과 같이 평가함

    ```javascript
    -0 === +0;				// -> true
    Object.is(-0, +0);		// -> false
    
    NaN === NaN;			// -> false;
    Object.is(NaN, NaN);	// -> true
    ```

  - 이 외의 부분은 일치 연산자와 동일하게 작동



## 7.4 삼항 조건 연산자

- 값으로 평가할 수 있는 표현식인 문임



## 7.5 논리 연산자

- 단축 평가에 유의!

  ```javascript
  'Cat' && 'Dog';	// -> Dog
  ```



## 7.6 쉼표 연산자

- 왼쪽 피연산자부터 차례대로 피연산자를 평가, 마지막 피연산자 평가 결과를 반환

```javascript
var x, y, z;
x = 1, y = 2, z = 3;	// -> 3
```



## 7.8 typeof 연산자

- 반환 타입: 문자열
  - "string"
  - "number"
    - `NaN`도 "number" 반환
  - "boolean"
  - "undefined"
  - "Symbol"
  - "object"
  - "function"

- `null` 반환하지 않음
  - `null`을 평가하면 `object`를 반환
  - 버그지만, 레거시 호환성 때문에 수정되지 않음

- 선언하지 않은 식별자를 검사 시에는 `undefined` 반환



## 7.9 지수 연산자

- Since ES7
- `base ** exponent` 형태
- 이전에는 `Math.pow(base, exponent)` 사용
- 음수를 `base`로 다루려면 괄호로 묶어서 사용



## 7.10 그 외의 연산자

| 연산자     | 개요                                                    |
| ---------- | ------------------------------------------------------- |
| ?.         | 옵셔널 체이닝 연산자                                    |
| ??         | null 병합 연산자                                        |
| delete     | 프로퍼티 삭제                                           |
| new        | 생성자 함수 호출할 때 사용하여 인스턴스 생성            |
| instanceof | 좌변 객체가 우변 생성자 함수와 연결된 인스턴스인지 판별 |
| in         | 프로퍼티 존재 확인                                      |



## 7.11 연산자의 부수 효과

- 부수 효과가 있는 연산자
  - 할당 연산자 `=`
  - 증/감 연산자 `++`/`--`
  - `delete` 연산자



# 08장 제어문

- 제어문(control flow statement)

- 함수형 프로그래밍 기법에서는
  - `forEach`, `map`, `filter`, `reduce` 등의 고차 함수를 이용하여
    제어문 특유의 복잡성을 해결하려고 함



## 8.1 블록문

- 0개 이상의 문을 중괄호로 묶은 것
- (코드) 블록
- 하나의 실행 단위로 취급됨



## 8.2 조건문

- `if ... else`문
  - if문의 조건식이 불리언 값이 아닌 값으로 평가될 경우 암묵적 타입 변환이 발생
- `switch` 문
  - fall through: case 문에 break를 사용하지 않을 경우, 나중 문도 실행되어 버림



## 8.3 반복문

- 반복문의 대체
  - 배열 순회 시에 `forEach` 메서드
  - 객체 프로퍼티 열거 시에는 `for ... in` 문
  - 이터러블(Since ES6) 순회 가능한 `for ... of` 문
- `for` 문
- `while` 문
  - `do ... while` 문



## 8.4 break 문

- `break`문이 사용 가능한 곳

  - 레이블 문(label statement)

    - 식별자가 붙은 문

      ```javascript
      // foo라는 레이블 식별자가 붙은 레이블 문
      foo: console.log('foo');
      ```

      ```javascript
      foo: {
          console.log(1);
          break foo;
          console.log(2);
      }
      ```

      - case문과 default 문도 사실은 label 문
      - `break label` 형태로도 사용 가능
      - 중첩 반복문의 외부를 탈출할 때는 유용하지만
        가독성이 낮고 오류 발생 가능성이 높기에 사용을 자제해야

  - 반복문

  - switch 코드 블록

- `continue`문



# 09장 타입 변환과 단축 평가

## 9.1 타입 변환이란?

- 타입 변환은 기존 값을 변경하는 것은 아님
  - 원시 값은 immutable value이기에 변경 불가
  - 타입 변환은 새 원시 값을 생성하는 것임
  - **자바스크립트 엔진은 암묵적 타입 변환이 발생하면
    새로운 값을 만들어 한 번 사용하고 버림**



## 9.3 암묵적 타입 변환

- 문자열 연산자 `+`

- 숫자 타입 변환 시에는 prefix `+`

  - 단 객체, 빈 배열이 아닌 배열, `undefined`의 경우 `NaN`

- 불리언 타입의 경우

  - `Falsy` 값
    - `false`
    - `undefined`
    - `null`
    - `0, -0`
    - `NaN`
    - `''`(빈 문자열)

  - `Falsy` 값 외의 모든 값은 `Truthy` 값



## 9.3 명시적 타입 변환

- 문자열로 변환

  - (`new` 연산자 없이) `String` 생성자 함수 호출 `String(toConverted)`

  - `Object.prototype.toString` `toConverted.toString()`
  - 문자열 연결 연산자(`+`)

- 숫자로 변환
  - (`new` 연산자 없이) `Number`생성자 함수 호출
  - (문자열만 가능) `parseInt`, `parseFloat`
  - `+` 단항 산술 연산자
  - `*` 산술 연산자
- 불리언으로 변환
  - (`new` 연산자 없이) `Boolean` 생성자 함수 호출
  - 부정 논리 연산자(`!`) 두 번 사용하기



## 9.4 단축 평가

### 9.4.1 논리 연산자를 사용한 단축 평가

- `||`이나 `&&` 연산자 표현식의 평가 결과는 불리언 값이 아닐 수 있음

  - 두 개의 피연산자 중 어느 한쪽으로 평가됨

- 논리곱(`&&`)

  - 좌항에서 우항으로 평가가 진행

    ```javascript
    'Cat' && 'Dog'	// -> 'Dog'
    ```

    - AND 연산의 경우 앞이 Truthy일 경우 뒤의 값에 따라 결정되니까

- 논리합(`||`)

  - 좌항에서 우항으로 평가 진행

    ```javascript
    'Cat' || 'Dog'	// -> 'Cat'
    ```

- 단축 평가(short-ccircuit evaluation)

  - 논리곱, 논리합 연산자는 피연산자를 타입 변환하지 않고 그대로 반환

  - 경우에 따라 `if`문을 대체 가능

    ```javascript
    var done = true;
    var message = '';
    
    if (done) message = '완료';
    
    // 상단의 if문과 동일 동작
    message = done && '완료';
    ```

- 단축 평가의 활용

  - `null`이나 `undefined` 체크

    ```java
    var elem = null;
    
    var value = elem && elem.value;
    ```

  - 매개변수 기본값 설정

    ```javascript
    function getStringLength(str) {
        str = str || '';
        return str.length;
    }
    
    // Since ES6
    function getStringLength(str = '') {
        return str.length;
    }
    ```

    

### 9.4.2 옵셔널 체이닝 연산자

- Since ES11(ECMAScript2020)

- 옵셔널 체이닝 연산자(optional chaining operator) `?.`

  - 좌항 피연산자가 `null` 혹은 `undefined`이면 `undefined` 반환
  - 아닐 경우 우항의 프로퍼티 참조를 이어감

- 용례

  ```javascript
  var elem = null;
  
  var value = elem?.value;
  console.log(value);	//undefined
  ```

  - 이전에는 단축평가를 이용했음

    ```javascript
    var elem = null;
    
    var value = elem && elem.value;
    console.log(value);	//null
    ```

- 논리 연산자 `&&`과의 비교
  - 논리 연산자 `&&`의 경우
    - 좌항 피연산자가 Falsy값이면 좌항 피연산자를 그대로 반환
    - 번외: `0`이나 `''`은 객체로 평가하기도 하기에 주의
  - 옵셔널 체이닝 연산자의 경우
    - 좌항 피연산자가 Falsy 값이라도
      `null`이나 `undefined`가 아닐 경우 우항의 프로퍼티 참조를 이어감



### 9.4.3 null 병합 연산자

- nullish coalescing 연산자 `??`
  - 좌항 피연산자가 `null`이거나 `undefined`인 경우 우항 피연산자를 반환
    그렇지 않을 경우 좌항 피연산자를 반환
  - 기본값 설정용으로 유용
- 논리 연산자 `||`과의 비교
  - 논리 연산자 단축평가를 이용할 경우
    - Falsy값 중에 유효한 값이 있을 경우 문제 발생 가능
    - 만약 0이나 ''을 의미 있는 값으로 쓴다면?
  - `null` 병합 연산자의 경우
    - `null`과 `undefined`만 체크, 아닐 경우 좌항 그대로 반환



## 10장 객체 리터럴

## 10.1 객체란?

- 자바스크립트는 객체 기반 프로그래밍 언어

  - 원시 값을 제외한 나머지 값은 모두 객체
    - 원시 타입 값은 불변값이지만
    - 객체 타입 값은 가변(mutable value)
  - 객체는 0개 이상의 프로퍼티로 구성된 집합

- 프로퍼티

  - 프로퍼티는 키와 값으로 구성

    ```java
    var person = {
        name: 'Lee',
        age: 20
    }
    ```

    - `name`, `age`는 키, `'Lee'`, `20`은 값

  - 모든 값은 프로퍼티 값이 될 수 있음
    - 자바스크립트의 함수는 일급 객체이기에 값으로 취급 가능
    - 프로퍼티 값인 함수는 메서드라 부름



## 10.2 객체 리터럴에 의한 객체 생성

- **자바스크립트의 객체 생성 방식**
  - **객체 리터럴** - 가장 일반적!
  - `Object` 생성자 함수
  - 생성자 함수
  - `Object.create` 메서드
  - 클래스(ES6)

- 객체 리터럴을 이용한 생성 방식

  ```javascript
  var person = {
      name: 'Lee',
      sayHello: function() {
          console.log('Hello! My name is ${this.name}');
      }
  };	//세미콜론 주의!
  
  console.log(typeof person);		//object
  console.log(person);	//{name: 'Lee', sayHello: f}
  
  var empty = {};	//빈 객체
  ```

  - 빈 중괄호의 경우 빈 객체를 생성
  - 객체 리터럴의 중괄호는 코드 블록이 아니고,
    값으로 평가받는 표현식이기에 세미콜론을 붙이자!

- 자바스크립트의 객체의 경우
  - 객체 생성 이후에 프로퍼티를 동적으로 추가할 수도 있음



## 10.3 프로퍼티

- 프로퍼티 키

  - 빈 문자열을 포함한 모든 문자열 혹은 심벌 값

  - 일반적으로는 문자열 사용

  - 주의사항

    - 문자열이기에 따옴표 붙여야 함
    - 단, 자바스크립트 식별자 네이밍 규칙을 따를 경우 생략 가능
    - 식별자 네이밍 규칙을 따르지 않은 프로퍼티 키의 따옴표를 생략할 경우
      표현식으로 해석함(ex. `last-name`은 `-`연산자가 있는 표현식으로 해석됨)
    - 빈 문자열도 사용 가능하지만 부적합
    - 문자열이나 심벌 이외의 값을 사용해도 암묵적 타입 변환 발생
    - 예약어도 사용 가능하지만 권장하지 않음
    - 이미 존재하는 프로퍼티 키를 중복 선언할 경우 덮어쓰게 됨
      - 에러 발생하지 않기에 주의!

  - **프로퍼티 키를 동적으로 생성할 수도 있음**

    - 단 이 경우에는 프로퍼티 키로 사용할 표현식을 대괄호로 묶어야 함

      ```javascript
      var obj = {};
      var key = 'hello';
      
      // Since ES5
      obj[key] = 'world';
      
      // Since ES6
      var obj = {[key]: 'world'};
      ```



## 10.4 메서드

- 자바스크립트의 함수는 일급 객체이기에 프로퍼티 값으로 사용 가능
- 메서드 내부에서 사용하는 `this`는 객체 자신을 가리키는 참조변수



## 10.5 프로퍼티 접근

- 방식
  - 마침표 표기법(dot notation)
    - `person.name`
  - 대괄호 표기법(bracket notation)
    - `person['name']`
    - 이 경우 반드시 프로퍼티 키를 따옴표로 감싼 문자열로 전달
      - 그렇지 않을 경우 식별자로 해석됨
    - **네이밍 규칙을 준수하지 않은 프로퍼티 키의 경우 반드시 대괄호 표기법을 사용해야**
- 존재하지 않는 프로퍼티에 접근할 경우 `undefined`를 반환
  - `ReferenceError` 발생 안 함



## 10.8 프로퍼티 삭제

- `delete` 연산자
  - 객체의 프로퍼티를 삭제 `delete person.age;`
  - 존재하지 않는 프로퍼티를 삭제 시도할 경우 에러 없이 무시됨



## 10.9 ES6에서 추가된 객체 리터럴의 확장 기능

### 10.9.1 프로퍼티 축약 표현

- 기존의 프로퍼티 표현 방식

  ```javascript
  var x = 1, y = 2;
  
  var obj ={
      x: x,
      y: y
  };
  ```

  

- 프로퍼티 축약 표현

  - Since ES6

    ```javascript
    let x = 1, y = 2;
    
    const obj = {x, y};
    ```

  - 프로퍼티 값으로 변수를 사용하는 경우
    변수명과 프로퍼티 키가 동일할 때, 프로퍼티 키를 생략(properly shorthand) 가능

    - 프로퍼티 키는 변수명으로 자동생성



### 10.9.2 계산된 프로퍼티 이름

- 기존 방식

  ```javascript
  var prefix = 'prop';
  var i = 0;
  
  var obj = {};
  
  obj[prefix  + '-' + ++i] = i;
  ...
  ```

- computed property name

  - Since ES6

  - 문자열 / 문자열로 변환 가능한 표현식을 이용해
    프로퍼티 키를 동적 생성

  - 프로퍼티 키로 사용할 표현식은 대괄호로 묶어야 함

    ```java
    const prefix = 'prop';
    let i = 0;
    
    const obj = {
        [`${prefix}-${++i}`]: i,
        [`${prefix}-${++i}`]: i,
        [`${prefix}-${++i}`]: i,
    };
    
    console.log(obj);	//{prop-1: 1, prop-2: 2, ...}
    ```



### 10.9.3 메서드 축약 표현

- 기존 방식

  ```javascript
  var obj {
      ...
      sayHello: function() {
          ...
      }
  };
  ```

- 메서드 축약 표현

  - Since ES6

  - `function` 키워드 생략 가능

  - **단, 이 방식으로 동작한 메서드는 프로퍼티에 할당한 함수와 다르게 동작함!!!**

    ```javascript
    const obj = {
        ...
        sayHello() {
            ...
        }
    };
    ```

