# 단위 테스트(Unit Testing)

- ## 생산성과 품질을 위한 단위 테스트 원칙과 패턴

- ### 블라디미르 코리코프 지음, 임준혁 옮김

## 목차

[TOC]

# Part 1. 더 큰 그림

# 1장 단위 테스트의 목표

## 1.1 단위 테스트 현황

- 단위 테스트는 이제 선택이 아닌 필수
- 단위 테스트는 단순히 테스트를 작성하는 것보다 큰 범주의 일임
  - 단순히 테스트 프레임워크나 Mocking library를 배우는, 기술적인 부분만 있는 게 아님
  - 최대한 이득을 얻도록 노력해야 함
    - 테스트에 드는 노력을 최소화하고
    - 테스트로 인한 이득을 최대화해야 함
- 어떤 단위 테스트가 좋은지 고민해야 함



## 1.2 단위 테스트의 목표

- **단위 테스트의 부수 효과**: 더 나은 설계를 도움

  - 단위 테스트는 더 나은 설계로 이어짐

    - 하지만 이는 부정 지표로서만 의미 있음
    - 즉, 단위 테스트하기 쉬운 코드라고 해서 좋은 코드는 아닐 수 있음

  - 단위 테스트하기 용이함과 좋은 코드의 상관관계
    $$
    모든\,코드조각\,c에\,대하여,\,단위테스트하기\,쉬움Ec,\,좋은\,코드임\,Gc라\,할\,때\\
    \quad \neg Ec \rightarrow \neg Gc\,이다. \,즉\,Gc \rightarrow Ec\,이다.\\
    \quad 역은\,성립하지\,않는다.
    $$

  - 단위 테스트하기 어려운 경우 주 원인은 강한 결합도(tight coupling)

- **단위 테스트의 주 목표: 소프트웨어 프로젝트의 지속 가능한 성장을 가능하게 하는 것**
  
  - **지속성과 확장성을 기반으로, 장기적으로 개발 속도를 유지하게 함**
  - **소프트웨어 엔트로피(software entropy)**
    - 프로젝트 진행에 따라 개발 속도가 빠르게 감소하는 현상
    - 소프트웨어에서는 품질을 떨어트리는 코드 형태로 엔트로피가 나타남
  - 테스트는 소프트웨어 엔트로피를 낮출 수 있음
    - 코드 베이스의 신뢰성을 지키고 코드의 안정화를 도움
    - 기능 확장 및 리팩토링에 도움
      - 테스트가 안전망 역할을 수행, 회귀에 대한 보험을 제공
        - 회귀(regression)
          - 코드 수정 등 사건 이후에 기능이 잘못 작동하는 것
          - 소프트웨어 버그와 동의어
      - 기능 도입, 리팩토링 이후에도 기존 기능이 잘 작동하는 지 확인 가능
  - 단점: **초반에 노력이 필요**
    - 하지만, 프로젝트 후반의 소프트웨어 엔트로피를 줄여주기에 장기적으로는 비용적 이득



### 1.2.1 좋은 테스트와 좋지 않은 테스트를 가르는 요인

- 잘못 만든 테스트와 개발 속도
  - 잘못 만든 테스트도 초반에는 침체 단계에 도달하는 것을 막아줌
  - 하지만 거시적인 관점에서는 큰 차이가 없음: 결국에는 침체 단계에 도달하게 됨

- 테스트에도 품질이 있음
  - 안 좋은 테스트는
    - 잘못된 경고를 발생시키며
    - 회귀 오류를 알아내는 데 도움이 되지 않음
    - 유지보수가 어렵고 느림
  - **테스트의 품질을 신경 쓰지 않고 무작정 많은 테스트를 만드는 것은 부적절**
- 테스트의 유지 비용
  - 다음 활동들에 필요한 시간에 따라 결정됨
    - 기반 코드를 리팩토링할 때 테스트도 리팩토링
    - 각 코드 변경 시 테스트 실행
    - 테스트가 잘못된 경고를 발생시킬 때 처리
    - 기반 코드 동작을 이해하기 위해 테스트를 읽는 데 시간을 투자
- **지속 가능한 프로젝트 성장을 위해 고품질 테스트에만 집중하라**
  - **테스트의 가치(품질)와 유지 비용 모두를 고려하여 좋은 테스트를 판별**
  - 고품질 테스트만 테스트 스위트에 남기자

- 제품 코드 대 테스트 코드
  - 테스트가 많다고 꼭 좋은 것이 아님
  - 테스트 코드도 코드임
  - 때문에 테스트 코드에도 책임이 따름



## 1.3 테스트 스위트 품질 측정을 위한 커버리지 지표

- **커버리지 지표**

  - 테스트 스위트가 소스 코드를 얼마나 실행하는지 백분율로 표시

  - 높을 수록 좋지만, 높다고 테스트 스위트의 품질이 좋음을 보장하지는 않음
    - 이 경우에도 **커버리지 지표는 좋은 코드의 필요조건이다. 역은 성립하지 않는다.**



### 1.3.1 코드 커버리지 지표에 대한 이해

- 코드 커버리지(code coverage) = 테스트 커버리지(test coverage)
  $$
  코드\,커버리지\,= \,{실행\,코드\,라인\,수\over 전체\,라인\,수}
  $$

  - 한계
    - 단순 라인 커버 비율만 측정하기에,
      **커버리지는 오르지만, 실질적인 검증 효과는 동일할 수 있음**



### 1.3.2 분기 커버리지 지표에 대한 이해

- **분기 커버리지**(branch coverage)

  - 코드 커버리지보다 더 정확

  - 라인 기반이 아니라 `if`, `switch` 등 제어문에 중점을 둠
    $$
    분기\,커버리지\,= \,{통과\,분기\over 전체\,분기\,수}
    $$



### 1.3.3 커버리지 지표에 대한 문제점

- 테스트 스위트의 품질 결정에 있어 **커버리지 지표는 한계가 있다.**
  - 테스트 대상 시스템의 **모든 가능 결과를 검증한다는 보장이 없음**
  - **외부 라이브러리** 코드 경로를 고려 가능한 지표가 없음



### 1.3.4 특정 커버리지 숫자를 목표로 하기

- **커버리지 지표는, 지표일 뿐 목표가 되어선 안 된다!**
- 커버리지 지표는 좋은 부정 지표지만 나쁜 긍정 지표다.



## 1.4 무엇이 성공적인 테스트 스위트를 만드는가?

- **스위트 내 각 테스트를 하나씩 따로 평가하는 것**이 가장 신뢰성 있는 품질 측정법
  - 이러한 평가는 자동화된 방식으로 확인이 불가하며
  - 개인의 판단에 따름
- 성공적인 테스트 스위트의 특징
  - 개발 주기에 통합돼 있음
  - 코드베이스에서 가장 중요한 부분만을 대상으로 함
  - 최소 유지비로 최대 가치를 끌어냄



### 1.4.1 개발 주기에 통합돼 있음

- 테스트는 끊임 없이 수행되어야 함
  - 모든 테스트는 개발 주기에 포함되어야 하며,
  - 이상적으로는 코드가 변경될 때마다 실행되어야 함



### 1.4.2 코드베이스에서 가장 중요한 부분만을 대상으로 함

- 검증되는 코드의 질에 따라 테스트의 정도가 달라져야 함
  - 중요한 부분일수록 테스트 작성에 노력을 기울이고
  - 덜 중요한 부분은 간략하게 혹은 간접적으로 검증하라.
- 각 부분에 따른 가치
  - **비즈니스 로직(도메인 모델): 일반적으로 가장 중요**
  - 그 외
    - 인프라 코드
    - DB, 서드파티 시스템 등 외부 서비스 및 종속성
    - 모든 것을 하나로 묶는 코드
- **이를 위해서 도메인 모델을 다른 중요하지 않은 부분과 분리해야 한다!**



### 1.4.3 최소 유지비로 최대 가치를 끌어냄

- 단위 테스트에서 가장 어려운 부분
- **가치가 유지비를 상회하는 테스트만 스위트에 유지하라!** 이를 위해,
  - 가치 있는 테스트를 식별,
    - 식별 기준이 필요(frame of reference)
  - 가치 있는 테스트를 작성해야.
    - 코드 설계 기술



# 2장 단위 테스트란 무엇인가

## 2.1 '단위 테스트'의 정의

- **단위 테스트의 주요 속성**
  - 작은 코드 조각(단위)을 검증하고,
  - 빠르게 수행하고,
  - **격리된 방식으로 처리하는 자동화된 테스트: 논쟁점!**

- 단위 테스트에 대한 두 해석 & 접근방식

  - **고전파(classical school)**
    - 단위 테스트와 TDD에 원론적으로 접근하는 방식
    - 디트로이트파(Detroit school), 고전주의자(classicist)
    - 켄트 백의 "테스트 주도 개발"이 대표적

  - **런던파(London school)**
    - 런던의 프로그래밍 커뮤니티에서 시작
    - 목 주의자(mockist): 멸칭
    - 스티브 프리먼(Steve Freeman), 냇 프라이스(Nat Pryce)의 "Growing Object-Oriented Software, Guided by Tests"
      - 번역서: [테스트 주도 개발로 배우는 객체 지향 설계와 실천](https://www.aladin.co.kr/shop/wproduct.aspx?ItemId=27490110)
      - 두 저자는 jMock과 nMock 라이브러리 개발

- **단위 테스트의 세 번째 속성 중 "격리(isolation)"에 대한 해석이 두 학파의 근원적 차이다.**
  - 이 책의 저자는 고전파를 선호



### 2.1.1 격리 문제에 대한 런던파의 접근

- 런던파의 격리 해석

  - 테스트 대상 시스템을 협력자(collaborator)에게서 격리하는 것

  - 하나의 클래스가 다른 클래스에 의존하면 의존성을 모두 테스트 대역(test double)로 대체해야 함

  - 도식화

    - **Before**

      ```mermaid
      flowchart LR
      	SUT(테스트 대상 시스템) --> D1((의존성1))
      	SUT(테스트 대상 시스템) --> D2((의존성2))
      ```

    - **After**

      ```mermaid
      flowchart LR
      	SUT(테스트 대상 시스템) --> D1((테스트 대역1))
      	SUT(테스트 대상 시스템) --> D2((테스트 대역2))
      	style D1 stroke:#f66,stroke-width:2px, stroke-dasharray: 5 5
      	style D2 stroke:#f66,stroke-width:2px, stroke-dasharray: 5 5
      ```

- **장점**

  - 테스트 실패 시 잘못된 부분을 확실히 알 수 있음: **무조건 테스트 대상 시스템이 잘못된 것**
  - 객체 그래프를 분할할 수 있음: **복잡한 의존성을 가진 코드베이스를 테스트하기 좋음**
    - 테스트 대역이 없을 경우 테스트용 의존성들을 구성해야 함
    - 의존성들은 또 다른 의존성을 갖기에 
      **의존성들을 모두 대체하는 것은 사실상 객체 그래프를 다시 형성하는 것과 같음**
  - 테스트 범위를 간단하게 설정할 수 있음
    - 예시: 하나의 클래스 당 하나의 단위 테스트를 작성하는 방식



#### 고전파 테스트와 런던파 테스트 예제

- **AAA 패턴**

  - Arrange(준비) - Act(실행) - Assert(검증)

- **고전파 테스트**

  - 코드

    ```java
    @DisplayName("고전파 테스트")
    class ClassicStyleTest {
    
    	@Test
    	void 재고가_충분하면_구매는_성공함() {
    		//준비
    		StoreImpl store = new StoreImpl();
    		store.addInventory(SHAMPOO, 10);
    		Customer customer = new Customer();
    
    		//실행
    		boolean success = customer.purchase(store, SHAMPOO, 5);
    
    		//검증
    		assertThat(success).isTrue();
    		assertThat(store.getInventory(SHAMPOO)).isEqualTo(5);	//상점 제품 다섯 개 감소
    	}
    
    	@Test
    	void 재고가_부족하면_구매는_실패함() {
    		//준비
    		StoreImpl store = new StoreImpl();
    		store.addInventory(SHAMPOO, 10);
    		Customer customer = new Customer();
    
    		//실행
    		boolean success = customer.purchase(store, SHAMPOO, 15);
    
    		//검증
    		assertThat(success).isFalse();
    		assertThat(store.getInventory(SHAMPOO)).isEqualTo(10);	//상점 제품 수량 변화 없음
    	}
    }
    ```

  - 해설

    - 준비
      - 테스트 대상 시스템(SUT; System Under Test)로 `Customer`
      - 협력자로 `Store`
      - **협력자가 필요한 이유**
        - 테스트 메서드 컴파일을 위해 매개변수로 `Store` 인스턴스를 필요로 함
        - 결과적으로 상점 제품 수량이 감소할 수 있기에 검증 필요
    - **협력자를 대체하지 않고, 운영용 인스턴스를 사용함!**
      - `Customer`에 이상이 없더라도 `Store` 문제로 단위 테스트 실패 가능
        -> **격리되어 있지 않음!**

- **런던파 테스트**

  - 코드

    ```java
    @DisplayName("런던파 테스트")
    class LondonStyleTest {
    
    	@Test
    	void 재고가_충분하면_구매는_성공함() {
    		//준비
    		Store storeMock = mock(Store.class);
    		when(storeMock.hasEnoughInventory(SHAMPOO, 5)).thenReturn(true);
    		Customer customer = new Customer();
    
    		//실행
    		boolean success = customer.purchase(storeMock, SHAMPOO, 5);
    
    		//검증
    		assertThat(success).isTrue();
    		verify(storeMock, times(1)).removeInventory(SHAMPOO, 5);
    	}
    
    	@Test
    	void 재고가_부족하면_구매는_실패함() {
    		//준비
    		Store storeMock = mock(Store.class);
    		when(storeMock.hasEnoughInventory(SHAMPOO, 5)).thenReturn(false);
    		Customer customer = new Customer();
    
    		//실행
    		boolean success = customer.purchase(storeMock, SHAMPOO, 5);
    
    		//검증
    		assertThat(success).isFalse();
    		verify(storeMock, times(0)).removeInventory(SHAMPOO, 5);
    	}
    }
    ```

  - 해설

    - *Store` 인스턴스를 테스트 대역의 일종인 **목으로 대체**
    - **구체 클래스인 StoreImpl이 아닌 인터페이스인 Store을 목으로 만들었음!**
      - 구체 클래스도 목으로 만들 수는 있지만, **안티 패턴임!**

- **비교**

  - 고전파 테스트에서는 **상태를 검증**함

  - 런던파 테스트에서는 **상호 작용(호출)을 검증**함



### 2.1.2 격리 문제에 대한 고전파의 접근

- 런던파의 테스트 대역 처리가 갖는 함의: **무엇이 단위 테스트의 대상인가?**
  - 각각의 클래스를 격리해야 한다면 테스트 단위(Unit)는
    **단일 클래스이거나 해당 클래스 내의 메서드임**
  - 격리 방식으로 인해 이 이상 큰 단위가 될 수는 없음
  - 경우에 따라 조금씩 다를 수는 있지만 기본 지침은 **한 번에 한 클래스를 테스트!**
- **격리에 대한 고전파의 해석**
  - 단위 테스트간의 격리를 의미
  - 테스트 실행 순서 따위가 테스트 결과에 영향을 끼치지 않게끔 격리
  - **공유 의존성이 없다면, 클래스 여럿을 묶어서 테스트해도 된다!**
  - **함의: 테스트 대역을 남용하지 말자!**
    - 테스트 대역은 테스트 간 의존성을 해소하는 데 사용됨



#### 의존성

##### 의존성의 종류

- **공유 의존성(shared dependency)**
  - 테스트 간 공유되고, 서로 결과에 영향을 끼칠 수 있는 수단을 제공하는 의존성
  - 대표적인 예
    - 정적 가변 필드(static mutable field)
    - DB
  
- **비공개 의존성(private dependency)**
  - 공유하지 않는 의존성
  
- **프로세스 외부 의존성(out-of-process-dependency)**
  - 애플리케이션 실행 프로세스 외부에서 실행되는 의존성
  - 아직 메모리에 없는 데이터에 대한 프록시
  - 일반적으로는 공유 의존성이지만 예외 있음
    - DB는 프로세스 외부 && 공유 의존성
    - (테스트 각각에 대해 실행된) 도커 컨테이너는 외부 && 비공개 의존성
    - 프로세스 외부의 불변 의존성은 공유 의존성이 아님
      - 어차피 수정 불가능한 값이기에 서로 영향을 끼칠 수 없기 때문

- 주의: 공유 의존성은 테스트 대상 클래스(단위) 간이 아니라 단위 테스트 간에 공유됨

  - 싱글톤 의존성은 단일하지만, 각 테스트 마다 새 인스턴스를 생성하기에 비공개 의존성

  - 설정 클래스는 단일하고, 모든 인스턴스에서 사용하지만 각 테스트에서 새 인스턴스를 만들 수 있음



##### 휘발성 의존성

- 휘발성 의존성(volatile dependency): 둘 중 하나 이상의 속성을 가짐
  - developer’s machine by default에 더하여 런타임 환경의 설치 및 구성을 요구
    - DB, API 서비스
    - 추가 설정 필요, 기본 설치되어 있지 않음
  - 비결정적 동작(nondeterministic behavior)를 포함
    - 난수 생성기, 날짜, 시간 반환 클래스 등
    - 멱등하지 않은 동작
- 휘발성 의존성과 공유 의존성의 비교 사례
  - DB의존성: 공유 의존성 && 휘발성 의존성
  - 파일 시스템
    - 모든 개발자 머신에 설치됨 && 결정적으로 작용: 휘발성 아님
    - 단위 테스트가 서로를 방해할 수 있기에 공유 의존성
  - 난수 생성기
    - 비결정적: 휘발성
    - 테스트 별 별도 인스턴스 제공 가능: 비공개 의존성



##### 공유 의존성은 테스트 실행 속도를 늦춘다

- 공유 의존성은 대부분의 경우 실행 프로세스 외부에 있고
- 비공개 의존성의 대부분은 프로세스 외부로 벗어나지 않기에
- 공유 의존성의 대한 호출은 일반적으로 비공개 의존성에 대한 호출보다 오래 걸림
- **단위 테스트는 빠르게 실행되어야 하기에 공유 의존성을 가진 테스트는 통합 테스트 영역으로 넘어감**



## 2.2 단위 테스트의 런던파와 고전파

| 분류       | 격리 주체   | 단위의 크기                  | 테스트 대역 사용 대상      |
| ---------- | ----------- | ---------------------------- | -------------------------- |
| **런던파** | 단위        | 단일 클래스                  | 불변 의존성 외 모든 의존성 |
| **고전파** | 단위 테스트 | 단일 클래스 또는 클래스 세트 | 공유 의존성                |



### 2.2.1 고전파와 런던파가 의존성을 다루는 방법

- **값 객체와 테스트 대역**

  - 각각의 identity가 존재하지 않고 내용에 의해서만 식별되는 것들
  - enum, 상수값(5, 7 등)
  - 런던파도 값 객체는 테스트 대역으로 대체하지 않음

- 교체 대상 도표

  ```mermaid
  flowchart RL
  subgraph 협력자 런던파에서 교체 대상
  
  	direction BT
  	subgraph 고전파에서 교체 대상
  		A((공유 의존성))
  	end
  	
  	B((변경 가능한 의존성))
  end
  C((의존성)) --> A
  C-->D
  D(비공개 의존성)-->B
  E((값 객체))
  D-->E
  ```

- **협력자와 의존성 비교**
  
  - 협력자(collaborator)
    - 공유하거나 변경 가능한 의존성
  - 의존성
    - 값 / 값 객체의 경우 의존성이지만 협력자는 아님



## 2.3 고전파와 런던파의 비교

- **런던파의 장점**
  - 입자성(granularity): 테스트가 세밀하기에(fine-grained) 한 번에 한 클래스만 확인
  - 클래스 그래프가 커져도 테스트하기 쉬움: 모든 협력자가 테스트 대역으로 대체되기 때문
  - 테스트가 실패한 경우 어떤 기능이 실패했는지 확실하게 알 수 있음

- 그럼에도 저자는 고전파를 선호함
  - 취약성(fragility) 때문
  - 목을 사용하는 테스트는 고전적인 테스트에 비해 불안정한 경향이 있음



### 2.3.1 한 번에 한 클래스만 테스트하기

- 클래스를 단위로 간주하게 되는 이유
  - 객체 지향 프로그래밍에서 클래스는 보통 원자 빌딩 블록(atomic building block)으로 간주됨
  - 이 성향이 이어져서 테스트에서도 클래스를 단위로 간주하게 된 것
- **좋은 코드 입자성을 위해서는 클래스가 아니라 동작 단위를 검증해야 함**
  - 코드 단위가 아니라 동작 단위를 검증하는 것이 좋은 테스트
  - 비즈니스적으로 의미 있다고 인식되는 것을 검증해야
  - 구현이 아니라, 동작을 검증해야 함!



### 2.3.2 상호 연결된 클래스의 큰 그래프를 단위 테스트하기

- 의존성 그래프가 복잡하게 얽혀 있을 경우 목은 도움이 된다.
- 하지만 **복잡한 클래스 그래프가 되지 않게 만드는 데 집중하는 것이 더 중요하다.**
  - 목을 이용한 방식은 이 중요 문제를 숨기기만 한다는 문제가 있다.



### 2.3.3 버그 위치 정확히 찾아내기

- 런던파 테스트의 경우 SUT에 문제가 있는 테스트만 테스트 실패한다.
- 반면 고전파 테스트의 경우 버그의 정확한 위치를 찾아내는 작업이 필요하다.
  - 테스트를 정기적으로 실행하는 것은 버그의 원인을 바로 찾게 해준다.
    - 이 경우 마지막으로 가한 수정이 문제임을 명확하게 알기 때문이다.
  - 특정 버그가 테스트 하나만이 아니라 여러 테스트에 영향을 끼친다면 버그를 발생시킨 코드 조각이 가치 있음을 알려주기도 한다.



### 2.3.4 고전파와 런던파 사이의 다른 차이점

- **테스트 주도 개발(TDD; Test-Driven-Development)를 통한 시스템 설계 방식**
  - 테스트 주도 개발 프로세스
    - 실패 케이스 작성
    - 테스트가 통과하게 만듦
    - 코드를 리팩토링
  - **런던파**
    - 하향식 TDD(단위 테스트 방식의 귀결)
    - 상위 레벨 테스트부터 시작
    - 목을 이용하여 협력자 차단하면서 하나씩 집중적으로 만들 수 있음
  - **고전파**
    - 일반적으로는 상향식 TDD
    - 도메인 모델을 시작, 계층을 쌓아가면서 최종 사용자가 사용할 수 있는 결과물까지 진행

- **과도한 명세(over-specification) 문제**
  - 테스트가 SUT의 구현 세부 사항에 결합되는가
  - 런던파 테스트의 경우 고전파에 비해 구현 세부사항에 상대적으로 더 결합되는 성향이 있음



## 2.4 두 분파의 통합 테스트

- **통합 테스트의 정의에 대한 런던파의 견해**
  - 실제 협력자 객체를 사용하는 모든 테스트는 통합 테스트
- **통합 테스트의 정의에 대한 고전파의 견해**
  - 단위 테스트의 정의: 고전파 해석
    - 작은 코드 조각: **단일 동작 단위를 검증**
    - 빠르게 수행
    - 격리된 방식: **다른 테스트와 별도로** 처리
  - 통합 테스트는 단위 테스트의 정의 중 하나를 충족하지 않는 테스트



### 2.4.1 통합 테스트의 일부인 엔드 투 엔드 테스트

- **엔드 투 엔드 테스트(end-to-end  test)**

  - 통합 테스트의 일부
  - 모든 외부 애플리케이션을 포함한 시스템을 최종 사용자 관점에서 검증 
  - 차이점: 엔드 투 엔드 테스트는 일반적으로 의존성을 더 많이 포함

- 비교

  - 일반적으로 통합 테스트는 프로세스 외부 의존성을 **1~2개만** 가지고 작동

  - 엔드 투 엔드 테스트는 프로세스 외부 의존성을 **전부 또는 대다수** 갖고 작동

- UI; User Interface 테스트 == GUI; Graphic User Interface 테스트 == 기능 테스트(functional test)
- 엔드 투 엔드 테스트는 가장 비용이 많이 들기 때문에 빌드 프로세스 후반에 실행함이 좋음
  - 개발자 머신이 아닌 빌드 서버에서만 실행할 수도 있음
  - 엔드 투 엔드 테스트에서도 처리하지 못한 외부 의존성이 존재할 수 있음
  - 통합 테스트와 엔드 투 엔드 테스트의 경계가 흐리며
  - 테스트 대역을 사용할 필요성이 있음을 기억해야



# 3장 단위 테스트 구조

## 3.1 단위 테스트를 구성하는 방법

### 3.1.1 AAA 패턴 사용

- 3A 패턴이라고도 한다.

- 준비(Arrange) - 실행(Act), - 검증(Assert)의 세 단계

- 예시 코드

  ```java
  class CalculatorTest {
  
  	@Test
  	void sumOfTwoNumbers() {
  		//Arrange
  		double first = 10;
  		double second = 20;
  		Calculator calculator = new Calculator();
  
  		//Act
  		double result = calculator.sum(first, second);
  
  		//Assert
  		assertThat(result).isEqualTo(30);
  	}
  }
  ```

- **일관성이 장점**

  - 모든 테스트가 단순하고 균일한 구조
  - 테스트 스위트의 유지 보수 비용을 줄임

- **단계**

  - 준비: SUT와 의존성을 원하는 상태로 세팅
  - 실행: SUT에서 메서드 호출, 의존성 전달, (필요시) 반환값 얻음
  - 검증: 결과를 검증
    - 결과는 반환값, SUT/협력자의 최종 상태, SUT가 협력자에 호출한 메서드 등이 될 수 있음

- Given-When-Then 패턴

  - 동일한 패턴이지만, 프로그래머가 아닌 사람들이 읽기에 더 좋음
  - 비기술자들과 공유하는 테스트에 더 적합

- 순서

  - 일반적으로는 준비 단계부터 시작하고, 그게 효과적이지만
  - TDD에서는 검증 단계부터 윤곽을 그리며 시작



### 3.1.2 여러 개의 준비, 실행, 검증 구절 피하기

- 예시

  ```mermaid
  flowchart LR
  A([테스트 준비]) --> B([실행]) --> C([검증]) --> D([좀 더 실행]) --> E([다시 검증])
  ```

  - 이런 경우, 더 이상 단위 테스트가 아니라 통합 테스트다. -> 리팩토링하라

- 실행이 하나여야

  - 테스트가 단위 테스트임을 보장
  - 간단, 빠름, 이해하기 쉬움

- **통합 테스트의 경우**

  - 여러 개의 통합 테스트를 하나로 묶어서 속도 향상을 꾀할 수 있음
  - 하지만 이 경우에도
    - 통합 테스트에만 해당하며
    - 그 중에서도 속도가 이미 느리고, 더 느리게 만들고 싶지 않은 경우에나 사용



### 3.1.3 테스트 내 if문 피하기

- 역시 안티 패턴
- 테스트가 한 번에 너무 많은 것을 검증한다는 의미
- 가독성 떨어트리며 유지 비용만 증가



### 3.1.4 각 구절은 얼마나 커야 하는가?

- 준비(Arrange)
  - 일반적으로, 준비 구절이 가장 큼
  - 하지만 준비 구절이 지나치게 클 경우 다음 두 패턴을 이용:
    - 오브젝트 마더(Object Mother)
    - 테스트 데이터 빌더(Test Data Builder)
- 실행(Act)
  - 일반적으로 코드 한 줄
  - 두 줄 이상일 경우 SUT의 공개 API에 문제가 있는지 고민
  - 불변 위반(invariant violation)
    - 단일 작업을 수행하는데 둘 이상의 메서드 호출이 필요하다는 점이 문제
      - 하나의 작업 단위가 분리되서 호출될 경우 불변 위반이 발생
      - 불변 위반을 막기 위해서 캡슐화가 필요
      - DB에서 이런 (트랜잭션) 문제가 발생하는 경우 문제가 매우 심각
    - 캡슐화를 항상 지켜서 이 문제를 예방하자
  - 단, 유틸리티나 인프라 코드의 경우 실행 구절을 하나로 해야 한다는 지침에서 상대적으로 자유로움



### 3.1.5 검증 구절에는 검증문이 얼마나 있어야 할까

- **반드시 테스트 당 하나의 검증을 가질 필요는 없다!**
  - 이는 최소 코드 단위를 테스트하려는 성향과 맞물린 것
  - **단위 테스트는 동작을 검증해야 하기에,**
    **하나의 동작으로 야기될 수 있는 결과가 여럿일 경우, 그 모든 결과를 그 테스트에서 검증해야.**
- **그러나 검증 구절이 지나치게 큰 경우에는 문제**
  - 제품 코드의 추상화가 누락되었는지 의심
  - (오버라이딩한) `equals()` 등 사용하여 검증문 길이 줄일 수 있음



### 3.1.6 종료 단계는 어떤가

- 준비-실행-검증-종료 구조
  - 종료 단계를 따로 구분하기도 함
  - 테스트에 의해 작성된 파일 삭제, DB 커넥션 종료 등을 위해 사용 가능
- 일반적으로 별도의 메서드로 추출, 재사용됨
- AAA 패턴에서는 포함하지 않는 단계
- **대부분의 단위 테스트는 종료가 불필요**
  - 단위 테스트는 외부 프로세스에 종속적이지 않기에 side-effect 처리는 불필요
  - **종료는 통합 테스트 시에 필요**



### 3.1.7 테스트 대상 시스템 구별하기

- SUT는 호출하고자 하는 동작에 대한 진입점을 제공
  - SUT를 수많은 의존성과 구별하면 테스트 대상을 쉽게 찾을 수 있음
  - 테스트 내에서 `sut`라고 명명하면 편함



### 3.1.8 준비, 실행, 검증 주석 제거하기

- 테스트의 어느 부분이 준비, 실행, 검증 단계에 해당하는가를 구별하기 쉽게 만들자.
- 방법
  - 주석을 이용한 구별 `//준비, //실행, //검증`
  - 빈 줄을 통한 구별: 각 단계 사이에 빈 줄을 넣어서 구별

- 빈 줄을 사용할 일이 없음 && AAA 패턴을 따름 -> 빈 줄을 이용한 구별
  - 그 외의 경우 주석을 이용한 구별



## 3.2 xUnit 프레임워크 살펴보기

- 테스트 생명주기에 따른 관리
  - 자바의 경우 `@BeforeEach`, `@AfterEach` 이용
- xUnit은 `[Fact]`로 테스트임을 표기
  - 테스트는 문제 영역에 대한 원자적 사실이며 테스트 통과는 그 사실이 참이라는 것을 의미함
  - 위와 같은 방식으로 테스트를 바라봐야함
    - 테스트는 제품 코드의 기능을 나열하는 것이 아니라
    - 비즈니스 담당자에게도 의미가 있는 명세가 되어야 함



## 3.3 테스트 간 테스트 픽스쳐 재사용

- **테스트 픽스쳐(Fixture)**
  - 테스트 실행 대상 객체
    - SUT로 저장되는 인수
    - 테스트 실행 전의 고정 상태로 유지되기에, 동일한 결과를 반환함
      (픽스쳐라는 이름의 이유)
  - NUnit 프레임워크의 [TestFixture]
    - 테스트가 포함된 클래스를 표시하는 특성
- 재사용 방법
  - **공통 부분에서 테스트 픽스처 초기화(`@BeforeEach`): 사용하지 말자!**
    - 테스트 코드의 양을 크게 줄일 수 있지만
    - **테스트 간 결합도를 높이며 테스트 가독성을 떨어트림** 
  - **`private` 팩토리 메서드 사용하기: 추천**



### 3.3.1 테스트 간의 높은 결합도는 안티 패턴이다

- 테스트의 공통 준비 로직(`@BeforeEach`) 수정하면 모든 테스트에 영향을 미침
- 테스트의 수정이 다른 테스트에 영향을 끼치게 됨
  - **테스트의 독립적인 수정을 무너트림**
  - **테스트의 독립적인 실행을 무너트린 것이 아님, 구별 필요!**
    - 독립적인 실행을 무너트리는 것은 테스트 간 공유 상태를 사용하는 것



### 3.3.2 테스트 가독성을 떨어뜨리는 생성자 사용

- 해당 테스트만 보고 흐름을 파악하기가 힘들어짐



### 3.3.3 더 나은 테스트 픽스처 재사용법

- 공통부분 코드는 비공개 팩토리 메서드로 추출

- 테스트 코드를 짧게 하면서도 해당 테스트 진행상황에 대한 전체적인 맥락을 유지할 수 있음

- 비공개 팩토리 메서드를 잘 일반화하면 가독성을 높이며, 재사용도 쉬움

  ```java
  Store store = createStoreWithInventory(Product.SHAMPOO, 10);
  ```

- 픽스처 사용법의 예외
  - 모든 테스트 혹은 대부분의 테스트에 사용되는 경우 위에서 추천하지 않은 `@BeforeEach` 방식을 사용할 수도 있음.
  - DB와 작동하는 통합 테스트가 여기에 종종 해당됨
  - ? DB 초기화 코드에 대한 이해 필요 ?



## 3.4 단위 테스트 명명법

- 부적절한 케이스
  - `[테스트 대상 메서드]_[시나리오]_[예상 결과]`
    - `Sum_TwoNumbers_ReturnsSum()`
  - 동작이 아니라 세부 구현에 집중하게 만듦
  - 간단한 영어 구문으로 표현해야
    - `Sum_of_two_numbers()`



### 3.4.1 단위 테스트 명명 지침

- 엄격한 명명 정책을 따르지 않음
  - 설명 능력을 위해 자유로운 표현을 허용하는 편이 더 이로움
- 비개발자들에게 시나리오를 설명하는 것처럼 지음
  - 도메인 전문가나 비즈니스 전문가들이 좋은 예
- 단어를 `_`UnderScore로 구별
  - 긴 이름일수록 가독성에 도움이 됨



### 3.4.2 예제: 지침에 따른 테스트 이름 변경

- 테스트 이름에 들어간 클래스명의 경우, 동작 진입점 정도로 생각하자.
  - 반드시 해당 클래스에만 제한되는 테스트가 되어야 하는 것은 아님
- 테스트명에 SUT의 메서드명을 포함하지 말자
  - 구현이 아니라 동작을 테스트해야하기 때문
  - 유틸리티 클래스의 경우는 예외



## 3.5 매개변수화된 테스트 리팩터링하기

- 매개변수화된 테스트(parameterized test)
- `@ParameterizedTest`
- 테스트 코드의 양을 많이 줄임
- 테스트 메서드가 나타내는 사실을 파악하기 어려워짐: 매개변수가 많을수록 심화
  - 절충안으로, 긍정적인 TC, 부정적인 TC를 별개로 나눠서 사용하면 명확해짐

- **테스트 코드의 양과 가독성은 반비례한다**
  - 매개변수만으로 TC를 판단할 수 있다면 성공/실패 케이스를 모두 함께 묶고
  - 그게 아니면 성공 TC만을 따로 빼내고
  - 복잡한 동작의 경우 매개변수화된 테스트를 사용하지 말자



### 3.5.1 매개변수화된 테스트를 위한 데이터 생성

- 간단한 경우 `@CsvSource`
- 매개변수 타입이 다양/복잡한 경우 `@MethodSource` 사용



## 3.6 검증문 라이브러리를 통한 테스트 가독성 향상

- 주어-행동-목적어 형태로 구성하면 읽기 좋음
- Fluent 방식이 가독성을 높임



# Part 2. 개발자에게 도움이 되는 테스트 만들기

# 4장 좋은 단위 테스트의 4대 요소

## 4.1 좋은 단위 테스트의 4대 요소 자세히 살펴보기

- 회귀 방지
- 리팩터링 내성
- 빠른 피드백
- 유지 보수성



### 4.1.1 첫 번째 요소: 회귀 방지

- 회귀 방지 지표 고려사항
  - 테스트 중 실행되는 코드 양
    - 많을 수록 회귀 발생 확률이 높음
  - 코드 복잡도
    - 복잡할수록 테스트 가치가 높음
  - 코드의 도메인 유의성
    - 높을수록 중요

- 외부 의존성에 대한 검증도 확인이 필요



### 4.1.2 두 번째 요소: 리팩터링 내성

- 거짓 양성(false positive)
  - 정상적으로 기능이 작동함에도 테스트가 실패하는 경우
- 리팩터링 내성 지표
  - 테스트에서 거짓 양성이 적게 나올수록 좋음



### 4.1.3 무엇이 거짓 양성의 원인인가?

- 테스트와 SUT의 구현 세부 사항이 많이 결합될수록 거짓 양성이 많아짐
- 구현 사항에서 테스트를 분리해야 함
  - **테스트는 SUT의 절차가 아니라 최종 결과를 검증해야 함**



## 4.2 첫 번째 특성과 두 번째 특성 간의 본질적인 관계

### 4.2.1 테스트 정확도 극대화

- 테스트 결과의 종류
  - 기능 정상 - 테스트 통과
    - 올바른 추론(참 음성)
  - 기능 고장 - 테스트 실패
    - 올바른 추론(참 양성)
  - 기능 작동 - 테스트 실패
    - 1종 오류(거짓 양성)
    - 리팩터링 내성이 낮음
  - 기능 고장 - 테스트 성공
    - 2종 오류(거짓 음성)
    - 회귀 방지가 안 됨

- 거짓 양성을 줄이는 것도, 거짓 음성을 줄이는 것도 모두 중요



### 4.2.2 거짓 양성과 거짓 음성의 중요성: 역학 관계

- 거짓 양성은 프로젝트 초기에는 거짓 음성에 비해 덜 중요
  - 초기에는 리팩터링의 중요성이 낮기 때문
  - 프로젝트 후반으로 갈수록 거짓 양성은 거짓 음성만큼 중요



## 4.3 세 번째 요소와 네 번째 요소: 빠른 피드백과 유지 보수성

- 빠른 피드백
- 유지 보수성
  - 테스트가 이해하기 어려운 정도
  - 테스트가 실행하기 어려운 정도



## 4.4 이상적인 테스트를 찾아서

- 좋은 테스트의 네 지표
  - 회귀 방지
  - 리팩터링 내성
  - 빠른 피드백
  - 유지 보수성
- 네 가지 지표가 0 ~ 1의 수치로 평가될 때
  - 테스트 코드의 품질은 네 지표의 값을 곱한 것과 같음



### 4.4.1 이상적인 테스트를 만들 수 있는가?

- 이상적인 테스트는 네 가지 지표에서 모두 1을 받는 테스트
  - 이는 불가능: 회귀 방지, 리팩터링 내성, 빠른 피드백은 상호 배타적이기 때문

- 하나라도 0인 테스트는 좋은 테스트가 아님
  - 테스트 지표 간 균형도 중요



### 4.4.2 극단적인 사례1: 엔드 투 엔드 테스트

- 많은 코드를 테스트하기에 회귀 방지가 훌륭함
- 거짓 양성에 면역이기에 리팩터링 내성도 우수
- 속도가 극단적으로 느리기에 엔드 투 엔드 테스트에만 의존할 수는 없음
- **빠른 피드백 지표에서 실패**



### 4.4.3  극단적인 사례2: 간단한 테스트

- getter를 검사하는 테스트의 예
- 빠른 실행 속도
- 거짓 양성 확률 낮음: 리팩터링 내성 높음
- 회귀 방지 능력이 전무
  - 동어반복(tautology) 테스트
  - 무의미한 검증

- **회귀 방지 지표에서 실패**



### 4.4.4 극단적인 사례3: 깨지기 쉬운 테스트

- 깨지기 쉬운 테스트(brittle test)
- 특정 SQL문을 실행했는지 확인하는 테스트의 예
- 빠른 실행, 회귀 방지에 있어서 훌륭하지만
- **리팩터링 내성에서 실패**



### 4.4.5 이상적인 테스트를 찾아서: 결론

- **리팩터링 내성을 포기할 수는 없음**
  - 일반적으로 리팩터링 내성은 있거나, 없거나: 둘 중 하나기 때문(0 or 1)
- 회귀 방지와 빠른 피드백 중 무엇을 얼마나 희생할 지 조절해야 함

- CAP 정리(CAP theorem): 분산 데이터 저장소가 충족하지 못하는 세 조건
  - 일관성(consistency): 모든 읽기가 가장 최근의 읽기 또는 오류를 수신
  - 가용성(availability): 모든 요청이 응답을 수신
  - 분할 내성(partition tolerance): 네트워크 분할에도 시스템이 계속 작동

- CAP정리는 테스트의 세 가지 관계와 유사함



## 4.5 대중적인 테스트 자동화 개념 살펴보기

### 4.5.1 테스트 피라미드 분해

- 단위 테스트 -> 통합 테스트 -> 엔드 투 엔드 테스트
  - 상단으로 갈수록 사용자 경험을 가깝게 모방
  - 상단으로 갈수록 회귀 방지에 유리, 하단으로 갈수록 실행 속도에 유리
  - 상단으로 갈수록 테스트 수가 적어야 한다.
  - 예외
    - 복잡도가 낮은 CRUD 위주 애플리케이션의 경우 피라미드 형태가 아니라
    - 단위 테스트와 통합 테스트의 수가 같고 엔드 투엔드 테스트가 없는 직사각형 형태가 될 것임



### 4.5.2 블랙박스 테스트와 화이트박스 테스트 간의 선택

|                   | 회귀 방지 | 리팩터링 내성 |
| ----------------- | --------- | ------------- |
| 화이트박스 테스트 | 좋음      | 나쁨          |
| 블랙박스 테스트   | 나쁨      | 좋음          |

