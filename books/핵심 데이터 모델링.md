# 핵심 데이터 모델링
Theory and Practice of Data Modeling
유동오 지음

## 데이터 모델링 이론
### 데이터 모델링이란
- 데이터 모델: 현실 세계의 정보를 시스템으로 구축하기 위해 추상화한 모형
	- 개체관계 모델(ER; Entity-Relationship Model)
	- 관계 모델(Relational Model)
	- 계층 모델(Hierarchical Model)
	- 망 모델(Network Model)
- 데이터 모델링: 이 시스템 구조를 사람이 이해할 수 있도록 형상화하는 과정
	- 정보의 대상을 식별(개념 모델링)
	- 추상화하여 표현(논리 모델링)
	- DB 구축을 위한 구체화(물리 모델링)
#### ER 모델
- 개체-관계로 표현
- P. P. Chen(1976)
- ER 표기법 사용
- ERD; Entity-Relationship Diagram
#### ER 모델의 질적 특성
- 완전성(Completeness): 현실 세계의 모든 업무적 요구사항을 표현하고 있는가?
- 정확성(Correctness): 개념에 맞게 모델링
- 최소성(Minimality): 요구사항의 모든 특성이 ER모델에 단 한번만 나타나야 하며, 중복 발생시 중복 데이터(Derived Data)를 반드시 문서화
- 자명성(Self-explanation): 별도의 자료 없이 그 자체로 의미를 명확히 설명
- 확장성(Extensibility): 확장에 용이하게 유연한 모델을 설계해야
- 표현성(Expressiveness): 직관적 이해가 가능하게끔 명확하게 설계
- 가독성(Readablitiy): 읽기 쉽게 표현

- ### 표현성과 자명성의 차이는?

### ER 모델 구성 요소
- 엔티티
- 관계
- 속성(Attribute)
- 식별자(Identifier): 속성과 관계 중 하나 이상의 조합으로 구성됨
#### 엔티티(Entity)
- 개념
	- 실체는 주어가 되며 술어가 되지 않는다.
	- 실체는 존재론적 독립성을 가짐
	- 엄밀히 말해서 엔티티는 엔티티 타입의 인스턴스다.
- 엔티티의 특성
	- 관계에 해당하는 엔티티는 존재할 수 있다.
	- 적어도 둘 이상의 인스턴스가 존재할 수 있어야 하고, 최소한 둘 이상의 속성이 있어야 하며, 식별자가 하나 이상 정의되어야 한다.
##### 슈퍼타입, 서브타입
- 슈퍼타입 엔티티는 일반화된 엔티티로, 서브타입의 공통속성을 관리
- 서브타입 엔티티는 특수화된 엔티티로, 고유 속성을 관리
- 일반화/특수화 과정을 통해 도출된다.
##### 일반화(Generalization)
- 하위 수준 엔티티를 결합하여 상위 수준의 엔티티로 통합하는 상향식 접근 방식
- 일반화의 분류
	- 완전(Total)/불완전(Partial) 일반화: 슈퍼타입의 인스턴스가 서브타입의 인스턴스에 모두 존재하는가?
	- 배타적/포괄적 일반화: 상위 수준 엔티티의 모든 인스턴스가 하위 수준 엔티티 중 하나에만 존재하는가? (SubType1 <-> !SubType2)
		- superTypeInstance instance of SubType1 && superTypeInstance SubType2이면 포괄
- 일반화는 업무 관리를 단순하게 정의할 수 있고 확장에 유연하다.
- 하지만 고유 속성의 의미가 불분명해질 수 있으며 참조 무결성 및 도메인 무결성을 제대로 반영하지 못할 수 있다.
##### 특수화(Specialization)
- 일반화의 반대 개념, 하향식 접근법
- 일반적인 순서로는
	- 슈퍼타입을 정의하고
	- 서브타입과 속성을 정의한 후
	- 관계를 정의한다.
- 특수화를 통해 구체적 속성을 명확히 식별하여 업무 규칙을 제대로 반영할 수 있다.
##### 집단화(Aggregation)
- 기본적인 ER 표기법은 관계와 관계 사이를 연결할 수 없다.
- 엔티티간의 관계를 집단화하여 단일 엔티티로서 새로이 정의할 수 있다.
- 하나의 엔티티로 취급되는 두 개 엔티티 사이에서 일어나며, 해당 엔티티와의 관계가 상위 수준 엔티티로 대체된다.
##### 엔티티의 다양한 분류 기준
- 엔티티 관계
	- 강한(Strong) 엔티티: 존재론적 독립성, 자체 식별자 사용
	- 약한(Weak) 엔티티: 다른 엔티티에 종속적, ### FK로 식별
-  엔티티 형태
	- 독립(Kernel, Master) 엔티티: 원래부터 현실에 존재하는 엔티티
	- 업무중심(Transaction) 엔티티: 업무 처리 중 발생하는 데이터 엔티티, 주제영역에서 핵심이 되는 엔티티
	- 종속(Dependent) 엔티티: 주로 업무중심 엔티티에서 1차 정규화로 분리된 엔티티
	- 교차(Associative, Relative) 엔티티: 두 개 이상의 엔티티 사이에서 발생하는 트랜잭션에 의해 생성되는 엔티티. 주로 다대다 관계를 해소하기 위함
- 엔티티 생성 관점
	- 핵심(Key) 엔티티: 부모 엔티티를 갖지 않는 독립적, 핵심적 엔티티
	- 중요(Main) 엔티티: 핵심 엔티티 간의 거래 관계에 의해서 생성, 업무의 핵심이 되는 엔티티
	- 행위(Action) 엔티티: 업무 행위에 의해 지속해서 발생하는 거래 행위에 대한 엔티티
- 엔티티 형태(유형, 무형)
	- 실체(Tangible) 엔티티: 눈으로 볼 수 있는 물리적 형태를 가짐
	- 비실체(Intangible) 엔티티
		- 개념 엔티티: 물리적 형태는 없으나 개념적으로 존재하는 엔티티
		- 사건(Event) 엔티티: 업무 행위와 관련된 비실체 엔티티, 데이터가 빈번하게 생성, 변경됨
#### 관계(Relation)
- 엔티티 사이에 존재하는 업무 규칙 정의
- 구성 요소
	- 관계수(Cardinality)
		- 엔티티 인스턴스가 타 엔티티 인스턴스 몇 개에 대응될 수 있는지
		- 최대 인스턴스 수와 유관
	- 선택성(optionality)
		- 상대 엔티티 인스턴스가 반드시 존재해야 하는지(Mandatory), 존재하지 않아도 되는지(Optional) 표시
		- 최소 인스턴스 수와 유관
	- 관계명(Relationship Name)
		- 의미의 명확성에 따라 양쪽에 모두 기술하기도 하고 생략하기도 함
##### 관계수(Cardinality)
- 일대일(1:1) 관계
- 일다대(1:N) 관계
- 다대다(M:N)
##### 관계 선택성(optionality)
- 필수 - 필수 관계
- 필수 - 선택 관계
- 선택 - 선택 관계
	- 단순 참조 관계
- ##### 식별자 상속
	- 식별관계
		- 참조되는 식별자가 하위 엔티티 식별자로 상속됨
		- 동일/유사한 데이터 집합의 종속 관계
	- 비식별관계
		- 일반 속성으로 상속
		- 서로 다른 주제영역 엔티티 간의 참조관계
##### 관계 유형
- 기본 관계
	- 가장 일반적인 관계, 엔티티와 엔티티가 관계 맺음
	- 1:1 또는 1:M 관계
- 재귀적 관계
	- 자신과 관계 맺는 경우
	- 순환 관계라고도 함
	- 계층적 구조를 표현할 때 유용(카테고리, 부서 등)
	- 무조건 Optional 관계
	- 계층 구조의 변경에 쉽게 대응
- 병렬 관계
	- 엔티티와 엔티티 사이에 두 개 이상의 관계를 맺음
	- 관계 많거나 추가 가능성이 있을 경우, 계약당사자 엔티티로 대체하라
	- 관계가 많아지면 검색이 어려워지거나, 인덱스를 여럿 설계해야 할 수도 있음
	- 관계 엔티티 추가시 성능을 고려하여 일부 속성을 추가, 중복 관리할 수 있다.
- 슈퍼타입/서브타입 관계
	- 공통속성 관리 / 개별 속성 관리
- 배타적인 관계
	- 아크(Arc) 관계
	- 다른 엔티티의 합집합과 관계를 가짐 
##### 관계 차원
- 단항 관계
	- 재귀적 관계처럼 하나의 엔티티에 존재하는 관계
- 이항 관계
	- 가장 일반적인 형태의 관계
- 삼항 관계
	- ERwin 등의 Case 툴에서 지원하지 않음
	- 교차 엔티티를 추가하여 표현
#### 속성(Attribute)
- 구성 요소
	- 속성명
	- 식별자여부
	- 옵셔널리티
		- Mandatory, Optional, Condtional(특정 조건에 해당 시 Mandatory)
	- 도메인
		- 속성이 허용하는 데이터 형식, 범위
- 분류
	- 단순 속성과 복합 속성
		- 단순 속성(Simple Attribute): 원자값
		- 복합 속성(Composite Attribute): 단순 속성들의 조합
		- 개념적 분석의 차원으로, 실제 모델링에서는 복합 속성도 단순 속성으로 종종 분리하여 표현하기도 한다.
	- 저장 속성과 파생 속성
		- 저장 속성(Stored Attribute): 원래 존재
		- 파생 속성(Derived Attribute): 파생됨
		- 파생 속성은 특수한 목적이 있을때만 도출
	- 단일 값 속성과 다중 값 속성
		- 단일 값 속성(Single-Valued Attribute)
		- 복합 값 속성(Multi-Valued Attribute): 하나의 속성이 여러 개의 값을 가짐
		- 다중 값 속성은 모델링 과정에서 정규화를 통해 별도 엔티티로 분리된다.
#### 식별자(Identifier)
- 엔티티에서 인스턴스를 개별적으로 식별할 수 있는 속성(들)
- 특징
	- 유일성(Uniqueness)
	- 최소성(Minimum)
	- 불변성(Stability)
	- 존재성(Mandatory)
- 분류
	- 고유 속성 여부에 따라
		- 본질 식별자
		- 인조 식별자
	- 대표성 여부에 따라
		- 주 식별자
		- 대체(보조) 식별자
		- 상대적인 개념, PK에 따라 달라짐

### 관계형 데이터 모델링 이론
- 릴레이션 스키마: 릴레이션명과 어트리뷰트
- 튜플: 릴레이션 인스턴스
#### 관계형 모델의 키
- 슈퍼 키(Super Key)
	- 튜플을 고유하게 식별할 수 있는 속성 집합
- 후보 키(Candidate Key)
	- 튜플을 고유하게 식별 할 수 있는 최소한의 속성 집합
	- 후보키 -> 슈퍼키 (역은 성립 안 한다.)
- 기본 키(Primary Key, PK)
	- 릴레이션은 후보키 중 단 하나만을 기본 키로 선택
- 대체 키(Alternate Key)
	- 기본 키가 아닌 후보 키
- 외래 키(Foreign Key)
	- 다른 릴레이션의 기본 키를 참조하는 어트리뷰트
	- null, 중복이 가능
#### 제약조건
- 키 제약조건: 슈퍼키여야 함
	- 무결성 제약조건
		- 실체무결성: PK는 !null, unique
		- 영역무결성: 어트리뷰트 값은 도메인 내에 속한 값
		- 참조무결성: 외래키는 참조하는 부모 릴레이션의 기본키 값이어야만 함, 양 릴레이션 같 일관성을 유지해야
#### 함수 종속(Functional Dependency)
- X 는 단일한 Y에 대응하고,
	Y는 X 여럿에 대응할 때,
	Y는 X에 함수 종속이다. (Functional depenent)
	- X -> Y로 표기
	- X는 결정자(Determinant)
	- Y는 종속자(Dependent)
- 특정 컬럼A의 값을 알면 컬럼B의 값을 알 수 있을 때 B는 A에 함수 종속성이 있다.
- 함수 종속성은 정규형과 연관이 있음
	- 완전 함수종속 -> 제1정규형
	- 부분 함수종속 -> 제2정규형
	- 이행적 함수종속 -> 제3정규형
	- 결정자 함수종속 -> BCNF정규형
	- 다중 값 종속 -> 제4정규형
	- 조인 종속 -> 제5정규형
- 분류
	- 완전 함수종속(Full Functional Dependency)
		- X -> Y지만, X의 부분집합에 대해서는 Y가 종속적이지 않음
		- 후보키인 X가 그 예
	- 부분 함수종속(Partial Functional Dependency)
		- X-> Y이고, X의 부분집합에 대해서도 Y가 종속적
		- 슈퍼키지만 후보키가 못 되는 X가 그 예
	- 이행적 함수종속(Transitive Functional Dependency)
		- X -> Y, Y -> Z로 인해 성립하는 X -> Z
		- 데이터 변경 이상의 원인이 됨
		- 주문번호 -> 고객번호 -> 고객명
#### 정규화(Normalization)
- CUD시에 발생하는 이상현상을 최소화하기 위해 작은 단위의 테이블로 설계하는 것
- 장점
	- 이상 현상 최소화
	- 유연성 극대화
		- 종속성이 강한 데이터요소를 분리, 독립 엔티티로 정의 -> 높은 응집력, 낮은 결합도
	- 재활용성 증가
		- 개념 세분으로 인함
		- 여러 참조 모델(Reference Model)이 정규형을 만족함
	- Non-key 데이터 요소가 한 번만 표현
		- 중복 최소화
		- 데이터 품질 문제 감소
		- 저장공간 최소화
	- CUD 작업 최소화 -> 속도 향상
- 일반적으로 ERD는 각 개념을 독립적으로 설계한 데이터 모델링의 결과물이기에 정규화된 형태를 가진다.
- 정규형을 만족하고 있지 않은 모델
	- 개념이 명확하지 않거나
	다수의 개념을 한 엔티티에 포함
	- 개념 분리 모델링을 통해 정규화 만족
- 정규형 만족 검토를 통해
	- 정규화를 거치지 않은 모델이라도 데이터 모델 완전성을 확인 가능
	- 리버스 모델링을 중심으로 상향식 모델링을 진행시 개선점을 도출 가능
- 정규화가 많아질수록 조인이 빈번하게 발생
	- 하지만 반드시 성능이 저하하지는 않음
	- 경우에 따라 반정규화(De-normalization)하기도 함.
		- 제한적으로 사용할 것
		- 데이터 중복으로 인한 이상 현상에 대비해야
- 정규화는 물리모델과 더 밀접한 관계형 모델과 관련되어 있지만, 논리 모델링 과정에서 ER모델과 함께 적용하는 것이 일반적
##### 제1정규형(1ST NF)
- 관계형 테이블은 중복되는 행이 없어야 하며
	- PK 존재하면 됨
- 모든 열의 값은 원자 값(Atomic value)를 가져야 한다.
	- 개념적으로 중복 열이 없어야 함
		- 동일한 개념의 어트리뷰트가 여럿 있으면 안 됨
	- 다중 값이 발생해선 안 됨
	- 개념적 중복 / 다중 값이 발생하는 어트리뷰트는 별도의 릴레이션으로 분리해야
		- 분리된 테이블은 일반적으로 원래 테이블의 PK를 상속하여 PK로 삼음
	- 원자성의 모호함
		- 사용 목적에 따라 다르게 볼 필요가 있음
		- ex) 전화번호, 주소 값, 집/회사 주소
##### 제2정규형(2ND NF)
- 제1정규형 만족하면서
- 후보키가 아닌 속성은 후보키 전체에 종속되어야 한다.
	- 후보키에 종속적이지 않거나 후보키 일부 속성에 종속적이지 않은 속성은 별도 테이블로 분리해야 한다.
##### 제3정규형(3RD NF)
- 제2정규형을 만족하면서
- 키가 아닌 어트리뷰트 사이에 종속적인 관계가 없어야 한다.
	- 키가 아닌 속성이가종속된 경우 별도 테이블로 분리하라.
#### 연결함정(Connection Trap)
- 관계형 모델에서 모호한 관계가 발생하는 현상
	- 정규화 과정에서 무손실 분해의 원칙이 지켜지지 않아 관계성을 손실할 때 발생
	- 주로 삼항관계(ternary relationship)을 이항관계(binary relationship)으로 적절히 분할하지 못할 때 발생
	- 부채꼴 함정(Fan Trap)과 균열 함정(Chasm Trap)으로 나뉨
##### 부채꼴 함정(Fan Trap)
- M:N 관계를 해소하기 위해 교차 엔티티를 추가하면서 발생 가능
- 잘못된 관계설정으로 인해 연계된 정보 추적이 불가능해질 때 발생
- 관계를 명확히 하여 해결

##### 균열 함정(Chasm Trap)
- 엔티티 사이의 관계 누락
- 중복된 관계를 제거할 때 정말로 중복인지 재확인 필요
- 업무 관련 지식의 이해가 필요 -> 이러한 문제들은 단순 모델링 개념만의 문제가 아님!
#### ER모델과 관계 모델
- ER모델 관계모델의 구별
	- ER모델은 관계 모델, 망 모델, 엔티티 집합 모델을 통합하여 실세계를 표현
	- ER모델과 관계 모델은 설계 과정은 다르지만 결과적으로 서로 대응하는 유사한 결과를 갖는다.
	- 그러나 ER모델과 관계 모델은 서로 다르다.
- 개념, 논리, 물리 모델링 구별
	- ER모델을 관계 모델로 적용하는 단계를 논리 모델로 보느냐, 물리 모델로 보느냐 등 관점에 따라 차이 있는 부분이 많다.
	- 개념적으로 논리와 물리, ER모델과 관계 모델은 독립적이다.
	- 이론과 별개로, 실제 모델링이 별개로 진행되어야 하는 것은 아니다.
	- 프로젝트의 성격과 상황 등에 따라 달리 할 부분이다.


## 02 개념 모델링
### 데이터 모델링 접근방법
- 하향식(Top-Down) 접근방식
- 상향식(Bottom-Up) 접근방식