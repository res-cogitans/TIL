# 핵심 데이터 모델링
Theory and Practice of Data Modeling
유동오 지음

## 데이터 모델링 이론
### 데이터 모델링이란
- 데이터 모델: 현실 세계의 정보를 시스템으로 구축하기 위해 추상화한 모형
	- 개체관계 모델(ER; Entity-Relationship Model)
	- 관계 모델(Relational Model)
	- 계층 모델(Hierarchical Model)
	- 망 모델(Network Model)
- 데이터 모델링: 이 시스템 구조를 사람이 이해할 수 있도록 형상화하는 과정
	- 정보의 대상을 식별(개념 모델링)
	- 추상화하여 표현(논리 모델링)
	- DB 구축을 위한 구체화(물리 모델링)
#### ER 모델
- 개체-관계로 표현
- P. P. Chen(1976)
- ER 표기법 사용
- ERD; Entity-Relationship Diagram
#### ER 모델의 질적 특성
- 완전성(Completeness): 현실 세계의 모든 업무적 요구사항을 표현하고 있는가?
- 정확성(Correctness): 개념에 맞게 모델링
- 최소성(Minimality): 요구사항의 모든 특성이 ER모델에 단 한번만 나타나야 하며, 중복 발생시 중복 데이터(Derived Data)를 반드시 문서화
- 자명성(Self-explanation): 별도의 자료 없이 그 자체로 의미를 명확히 설명
- 확장성(Extensibility): 확장에 용이하게 유연한 모델을 설계해야
- 표현성(Expressiveness): 직관적 이해가 가능하게끔 명확하게 설계
- 가독성(Readablitiy): 읽기 쉽게 표현

- ### 표현성과 자명성의 차이는?

### ER 모델 구성 요소
- 엔티티
- 관계
- 속성(Attribute)
- 식별자(Identifier): 속성과 관계 중 하나 이상의 조합으로 구성됨
#### 엔티티(Entity)
- 개념
	- 실체는 주어가 되며 술어가 되지 않는다.
	- 실체는 존재론적 독립성을 가짐
	- 엄밀히 말해서 엔티티는 엔티티 타입의 인스턴스다.
- 엔티티의 특성
	- 관계에 해당하는 엔티티는 존재할 수 있다.
	- 적어도 둘 이상의 인스턴스가 존재할 수 있어야 하고, 최소한 둘 이상의 속성이 있어야 하며, 식별자가 하나 이상 정의되어야 한다.
##### 슈퍼타입, 서브타입
- 슈퍼타입 엔티티는 일반화된 엔티티로, 서브타입의 공통속성을 관리
- 서브타입 엔티티는 특수화된 엔티티로, 고유 속성을 관리
- 일반화/특수화 과정을 통해 도출된다.
##### 일반화(Generalization)
- 하위 수준 엔티티를 결합하여 상위 수준의 엔티티로 통합하는 상향식 접근 방식
- 일반화의 분류
	- 완전(Total)/불완전(Partial) 일반화: 슈퍼타입의 인스턴스가 서브타입의 인스턴스에 모두 존재하는가?
	- 배타적/포괄적 일반화: 상위 수준 엔티티의 모든 인스턴스가 하위 수준 엔티티 중 하나에만 존재하는가? (SubType1 <-> !SubType2)
		- superTypeInstance instance of SubType1 && superTypeInstance SubType2이면 포괄
- 일반화는 업무 관리를 단순하게 정의할 수 있고 확장에 유연하다.
- 하지만 고유 속성의 의미가 불분명해질 수 있으며 참조 무결성 및 도메인 무결성을 제대로 반영하지 못할 수 있다.
##### 특수화(Specialization)
- 일반화의 반대 개념, 하향식 접근법
- 일반적인 순서로는
	- 슈퍼타입을 정의하고
	- 서브타입과 속성을 정의한 후
	- 관계를 정의한다.
- 특수화를 통해 구체적 속성을 명확히 식별하여 업무 규칙을 제대로 반영할 수 있다.
##### 집단화(Aggregation)
- 기본적인 ER 표기법은 관계와 관계 사이를 연결할 수 없다.
- 엔티티간의 관계를 집단화하여 단일 엔티티로서 새로이 정의할 수 있다.
- 하나의 엔티티로 취급되는 두 개 엔티티 사이에서 일어나며, 해당 엔티티와의 관계가 상위 수준 엔티티로 대체된다.
##### 엔티티의 다양한 분류 기준
- 엔티티 관계
	- 강한(Strong) 엔티티: 존재론적 독립성, 자체 식별자 사용
	- 약한(Weak) 엔티티: 다른 엔티티에 종속적, ### FK로 식별
-  엔티티 형태
	- 독립(Kernel, Master) 엔티티: 원래부터 현실에 존재하는 엔티티
	- 업무중심(Transaction) 엔티티: 업무 처리 중 발생하는 데이터 엔티티, 주제영역에서 핵심이 되는 엔티티
	- 종속(Dependent) 엔티티: 주로 업무중심 엔티티에서 1차 정규화로 분리된 엔티티
	- 교차(Associative, Relative) 엔티티: 두 개 이상의 엔티티 사이에서 발생하는 트랜잭션에 의해 생성되는 엔티티. 주로 다대다 관계를 해소하기 위함
- 엔티티 생성 관점
	- 핵심(Key) 엔티티: 부모 엔티티를 갖지 않는 독립적, 핵심적 엔티티
	- 중요(Main) 엔티티: 핵심 엔티티 간의 거래 관계에 의해서 생성, 업무의 핵심이 되는 엔티티
	- 행위(Action) 엔티티: 업무 행위에 의해 지속해서 발생하는 거래 행위에 대한 엔티티
- 엔티티 형태(유형, 무형)
	- 실체(Tangible) 엔티티: 눈으로 볼 수 있는 물리적 형태를 가짐
	- 비실체(Intangible) 엔티티
		- 개념 엔티티: 물리적 형태는 없으나 개념적으로 존재하는 엔티티
		- 사건(Event) 엔티티: 업무 행위와 관련된 비실체 엔티티, 데이터가 빈번하게 생성, 변경됨
#### 관계(Relation)
- 엔티티 사이에 존재하는 업무 규칙 정의
- 구성 요소
	- 관계수(Cardinality)
		- 엔티티 인스턴스가 타 엔티티 인스턴스 몇 개에 대응될 수 있는지
		- 최대 인스턴스 수와 유관
	- 선택성(optionality)
		- 상대 엔티티 인스턴스가 반드시 존재해야 하는지(Mandatory), 존재하지 않아도 되는지(Optional) 표시
		- 최소 인스턴스 수와 유관
	- 관계명(Relationship Name)
		- 의미의 명확성에 따라 양쪽에 모두 기술하기도 하고 생략하기도 함
##### 관계수(Cardinality)
- 일대일(1:1) 관계
- 일다대(1:N) 관계
- 다대다(M:N)
##### 관계 선택성(optionality)
- 필수 - 필수 관계
- 필수 - 선택 관계
- 선택 - 선택 관계
	- 단순 참조 관계
- ##### 식별자 상속
	- 식별관계
		- 참조되는 식별자가 하위 엔티티 식별자로 상속됨
		- 동일/유사한 데이터 집합의 종속 관계
	- 비식별관계
		- 일반 속성으로 상속
		- 서로 다른 주제영역 엔티티 간의 참조관계
##### 관계 유형
- 기본 관계
	- 가장 일반적인 관계, 엔티티와 엔티티가 관계 맺음
	- 1:1 또는 1:M 관계
- 재귀적 관계
	- 자신과 관계 맺는 경우
	- 순환 관계라고도 함
	- 계층적 구조를 표현할 때 유용(카테고리, 부서 등)
	- 무조건 Optional 관계
	- 계층 구조의 변경에 쉽게 대응
- 병렬 관계
	- 엔티티와 엔티티 사이에 두 개 이상의 관계를 맺음
	- 관계 많거나 추가 가능성이 있을 경우, 계약당사자 엔티티로 대체하라
	- 관계가 많아지면 검색이 어려워지거나, 인덱스를 여럿 설계해야 할 수도 있음
	- 관계 엔티티 추가시 성능을 고려하여 일부 속성을 추가, 중복 관리할 수 있다.
- 슈퍼타입/서브타입 관계
	- 공통속성 관리 / 개별 속성 관리
- 배타적인 관계
	- 아크(Arc) 관계
	- 다른 엔티티의 합집합과 관계를 가짐 
##### 관계 차원
- 단항 관계
	- 재귀적 관계처럼 하나의 엔티티에 존재하는 관계
- 이항 관계
	- 가장 일반적인 형태의 관계
- 삼항 관계
	- ERwin 등의 Case 툴에서 지원하지 않음
	- 교차 엔티티를 추가하여 표현
#### 속성(Attribute)
- 구성 요소
	- 속성명
	- 식별자여부
	- 옵셔널리티
		- Mandatory, Optional, Condtional(특정 조건에 해당 시 Mandatory)
	- 도메인
		- 속성이 허용하는 데이터 형식, 범위
- 분류
	- 단순 속성과 복합 속성
		- 단순 속성(Simple Attribute): 원자값
		- 복합 속성(Composite Attribute): 단순 속성들의 조합
		- 개념적 분석의 차원으로, 실제 모델링에서는 복합 속성도 단순 속성으로 종종 분리하여 표현하기도 한다.
	- 저장 속성과 파생 속성
		- 저장 속성(Stored Attribute): 원래 존재
		- 파생 속성(Derived Attribute): 파생됨
		- 파생 속성은 특수한 목적이 있을때만 도출
	- 단일 값 속성과 다중 값 속성
		- 단일 값 속성(Single-Valued Attribute)
		- 복합 값 속성(Multi-Valued Attribute): 하나의 속성이 여러 개의 값을 가짐
		- 다중 값 속성은 모델링 과정에서 정규화를 통해 별도 엔티티로 분리된다.
#### 식별자(Identifier)
- 엔티티에서 인스턴스를 개별적으로 식별할 수 있는 속성(들)
- 특징
	- 유일성(Uniqueness)
	- 최소성(Minimum)
	- 불변성(Stability)
	- 존재성(Mandatory)
- 분류
	- 고유 속성 여부에 따라
		- 본질 식별자
		- 인조 식별자
	- 대표성 여부에 따라
		- 주 식별자
		- 대체(보조) 식별자
		- 상대적인 개념, PK에 따라 달라짐

### 관계형 데이터 모델링 이론
- 릴레이션 스키마: 릴레이션명과 어트리뷰트
- 튜플: 릴레이션 인스턴스
#### 관계형 모델의 키
- 슈퍼 키(Super Key)
	- 튜플을 고유하게 식별할 수 있는 속성 집합
- 후보 키(Candidate Key)
	- 튜플을 고유하게 식별 할 수 있는 최소한의 속성 집합
	- 후보키 -> 슈퍼키 (역은 성립 안 한다.)
- 기본 키(Primary Key, PK)
	- 릴레이션은 후보키 중 단 하나만을 기본 키로 선택
- 대체 키(Alternate Key)
	- 기본 키가 아닌 후보 키
- 외래 키(Foreign Key)
	- 다른 릴레이션의 기본 키를 참조하는 어트리뷰트
	- null, 중복이 가능
#### 제약조건
- 키 제약조건: 슈퍼키여야 함
	- 무결성 제약조건
		- 실체무결성: PK는 !null, unique
		- 영역무결성: 어트리뷰트 값은 도메인 내에 속한 값
		- 참조무결성: 외래키는 참조하는 부모 릴레이션의 기본키 값이어야만 함, 양 릴레이션 같 일관성을 유지해야
#### 함수 종속(Functional Dependency)
- X 는 단일한 Y에 대응하고,
	Y는 X 여럿에 대응할 때,
	Y는 X에 함수 종속이다. (Functional depenent)
	- X -> Y로 표기
	- X는 결정자(Determinant)
	- Y는 종속자(Dependent)
- 특정 컬럼A의 값을 알면 컬럼B의 값을 알 수 있을 때 B는 A에 함수 종속성이 있다.
- 함수 종속성은 정규형과 연관이 있음
	- 완전 함수종속 -> 제1정규형
	- 부분 함수종속 -> 제2정규형
	- 이행적 함수종속 -> 제3정규형
	- 결정자 함수종속 -> BCNF정규형
	- 다중 값 종속 -> 제4정규형
	- 조인 종속 -> 제5정규형
- 분류
	- 완전 함수종속(Full Functional Dependency)
		- X -> Y지만, X의 부분집합에 대해서는 Y가 종속적이지 않음
		- 후보키인 X가 그 예
	- 부분 함수종속(Partial Functional Dependency)
		- X-> Y이고, X의 부분집합에 대해서도 Y가 종속적
		- 슈퍼키지만 후보키가 못 되는 X가 그 예
	- 이행적 함수종속(Transitive Functional Dependency)
		- X -> Y, Y -> Z로 인해 성립하는 X -> Z
		- 데이터 변경 이상의 원인이 됨
		- 주문번호 -> 고객번호 -> 고객명
#### 정규화(Normalization)
- CUD시에 발생하는 이상현상을 최소화하기 위해 작은 단위의 테이블로 설계하는 것
- 장점
	- 이상 현상 최소화
	- 유연성 극대화
		- 종속성이 강한 데이터요소를 분리, 독립 엔티티로 정의 -> 높은 응집력, 낮은 결합도
	- 재활용성 증가
		- 개념 세분으로 인함
		- 여러 참조 모델(Reference Model)이 정규형을 만족함
	- Non-key 데이터 요소가 한 번만 표현
		- 중복 최소화
		- 데이터 품질 문제 감소
		- 저장공간 최소화
	- CUD 작업 최소화 -> 속도 향상
- 일반적으로 ERD는 각 개념을 독립적으로 설계한 데이터 모델링의 결과물이기에 정규화된 형태를 가진다.
- 정규형을 만족하고 있지 않은 모델
	- 개념이 명확하지 않거나
	다수의 개념을 한 엔티티에 포함
	- 개념 분리 모델링을 통해 정규화 만족
- 정규형 만족 검토를 통해
	- 정규화를 거치지 않은 모델이라도 데이터 모델 완전성을 확인 가능
	- 리버스 모델링을 중심으로 상향식 모델링을 진행시 개선점을 도출 가능
- 정규화가 많아질수록 조인이 빈번하게 발생
	- 하지만 반드시 성능이 저하하지는 않음
	- 경우에 따라 반정규화(De-normalization)하기도 함.
		- 제한적으로 사용할 것
		- 데이터 중복으로 인한 이상 현상에 대비해야
- 정규화는 물리모델과 더 밀접한 관계형 모델과 관련되어 있지만, 논리 모델링 과정에서 ER모델과 함께 적용하는 것이 일반적
##### 제1정규형(1ST NF)
- 관계형 테이블은 중복되는 행이 없어야 하며
	- PK 존재하면 됨
- 모든 열의 값은 원자 값(Atomic value)를 가져야 한다.
	- 개념적으로 중복 열이 없어야 함
		- 동일한 개념의 어트리뷰트가 여럿 있으면 안 됨
	- 다중 값이 발생해선 안 됨
	- 개념적 중복 / 다중 값이 발생하는 어트리뷰트는 별도의 릴레이션으로 분리해야
		- 분리된 테이블은 일반적으로 원래 테이블의 PK를 상속하여 PK로 삼음
	- 원자성의 모호함
		- 사용 목적에 따라 다르게 볼 필요가 있음
		- ex) 전화번호, 주소 값, 집/회사 주소
##### 제2정규형(2ND NF)
- 제1정규형 만족하면서
- 후보키가 아닌 속성은 후보키 전체에 종속되어야 한다.
	- 후보키에 종속적이지 않거나 후보키 일부 속성에 종속적이지 않은 속성은 별도 테이블로 분리해야 한다.
##### 제3정규형(3RD NF)
- 제2정규형을 만족하면서
- 키가 아닌 어트리뷰트 사이에 종속적인 관계가 없어야 한다.
	- 키가 아닌 속성이가종속된 경우 별도 테이블로 분리하라.
#### 연결함정(Connection Trap)
- 관계형 모델에서 모호한 관계가 발생하는 현상
	- 정규화 과정에서 무손실 분해의 원칙이 지켜지지 않아 관계성을 손실할 때 발생
	- 주로 삼항관계(ternary relationship)을 이항관계(binary relationship)으로 적절히 분할하지 못할 때 발생
	- 부채꼴 함정(Fan Trap)과 균열 함정(Chasm Trap)으로 나뉨
##### 부채꼴 함정(Fan Trap)
- M:N 관계를 해소하기 위해 교차 엔티티를 추가하면서 발생 가능
- 잘못된 관계설정으로 인해 연계된 정보 추적이 불가능해질 때 발생
- 관계를 명확히 하여 해결

##### 균열 함정(Chasm Trap)
- 엔티티 사이의 관계 누락
- 중복된 관계를 제거할 때 정말로 중복인지 재확인 필요
- 업무 관련 지식의 이해가 필요 -> 이러한 문제들은 단순 모델링 개념만의 문제가 아님!
#### ER모델과 관계 모델
- ER모델 관계모델의 구별
	- ER모델은 관계 모델, 망 모델, 엔티티 집합 모델을 통합하여 실세계를 표현
	- ER모델과 관계 모델은 설계 과정은 다르지만 결과적으로 서로 대응하는 유사한 결과를 갖는다.
	- 그러나 ER모델과 관계 모델은 서로 다르다.
- 개념, 논리, 물리 모델링 구별
	- ER모델을 관계 모델로 적용하는 단계를 논리 모델로 보느냐, 물리 모델로 보느냐 등 관점에 따라 차이 있는 부분이 많다.
	- 개념적으로 논리와 물리, ER모델과 관계 모델은 독립적이다.
	- 이론과 별개로, 실제 모델링이 별개로 진행되어야 하는 것은 아니다.
	- 프로젝트의 성격과 상황 등에 따라 달리 할 부분이다.

## 02 개념 모델링
### 데이터 모델링 접근방법
- 하향식(Top-Down) 접근방식
	- 프로젝트 규모가 크고, 담당자에 의한 업무 지원이 원활한 경우
- 상향식(Bottom-Up) 접근방식
	- 프로젝트 규모가 비교적 작거나 현업자의 참여가 한정된 경우
	- 기존 ERD, 보고서, 매뉴얼, 업무지침서를 바탕으로 함
#### 현행분석 및 방향성 수립
- 현행 업무 분석: 업무에 대한 지식 파악
- 현행 데이터 분석: ERD, 테이블 정의서 등의 산출물 분석
##### 현업담당자와 협업
- 가장 좋은 방법
- 하지만 업무 지식이 뒷받침되어야 함
##### 문서를 통한 업무 요건 파악
- 기본적으로 보조적 방식
- 사용한다면
	- 업무/데이터 구조가 간단할 때 
	- 이미 구축된 시스템이 있고, 신규 시스템도 유사할 때 적용
- 추가적으로 현업자와 소통이 권장됨
##### 리버스 모델 활용
- 현행 ERD가 없거나 현행화가 이루어지지 않은 경우
- 시스템 DB 메타정보를 이용, ERD 작성: 리버스 모델링
- 빠르게 대상 시스템 구조, 업무 흐름을 파악 가능
	- 이를 통해 기존 시스템의 구조적 문제 파악과 개선 방안 마련 가능
- 상세화 작업이 중요
#### 리버스 모델링(Reverse Modeling)
- 주제영역별로 테이블을 나누어 수행, 속성 및 관계에 대한 상세화 진행
- 방법
	- 모든 테이블을 대상으로 리버스 작업을 1회 수행
		- 반복 작업이 적지만, 엔티티 식별, 관계 도출 작업이 어려움
	- 업무/주제영역/테이블 Owner 기준으로 작업을 나누어 수행
		- 반복적 작업을 요하지만 엔티티 도출 및 관계 식별이 용이
- ERWin 등 작업도구에서 주제 별 식별이 쉽게 색상이나 영역명 등을 추가함이 좋음

### 개념 모델링
- 업무 영역(Business Domian)에 대한 전반적인 구조 제시, 상위 수준의 데이터 구조를 설계
- 비즈니스 도메인에서 요구사항을 형상화하여 개념 도출,	
- 개념을 구체화하여 엔티티 식별
	- 최하위 영역 구역의 핵심 엔티티 도출
	- 엔티티 관계 식별
- 일반적인 작업과정
	- 주제영역 도출
	- 주제영역 분류 및 정의
	- 핵심 엔티티 정의 및 관계 정의
#### 주제영역
- 최상위 데이터 아키텍처
- 명확한 주제영역 구별
- 중복의 최소화
#### 주제영역도출
- 하향식 방법: 상위영역 식별 후, 하위계층 세분화
	- 현행 시스템에 대한 자료가 없거나 새 시스템 구축시 적용
- 상향식 방법: 엔티티 분류, 그룹핑으로 주제영역을 도출

#### 주제영역분류
- 주제영역 프레임워크
	- 핵심(Key) 데이터 주제영역
		- 주체(Who)
		- 장소(Where)
		- 대상/자원(What/How)
	- 중요(Main) 데이터 주제영역
		- 이벤트(When/Why 포함)
		- 상세한 이벤트 상태 등
- 수평적으로는 데이터 범위, 수직적으로는 데이터 계층
- MECE 원칙
	- 주제영역의 의미가 판명해야 하며,
	- 주제영역이 중복되지 않아야 하며,
	- 누락되어선 안 된다.
- 주제영역의 분류 관점
	- 기본적으로는 데이터 관점
		- 데이터 통합을 전제로 함
	- 서비스 관점이나 업무 관점도 가능
		- 다만 중복 데이터 존재할 수 있음
	- 데이터 중심이 이상적이지만, 업무나 기능 중심 관점이 관련자 입장에서 직관적이기도
	- 데이터 중심 분류가 아니라도 핵심 엔티티는 중복 관리하지 않도록 데이터 중심 분류가 필요
#### 주제영역 정의
- 주제영역을 설명하고 해당하는 데이터 범위나 내용을 명확히 정의하는 과정
- 주제영역 명명 규칙
	- 주제영역명은 관리하는 정보를 설명하는 단수형 명사를 사용한다.
	- 한글과 영문 대문자를 사용하고, 숫자 및 특수 문자는 사용하지 않는다.
	- 주제영역에 대한 영문약어는 알파벳 대문자와 숫자로 구성하며, 1레벨 주제영역은 영문 2자리로 구성하고, 하위 주제영역은 상위 주제영역 약어에 숫자 2자리를 붙여 구성한다. 예) CU01, CU0201
#### 주제영역을 정의할 때 난점
- 개념 부족
- 의견 차이
	- 직무에 따라 서로 다른 관점에서 접근하게 된다:
		- 모델러는 데이터 관점에서,
		- 현업은 실제 업무의 기능이나 흐름을 구현하려는 관점에서,
		- 시스템 운영 담당자는 시스템을 관리하고 운영하는 관점에서,
- 확신 부족
- 오너십
	- 영역, 역할, 책임 등의 애매모호함
	- 이런 이유로 주제영역과 오너십은 독립적이지만
	- 주제영역 정의에서 반발 발생 가능
#### 핵심 엔티티 식별
- 최하위 주제영역별로 핵심 엔티티를 도출, 식별
- 최하위 주제영역에 핵심 엔티티가 없다면 주제영역이 과도하게 세분화된 것임
- 핵심 데이터 주제영역에서는, 주체, 대상, 장소 등
- 중요 데이터 주제영역에서는, 업무 영역 내에서 상위 수준에 해당하는 엔티티(계약, 주문, 입출금)나, 고유 식별자를 가지는 엔티티(발주번호)
- 핵심 엔티티의 수, 상세화 수준은
	- 전반적인 데이터 구조 및 관계를 파악할 수 있을만큼 식별
	- 많은 엔티티를 추가해야하며 데이터의 의존성이 크지 않다면 주제영역을 세분화할 것
#### 식별자 및 속성 정의
- 식별자는 엔티티 개념을 가장 명확하게 표현할 수 있는 속성으로 구성한다.
- 속성을 어디까지 도출해야 할 지
	- 전반적인 데이터를 사용자가 파악할 수 있는 수준인것이 원론적으로 옳다.
	- 무조건 정규화나 중복 방지에 집착하지 말고 필요에 따라 직관적인 형태를 택하는 것이 낫다.
	- 주제엔티티의 관계가 너무 많을 경우(특히 M:N) 주제영역이 과도하게 분류된 것으로, 통합이 필요하다.

## 논리 모델링
### 논리 모델링이란
- 데이터 주제영역 단위로 데이터 모델링을 진행
- 구축 방법론
	- 기초 논리 데이터 모델(Primitive Logical Data Model) 설계
		- 주제영역별로 핵심 엔티티를 도출
		- 주요 관계 설계
		- 엔티티 식별자 정의
		- 주요 속성 도출
	- 논리 데이터 모델(Logical Data Model) 설계
		- 모든 업무영역에 필요한 데이터 모델 설계
		- 시스템 관점에서 필요한 데이터 항목은 방영 안 함
		- 데이터 이력관리는 업무 측면에서 관리가 필요한 부분만 반영
### 엔티티 정의 및 상세화
#### 핵심 엔티티(Key Entity, 기준정보)

- 독립적 엔티티
- 우선 분석 대상
- 업무 주체 혹은 행위 대상인 경우가 대부분
- 업무 행위(Event)에 대한 집계 또는 통계 자료 작성시 집합의 크기를 결정하는 Dimension으로 사용된다.
- 분류
	- 유형 및 분류(Type & Category)
		- 고객유형코드, 상품분류코드 등
	- 업무규칙 및 지식(Rule & Knowledge)
		- 직급별 연봉, 보험료 조건, 지역별 담당자
	- 업무주체 및 대상(Subject & Object)
		- 부서, 사원, 고객, 상품
	- 장소(Where)
		- 물류창고, 공장, AS센터, 도로, 채널, 지역, 좌표 등
- 핵심 엔티티 식별시, 엔티티 전체 집합의 범위와 유형을 명확히 해야 한다.
	- 또한, 엔티티 생명주기에 대한 명확한 이해가 바탕이 되어야 한다.
- 서브타입 도출, 식별자 정의, 속성 도출한다.
##### 유형 및 분류(Type & Category)
- 별도 엔티티로 구성
	- ex) 산업분류코드의 필드에 상위산업분류코드(FK)
	- 분류 체계가 복잡하거나 관리할 대상이 특별한 경우, 업무에서 중요한 위치를 차지할 때
- 공통코드로 통합하여 관리
	- 대분류코드 A: 농업 임업 및 어업(01~03)
	- dtype처럼 사용
##### 업무규칙 및 지식 엔티티(Type & Category)
- 업무 요건이 변경되었을 때 프로그램을 수정하지 않고도 변경사항을 시스템에 반영 가능
	- ex) 서비스 대상(자격) 엔티티
##### 업무 주체 및 대상(Subject & Object)
- 특히 고객 집합을 정의하는 것은 다양한 이슈를 가진다.
	- 고객은 누구인가: 비회원, 웹회원, 세대, 협력업체 등 다양한 식별 관점
	- 등록을 위한 최소 정보: 주민번호, 성명 등 식별을 위한 최소 정보
	- 식별방법: 주민번호, 외국인 등록번호, 여권번호 등, 실제 고객수보다 더 많이 집계되는 통계 왜곡도 발생 가능
	- 개인과 개인사업자: 비즈니스 측면에서 둘을 동등하게 볼 것인지, 다르게 볼 것인지
##### 장소(Where)
- 독립적인 엔티티로도
- 핵심 엔티티의 속성으로도 식별될 수 있음 
- 도로명주소 등 위치정보 데이터와의 연계 유무 등

#### 중요 엔티티(Main Entity, 업무기본)
