# 팀 개발을 위한 Git, GitHub 입문

- 여러 개발자가 동시에 코드를 짜려면?
  - 동일 소스 저장소를 다 같이 쓰는 경우를 생각해보자.
  - 버전관리 Git + 클라우드 저장소 GitHub
- 분산 버전 관리 시스템
  - 개인 작업이라면 진행 단계를 돌아가는 정도로도 괜찮다.
- 버전 관리
  - 원하는 시점마다 버전을 만들고 자유롭게 이동 가능
  - 동료가 만든 버전으로 이동 가능
  - 최신본으로 변경 가능

- **Git 호스팅 사이트 비교**

| Git 호스팅 사이트 | 모기업                      | 특징                                            | 가격                                                         |
| ----------------- | --------------------------- | ----------------------------------------------- | ------------------------------------------------------------ |
| **GitHub**        | GitHub Inc (Microsoft 인수) | 2800만명 사용자, 최대 규모                      | 공개 저장소 생성 무료<br>비공개 저장소: 3인 이하 무료<br>Enterprise(설치형): 21$/month |
| **GitLab**        | GitLab Inc                  | NASA, SONY등 10만 개 이상의 조직 사용, 오플소스 | 무료                                                         |
| **BitBucket**     | Atlassian                   | 사용자 600만, Jira 연동 쉬움                    | 5인 이하 무료                                                |



### Git & GitHub 시작하기

#### git 초기화와 로컬 저장소

- 초기화 명령
  - **`git init`**
  - 로컬 저장소 생성 (`.git` 폴더 생성)
    - `.git` 폴더는 로컬 저장소
    - 로컬 저장소에 버전 정보, 원격 저장소 주소 등이 생성됨
  - 한 폴더에 한 로컬 저장소만 유지해야 한다.

- git 전역 사용자 설정
  - **`git config -- global user.name "User Name"`**
  - - **`git config -- global user.email "myemail.email.com"`**



#### 버전 만들기

- ***`git add`**
  - 스테이지에 올릴 파일 선택

- **`git commit m "메세지"`**
  - **의미 있는 변동사항**을 묶어서 만든다.
  - **커밋 메시지를 잘 적자.**

- **`git log`**: 생성한 커밋 보기



#### GitHub에 코드 올리기 / 받아오기

- repo 만들기
  - template 기능: 자주 쓰는 프로젝트 초기화에 유용하다.
  - README
  - .gitignore
  - license

- **`git remote add`**
  - 로컬 프로젝트 폴더에 저장소 주소 알리기

- **`git push`**
  - **`git push origin main`**
  - 리모트 저장소에 변경 사항 올리기

> **`origin`은 remote 저장소 url을 지칭하는 표현**

- **`git clone`**
  - **`git clone https://github.com/아이디/이름.git.`**
    - **마지막 점을 찍지 않으면 현재 폴더에 생성됨!!!**
- **`git pull`**
  - 원격 저장소의 변경사항 받아오기
  - **`git pull origin main`**



### Git 주요 개념들

#### git의 커밋 개념

- 변경 사항(diff)의 모음이 아니다!
  - 과거 SVN들은 diff만 저장했다.
- git의 커밋은 **최종 코드 모음**이 맞다.

- 성능 문제?

  - Diff만 저장한 SVN은 초기로 되돌리는 데 시간이 너무 많이 걸린다
  - 기존 커밋과 비교, 변경 없다면 변경하지 않음만 저장해서 용량이 무겁지는 않음

  

#### git으로 추적하는 파일의 4가지 상태

- untracked: 수정 안 됨
- tracked
  - 수정 없음
  - 수정함
  - 스테이지됨



#### 소스트리 설정

- 인증방식은 **`OAuth`**
- 프로토콜은 **HTTPS**



#### branch

- 여러 가지를 뻗어서 커밋을 쌓는다.
- **main**: 기본 브랜치
- **head**: 현재 작업중인 브랜치
- **`git switch 다른브랜치이름`**: `다른브랜치이름` 브랜치로 이동하라.
  - `checkout` 명령어는 과거 방식임



#### merge

- **base** 브랜치에 **compare** 브랜치를 합침

- 먼저 **base** 브랜치로 이동

  - 즉, base 브랜치를 **head** 브랜치로 삼아 이동

  - **`git merge 합칠브랜치명`**

  - 합쳐진 두 브랜치는 동일 브랜치를 가리키게 된다.



##### merge의 종류



- `{a} merge {a, b} -> {a,b}`
  - 기존과 동일한 경우임: **fast-foward** 빨리 감기 방식
- {a, b, ?} merge {a, ?, c, }-> {a, b, c}
  - 머지 커밋 말생 **merge commit**

- {a, b, e} + {a, c, d} -> ?

  - 겹치는 지점이 있는 경우 컨플릭트 **conflict**

  - 동일 지점에 다른 포인트가 존재

  

#### conflict

- 해결

  - 충돌 지점을 수동으로 고쳐줘야 한다.

  - 충돌 지점은 다음과 같이 표시된다:

    ````
    ```
    1. 냥냥
    <<< HEAD
    2. 츄르가 조아
    ================
    2. 츄르~~ 시 져 !!
    >>> another 브랜치
    ````

  - `츄르~~ 시 져 !!`만 남기거나 하는 식으로, 하나만 남겨서 해결.

  - 충돌을 해결한 다음에는 다시 해당 변경사항을 스테이지로 올리고 커밋하라.



#### fork

- 저장소를 통째로 복사
  - 푸시 권한이 없을 때 기여하고 싶다면?
  - 포크한 저장소에 자유롭게 커밋 푸시 한 후 머지를 요청하면 된다.



##### 브랜치와 포크의 차이점

|            | 의의                                   | 편리한 점                                                    | 불편한 점                                               |
| ---------- | -------------------------------------- | ------------------------------------------------------------ | ------------------------------------------------------- |
| **브랜치** | 하나의 원본 저장소에서 분기를 나눈다   | 하나의 원본저장소에서 코드 커밋 이력을 편하게 볼 수 있다.    | 다수의 사용자가 다수의 브랜치를 만들면 관리하기 힘들다. |
| **포크**   | 여러 원격저장소를 만들어 분기를 나눈다 | 원본저장소에 영향을 미치지 않으므로 마음껏 코드를 수정할 수 있다. | 원본저장소의 이력을 보려면 따로 주소를 추가해줘야 한다. |



#### Pull Request

- 머지를 허락받는 것

- 풀 리퀘스트: 커밋들을 합치기

  - 머지하고 싶은 두 브렌치를 선택하고
  - 어떤 변경을 했는지 제목과 내용에 쓰면 됨
  - 포크한 저장소에서도 보낼 수 있다

- 가급적 직접 머지는 피하고 풀 리퀘스트 쓰라 **PR**
  - PR을 보고 코드 리뷰 가능
  - PR에 수정이 필요하면 댓글 달아 change request 보낼 수 있다
  - 오픈소스에 PR할 때는 기여 안내 문서 반드시 참고하라



### git 응용

- 브랜치 관리하기
  - 개별 개발
    - feat/기능명 : 한 사람 기능 브랜치
    - fix/버그명
    - hotfix/급한 버그
  - dev / main 브랜치로 PR 보내기
  - release latest 브랜치로 머지시키기
  - 실서버 배포
  - 직접 커밋은 feat/fix/hotfix 블랜치만
    - dev 등에는ㄴㄴ



- 베이스와 컴페어 주의



- fetch 패치 새로 고침 기능



- 과제 제출해 보기

  - 포크 // 포크 사용시

  - 코드 -> 주소 복사

  - 저장소 클론

  - PR로만 제출하라



- 실무 사례

  - amend : 까먹었다! 아까 커밋에 추가했어야 하는데

    - 커밋 옵션 -> 마지막 커밋 수정
    - 이력 변경 발생

  - stash: 변경사항을 킵해두고, 아직 커밋은 안 함

    - 가령, 작업 중에 다른 브랜치로 옮기고 싶은 상황
    - 작업소는 깨끗해야 한다
    - 지우기도 아까울 때
    - 일단 잠깐 서랍에 넣어두는 것
    - 옵션을 통해 새로 만든 파일 등도 담아 둘 수 있다
    - 스태시 적용 기능

  - reset: 예전 커밋으로 브랜치를 되돌리고 싶음

    - 리셉 옵션
    - 메인을 이 커밋으로 초기화
    - 하드 리셋: 변경 사항 날려버림

  - revert: 이 커밋의 변경사항을 되돌리고 싶어요: 보수적 버전

    - 공용 브랜치 등은 히스토리 건드리면 안 됨
    - reset - force push는 영향을 주니 revert 쓰자
    - revert하는 푸시 작성

    - 공용은 리셋하지 마
    - 커밋 되돌리기

  - cherry-pick

    - 수정사항이 많은데 일부분만 머지하고 싶다면?

    - 특정 커밋만 체리픽하여 붙임

      

- 커밋 메시지 팁

  - 변경사항을 깨끗하게 쪼개고 간략하게 적음
  - 차근차근 정리하라

  - **선 커밋메세지 후 커밋도 유용**



- PR 양식
  - 주요변경사항: 해결 무넺
  - 관련 링크
  - 시급성
  - 중점적으로 봐야 할 부분



- 개념 비교
  - project
  - repo: local, remote
  - organization: 협업 단체, 팀, 단체 소유로 repo 만들고 싶다면 org 좋아



- 문답

  - 적극성이 중요
    - 단순 기술이 아니라, 협업, 새 문화 적용 등에서 주도성
    - 항상 고민하고 문제제기 하는 사람
  - mock api 제공으로 프론트 파트가 일 하기 쉽게 할 수 있게 하자!
  - 충돌을 피하기 위한 전략: 깃 플로우 등 참고
    - 한 PR의 크기를 최소화하라
  - 스타트업 등의 경우 미리 티타임 등으로 회사에 대해 알아보자

  - 브랜치는 무조건 이슈별로 따라!
    - 나눌 수 있는 만큼 나누는 것이 안전하다
    - 되돌아 갈 수 있을만큼 작으면서
    - 이해할 수 있을 만큼 추상단위
  - reset < revert

