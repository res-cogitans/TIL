---


---

<h1 id="스프링-핵심-원리---기본편김영한">스프링 핵심 원리 - 기본편(김영한)</h1>
<h2 id="객체-지향-설계와-스프링">객체 지향 설계와 스프링</h2>
<p><strong>E</strong>nterprise <strong>J</strong>ava <strong>B</strong>eans: 자바 표준 기술<br>
EJB는 다수의 기능을 지원했지만, 사용하기 복잡하고 어려웠으며, 성능이 느렸다. 심지어 값비쌌음.<br>
EJB의 복잡성으로 인해 <strong>P</strong>lain <strong>O</strong>ld <strong>J</strong>ava <strong>O</strong>bject가 등장하기도 함.<br>
EJB의 문제 해결을 위해 대두한 오픈 소스 기술들: <strong>스프링, 하이버네이트</strong></p>
<p><strong>스프링</strong></p>
<ul>
<li>EJB 컨테이너 대체</li>
<li>단순함</li>
<li>현재 사실상 표준 기술</li>
</ul>
<p><strong>하이버네이트(Hibernate)</strong></p>
<ul>
<li>EJB 엔티티빈 기술을 대체</li>
<li><strong>J</strong>ava <strong>P</strong>ersistence <strong>A</strong>PI의 새로운 표준을 정의<br>
EJB 엔티티빈 -&gt; 하이버네이트 -&gt; JPA(자바표준)</li>
<li>표준 인터페이스 JPA와 그 구현체 (주로) 하이버네이트, EclipseLink 등</li>
</ul>
<p>-&gt; 현대 자바 개발자에게 가장 중요한 두 기술: <strong>스프링, 하이버네이트</strong></p>
<hr>
<h3 id="스프링의-역사">스프링의 역사</h3>
<p><strong>Rod Johnson, “J2EE Design and Development”(2002)</strong></p>
<ul>
<li>EJB의 문제점 지적</li>
<li>EJB 없이 제작한 애플리케이션 예시, 스프링 핵심 개념, 기반 코드</li>
<li><strong>BeanFactory, ApplicationContext, POJO, 제어의 역전, 의존관계 주입(DI)</strong></li>
<li>Juergen Hoeller, Yann Caroff가 오픈소스 프로젝트 제안, 개발</li>
<li>J2EE(EJB)-겨울을 넘어서 새로운 시작이라는 의미로 스프링</li>
</ul>
<p><strong>릴리즈</strong></p>
<ul>
<li>2003, 1.0 - Xml 기반</li>
<li>2006, 2.0 - Xml 편의기능</li>
<li>2009, 3.0 - 자바 코드로 설정(스프링은 설정이 매우 난해했음)</li>
<li>2013, 4.0 - 자바8</li>
<li>2014, 스프링부트 1.0</li>
<li>2017, 5.0, 부트 2.0 -리엑티브 프로그래밍 지원(비동기 NumBlocking Node.js유사)</li>
<li>현재 5.2.x 부트 2.3x</li>
</ul>
<hr>
<h3 id="스프링이란">스프링이란?</h3>
<p>스프링은 단일 기술이 아니라 다수 기술의 모음</p>
<ul>
<li>핵심: 스프링 프레임워크, 스프링 부트</li>
<li>선택:
<ul>
<li>스프링 데이터: DB사용을 도움, ex) 스프링데이터 Jpa</li>
<li>스프링 세션</li>
<li>스프링 시큐리티</li>
<li>스프링 Rest Docs(API문서화, 테스트)</li>
<li>스프링 배치</li>
<li>스프링 클라우드</li>
<li>etc . . . (공식 사이트의 project 참조)</li>
</ul>
</li>
</ul>
<p><strong>스프링 프레임워크</strong></p>
<ul>
<li>핵심 기술: 스프링 DI 컨테이너, AOP, 이벤트, 기타</li>
<li>웹 기술: 스프링 MVC, 스프링 WebFlux</li>
<li>데이터 접근 기술: 트랜젝션, JDBC, ORM 지원, XML 지원</li>
<li>기술 통합: 캐시, 이메일, 원격접근, 스케줄링</li>
<li>테스트: 스프링 기반 테스트 지원</li>
<li>언어: 코틀린, 그루비</li>
<li>스프링 부트를 통해서 스프링 / 스프링 프레임워크의 기술들을 편리하게 사용 가능.</li>
</ul>
<p><strong>스프링 부트</strong></p>
<ul>
<li>단독 실행 가능한 스프링 애플리케이션을 쉽게 생성</li>
<li>Tomcat 같은 웹 서버를 내장, 별도의 웹 서버 설치 불필요.</li>
<li>손쉬운 빌드 구성을 위한 starter 종속성 제공(라이브러리 종속성 관리 build.gradle 참조)</li>
<li>스프링과 3rd party(외부) 라이브러리 자동 구성(버전당 써드파티 라이브러리 호환성 관리)</li>
<li>메트릭, 상태 확인, 외부 구성 같은 프로덕션 준비 기능 제공(모니터링 환경)</li>
<li>관례에 의한 간결한 설정(디폴트 설정 + 메뉴얼이 잘 되어있음)</li>
</ul>
<p><strong>스프링이라는 단어</strong></p>
<ul>
<li>스프링 DI 컨테이너 기술</li>
<li>스프링 프레임워크</li>
<li><strong>스프링 생태계 전체</strong></li>
</ul>
<p><strong>스프링의 제작 이유 - 핵심 개념</strong></p>
<ul>
<li><strong>자바</strong> 기반 프레임워크: <strong>객체 지향</strong></li>
<li>스프링은 <strong>좋은 객체 지향</strong> 애플리케이션 개발을 돕는 프레임워크</li>
<li>그것을 돕는 <strong>DI 컨테이너</strong></li>
</ul>
<hr>
<h3 id="좋은-객체-지향-프로그래밍">좋은 객체 지향 프로그래밍</h3>
<p><strong>다형성(Polymorphism)</strong></p>
<ul>
<li>객체지향 프로그래밍이 컴포넌트 교체 등으로 인해 <strong>단순, 유연, 변경 용이</strong>하게 만드는 이유.</li>
<li>자동차의 예시) 개별 자동차들이 자동차라는 인터페이스의 구현체이기에, 무한히 확장 가능하며(<strong>확장 가능한 설계</strong>), 운전자에게 영향을 주지 않아도 됨.</li>
<li><strong>역할</strong>과 <strong>구현</strong>을 분리해서 가능한 것!</li>
</ul>
<p><strong>역할과 구현의 분리</strong></p>
<ul>
<li>클라이언트는
<ul>
<li>대상의 역할(인터페이스)만 알면 된다.</li>
<li>대상의 내부 구조를 몰라도 된다.</li>
<li>대상의 내부 구조가 변경되어도 영향 받지 않는다.</li>
<li>구현 대상 자체가 변경되어도 영향 받지 않는다.<br>
-&gt; <strong>추상화, 캡슐화</strong> 등과도 일맥상통.</li>
</ul>
</li>
<li>자바 언어의 다형성:
<ul>
<li>역할 = 인터페이스</li>
<li>구현 = 구현 클래스, 객체</li>
</ul>
</li>
<li>객체 설계시 역할과 구현의 분리</li>
<li>역할(인터페이스)를 먼저 부여하고, 그것의 구현체를 만들어야.</li>
</ul>
<p><strong>객체의 협력</strong></p>
<ul>
<li>객체는 협력관계
<ul>
<li>클라이언트는 요청, 서버는 응답</li>
<li>이런 구조는 중첩될 수도 있다.</li>
</ul>
</li>
</ul>
<p><strong>자바 언어의 다형성 - 오버라이딩</strong></p>
<ul>
<li>다형성으로 인터페이스를 구현한 객체를 실행 시점에 유연하게 변경 가능</li>
<li>클래스 상속 관계에서도 마찬가지</li>
<li>예시: 클라이언트는 MemberRepository에 의존(인식), 이 MemberRepository 자리에 여러 구현체들로 역할 구현 가능.</li>
<li><strong>클라이언트를 변경하지 않고, 서버의 구현 기능을 유연하게 변경 가능.</strong></li>
</ul>
<p><strong>한계점</strong></p>
<ul>
<li>역할 자체의 변화가 발생시 큰 변경 발생.<br>
-&gt; <strong>인터페이스의 설계 중요성</strong></li>
</ul>
<p><strong>스프링과 객체 지향</strong></p>
<ul>
<li><strong>제어의 역전(IoC), 의존관계 주입(DI)</strong> 등은 <strong>다형성</strong>을 활용하여 <strong>역할</strong>과 <strong>구현</strong>을 편리하게 다룰 수 있게 지원함.</li>
</ul>
<hr>
<h3 id="solid-원칙">SOLID 원칙</h3>
<p><strong>SOLID</strong>: 로버트 마틴(클린 코드)가 정리한 좋은 객체 지향 설계의 5원칙</p>
<ul>
<li><strong>SRP</strong>: 단일 책임 원칙(<strong>S</strong>ingle <strong>R</strong>esponsibility <strong>P</strong>rinciple)</li>
<li><strong>OCP</strong>: 개방-폐쇄 원칙(<strong>O</strong>pen/<strong>C</strong>losed <strong>P</strong>rinciple)</li>
<li><strong>LSP</strong>: 리스코프 치환 원칙(<strong>L</strong>iskov <strong>S</strong>ubstitution <strong>P</strong>rinciple)</li>
<li><strong>ISP</strong>: 인터페이스 분리 원칙(<strong>I</strong>nterface <strong>S</strong>egregation <strong>P</strong>rinciple)</li>
<li><strong>DIP</strong>: 의존관계 분리 원칙(<strong>D</strong>ependency <strong>I</strong>nversion <strong>P</strong>rinciple)</li>
</ul>
<p><strong>SRP 단일 책임 원칙</strong>(<strong>S</strong>ingle <strong>R</strong>esponsibility <strong>P</strong>rinciple)</p>
<ul>
<li>한 클래스는 하나의 책임만 가져야 한다.</li>
<li>이 범위를 적절히 조절하는 것이 핵심.</li>
<li>중요한 기준은 <strong>변경</strong>, 변경 시 파급 효과가 적다면 이 원칙을 잘 따른 것.</li>
</ul>
<p><strong>OCP 개방-폐쇄 원칙</strong>(<strong>O</strong>pen/<strong>C</strong>losed <strong>P</strong>rinciple)</p>
<ul>
<li>소프트웨어 요소는 <strong>확장에는 열려</strong> 있으나 <strong>변경에는 닫혀</strong> 있어야 한다.</li>
<li>인터페이스의 새 구현체를 만들어서 새로운 기능을 구현<br>
<strong>문제점</strong>
<ul>
<li>MemberService 클라이언트가 구현 클래스를 직접 선택</li>
<li><code>MemberRepository m = new MemoryMemberRepository();</code>에서</li>
<li><code>MemberRepository m = new JdbcMemberRepository();</code>로 변경</li>
<li>구현 객체를 변경하려면 클라이언트 코드를 변경해야 함.</li>
<li><strong>다형성을 사용했으나, OCP를 지키지 못함.</strong></li>
<li><strong>해결</strong>:객체를 생성하고, 연관관계를 맺어주는 별도의 조립, 설정자가 필요.<br>
-&gt; <strong>스프링의 필요</strong></li>
</ul>
</li>
</ul>
<p><strong>LSP 리스코프 치환 원칙</strong>(<strong>L</strong>iskov <strong>S</strong>ubstitution <strong>P</strong>rinciple)</p>
<ul>
<li>프로그램의 객체는 프로그램의 정확성을 깨뜨리지 않으면서 하위 타입의 인스턴스로 바꿀 수 있어야 한다.</li>
<li>다형성에서 하위 클래스는 인터페이스 규약을 다 지켜야 한다는 것.</li>
</ul>
<p><strong>ISP 인터페이스 분리 원칙</strong>(<strong>I</strong>nterface <strong>S</strong>egregation <strong>P</strong>rinciple)</p>
<ul>
<li>특정 클라이언트를 위한 인터페이스 여러 개가 범용 인터페이스 하나보다 낫다. -&gt; <strong>쪼개라</strong></li>
<li>인터페이스가 명확해지고 대체 가능성이 높아진다.</li>
</ul>
<p><strong>DIP 의존관계 분리 원칙</strong>(<strong>D</strong>ependency <strong>I</strong>nversion <strong>P</strong>rinciple)</p>
<ul>
<li><strong>"프로그래머는 추상화에 의존해야지 구체화에 의존하면 안 된다."</strong></li>
<li>구현에 의존하지 말고 <strong>역할(인터페이스)에 의존</strong>하라, 구현이 아닌 역할을 알게끔 하라.<br>
<strong>위반사례</strong>
<ul>
<li>클래스 MemberService의 코드 <code>MemberRepository m = new MemoryMemberRepository();</code>의 경우</li>
<li>인터페이스 MemberRepository 뿐만 아니라 MemoryMemberRepository 구현체에도 동시 의존한다.</li>
<li>클라이언트가 구현 클래스를 직접 선택하고 있음.</li>
</ul>
</li>
</ul>
<p><strong>정리</strong><br>
다형성 만으로는</p>
<ul>
<li>클라이언트 코드 변경 없이 구현체의 유연한 교체가 불가능하다!</li>
<li>OCP, DIP를 지킬 수 없다.<br>
-&gt; 스프링의 필요성</li>
</ul>
<hr>
<h3 id="객체-지향-설계와-스프링-1">객체 지향 설계와 스프링</h3>
<p>스프링이 <strong>다형성 + OCP, DIP</strong> 가능하게 지원하는 수단</p>
<ul>
<li>DI: 의존관계, 의존성 주입</li>
<li>DI 컨테이너 제공</li>
<li>순수 자바로 객체지향적 개발을 하려면 생산성이 낮음<br>
-&gt; 스프링 프레임워크의 등장.</li>
</ul>
<p><strong>정리</strong></p>
<ul>
<li>설계와 구현의 분리</li>
<li><strong>이상적으로, 모든 설계에 인터페이스를 부여하라.</strong></li>
<li><strong>현실적으로, 인터페이스 남발은 추상화 비용(생산성)이 발생</strong><br>
때문에 기능 확장 가능성이 없을 때는 구체적 클래스를 사용하고 필요할 때 리팩토링으로 인터페이스를 도입하는 방법을 고려.</li>
</ul>
<hr>
<h2 id="스프링-핵심-원리-이해1---예제-만들기">스프링 핵심 원리 이해1 - 예제 만들기</h2>
<ul>
<li>
<p>회원 도메인 협력관계: 기획자들도 볼 수 있는 레벨</p>
</li>
<li>
<p>클라이언트 -&gt; 회원 서비스 -&gt; 회원 저장소</p>
</li>
<li>
<p>회원 클래스 다이어그램(구체화) - 정적</p>
</li>
<li>
<p>회원 객체 다이어그램(실사용-인스턴스간 참조) - 동적</p>
</li>
<li>
<p>MMR =&gt; HashMap 대신 ConcurrentHashMap(동시성 이슈 대비)</p>
</li>
<li>
<p>MemberServiceImpl -&gt; 단일 구현체면 Impl식 작명</p>
</li>
<li>
<p>역할을 먼저 만들고, 구현체를 나중에 만듦 -&gt; 유연한 교체가 가능</p>
</li>
</ul>
<h2 id="스프링-핵심-원리-이해2---객체-지향-원리-적용">스프링 핵심 원리 이해2 - 객체 지향 원리 적용</h2>
<ul>
<li>@Test 아래의 @Displayname(String value) 어노테이션은 테스트시 제목표시</li>
<li>테스트에는 반대 케이스도 만들어야 한다.</li>
</ul>
<p>-&gt; 예제에서 DIP OCP 위반한다.<br>
-&gt; 인터페이스만 바라보게 하면 구현체가 없음. NPE<br>
-&gt; 외부에서 DI 해줘야함.</p>
<p>구현체가 다른 인터페이스 뿐만 아니라 그 구현체까지 바라보고 있음. <strong>관심사의 분리</strong>가 필요.</p>
<h3 id="appconfig">AppConfig</h3>
<p><strong>구현 객체를 생성하고 연결하는 책임</strong>을 갖는 별도의 설정 클래스</p>
<pre class=" language-java"><code class="prism  language-java"><span class="token keyword">package</span> logos<span class="token punctuation">.</span>springCore<span class="token punctuation">;</span>  
  
<span class="token keyword">import</span> logos<span class="token punctuation">.</span>springCore<span class="token punctuation">.</span>discount<span class="token punctuation">.</span>RateDiscountPolicy<span class="token punctuation">;</span>  
<span class="token keyword">import</span> logos<span class="token punctuation">.</span>springCore<span class="token punctuation">.</span>member<span class="token punctuation">.</span>MemberService<span class="token punctuation">;</span>  
<span class="token keyword">import</span> logos<span class="token punctuation">.</span>springCore<span class="token punctuation">.</span>member<span class="token punctuation">.</span>MemberServiceImpl<span class="token punctuation">;</span>  
<span class="token keyword">import</span> logos<span class="token punctuation">.</span>springCore<span class="token punctuation">.</span>member<span class="token punctuation">.</span>MemoryMemberRepository<span class="token punctuation">;</span>  
<span class="token keyword">import</span> logos<span class="token punctuation">.</span>springCore<span class="token punctuation">.</span>order<span class="token punctuation">.</span>OrderService<span class="token punctuation">;</span>  
<span class="token keyword">import</span> logos<span class="token punctuation">.</span>springCore<span class="token punctuation">.</span>order<span class="token punctuation">.</span>OrderServiceImpl<span class="token punctuation">;</span>  
  
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">AppConfig</span> <span class="token punctuation">{</span>  
  
    <span class="token punctuation">;</span>  
  
 <span class="token keyword">public</span> MemberService <span class="token function">memberService</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  
        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">MemberServiceImpl</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">MemoryMemberRepository</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
  <span class="token punctuation">}</span>  
  
    <span class="token keyword">public</span> OrderService <span class="token function">orderService</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  
        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">OrderServiceImpl</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">MemoryMemberRepository</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">RateDiscountPolicy</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
  <span class="token punctuation">}</span>
  
<span class="token punctuation">}</span>
</code></pre>
<p>생성 객체 인스턴스의 참조(레퍼런스)를 생성자를 통해서 주입(연결) 해준다. (<strong>생성자 주입</strong>)<br>
-&gt; <strong>DIP 완성, 관심사의 분리</strong></p>
<ul>
<li>리팩토링을 통해 의존관계, 어떤 구현체 사용하는지를 잘 드러내줘야 한다.</li>
<li>사용 영역과 구성 영역(AppConfig)의 분리</li>
</ul>
<h3 id="ioc-di-컨테이너">IOC, DI, 컨테이너</h3>
<dl>
<dt><strong>제어의 역전 IoC(Inversion of Control)</strong></dt>
<dd>AppConfig가 제어흐름을 통제</dd>
</dl>
<p><strong>프레임워크 vs 라이브러리</strong></p>
<ul>
<li>프레임워크가 내가 작성한 코드를 제어하고, 대신 실행하면 그것은 프레임워크가 맞다. (JUnit)</li>
<li>반면에 내가 작성한 코드가 직접 제어의 흐름을 담당한다면 그것은 라이브러리다.</li>
</ul>
<dl>
<dt><strong>의존관계 주입Dependency Injection</strong></dt>
<dd>정적인 클래스 의존 관계와 동적 객체 의존관계를 구별하라.<br>
정적인 클래스 의존관계만으로는 실제로 어떤 구현체가 주입되는지는 모름, 이는 런타임에 외부에서 실제 구현객체를 생성, 전달하여 그 관계가 연결된다.</dd>
<dt><strong>IoC 컨테이너, DI 컨테이너</strong></dt>
<dd>위의 AppConfig처럼 객체를 생성, 관리, 의존관계 연결해주는 것.<br>
최근에는 DI에 초점을 맞춰 DI컨테이너라 주로 말함.<br>
혹은 어셈블러, 오브젝트 팩토리 등으로 불리기도 함.</dd>
</dl>
<h2 id="스프링-컨테이너와-스프링-빈">스프링 컨테이너와 스프링 빈</h2>
<h3 id="스프링-컨테이너">스프링 컨테이너</h3>
<ul>
<li>ApplicationContext / BeanFactory를 스프링 컨테이너라 한다.</li>
<li>기존에는 개발자가 AppConfig를 이용, 객체 생성, DI했지만 이제 스프링 컨테이너를 통해 사용한다.</li>
<li>스프링 컨테이너는 @Configuration이 붙은 AppConfig를 설정(구성) 정보로 사용한다. 여기서 @Bean이라 적힌 메소드를 모두 호출, 반환된 객체를 스프링 컨테이너에 등록한다. 이 등록된 객체를 스프링 빈이라 한다.</li>
<li>객체를 직접 생성, 호출이 아니라 스프링 컨테이너를 이용해서 찾아야 함. 스프링 빈은 <code>applicationContext.getBean()</code>메서드 사용해서 찾을 수 있다.</li>
<li>스프링 컨테이너는 XML기반으로 혹은 어노테이션 기반 자바 설정 클래스로 만들 수 있다.</li>
<li>ApplicationContext는 인터페이스, AnnotationConfigApplicationContext는 그것의 구현체.</li>
</ul>
<ol>
<li>스프링 컨테이너 생성</li>
</ol>
<table border="2"><tbody><tr><td>스프링 컨테이너<table border="2"><tbody><tr><td>스프링 빈 저장소</td></tr><tr><td>빈 이름</td><td>빈 객체</td></tr></tbody></table></td></tr></tbody></table>
<ol start="2">
<li>구성 정보 활용(AppConfig.class가 구성 정보로 지정)</li>
<li>스프링 빈 등록(컨테이너가 설정 클래스 정보로 스프링 빈을 등록)
<ul>
<li>주의! 빈 이름은 직접 부여할 수도 있지만, 빈 이름은 항상 다른 이름을 부여해야 한다! 무시되게나, 덮거나, 오류 발생 가능.</li>
</ul>
</li>
<li>스프링 빈 의존관계 설정-준비</li>
<li>스프링 빈 의존관계 설정-완료(설정관계를 참고해서 의존관계를 주입)</li>
</ol>
<ul>
<li>스프링은 빈을 생성하고, 의존관계를 주입하는 단계가 나누어져 있음. 단 자바 코드로 스프링 빈은 등록하면 빈 생성과 의존관계 주입이 동시 처리됨.</li>
</ul>
<h3 id="스프링-빈-조회">스프링 빈 조회</h3>
<ul>
<li>동일한 타입의 빈이 둘 이상일 때 오류가 발생한다(<code>NoUniqueBeanDefinitionException</code>). 이 경우 빈 이름을 지정해야.</li>
<li>부모 타입 스프링 빈 조회시 자식 타입 모두가 조회된다.</li>
</ul>
<h3 id="beanfactory와-applicationcontext">BeanFactory와 ApplicationContext</h3>
<p>Interface <strong>BeanFactory</strong><br>
Interface <strong>ApplicationContext</strong> implements BeanFactory<br>
class <strong>AnnotationConfigApplicationContext</strong> implements ApplicationContext</p>
<p><strong>BeanFactory</strong></p>
<ul>
<li>스프링 컨테이너의 최상위 인터페이스</li>
<li>스프링 빈을 관리, 조회</li>
<li><code>getBean()</code>을 제공</li>
</ul>
<p><strong>ApplicationContext</strong></p>
<ul>
<li>BeanFactory 기능을 모두 상속</li>
<li>부가기능들: implements MessageSource, EnvironmentCapable, ApplicationEventPublisher, ResourceLoader (모두 Interface)
<ul>
<li>MessageSource: 국제화 기능(접속위치에 따라 다른 언어로 출력)</li>
<li>EnvironmentCapable: 환경변수로 로컬, 개발, 운영등을 구분해서 처리, 환경별로 어떤 DB 연결할지 등</li>
<li>ApplicationEventPublisher: 이벤트를 발행하고 구독하는 모델 지원</li>
<li>ResourceLoader: 편리한 리소스 조회</li>
</ul>
</li>
</ul>
<h3 id="xml로-설정">XML로 설정</h3>
<ul>
<li>스프링 컨테이너는 자바 코드, XML, Groovy 등 여러 방식의 설정 정보를 받아들일 수 있다.</li>
<li>AnnotationConfigApplicationContext implements ApplicationContext -&gt; AppConfig.class</li>
<li>GenericXmlApplicationContext implements ApplicationContext -&gt; appConfig.xml</li>
<li>???ApplicationContext implements ApplicationContext -&gt; appConfig.??? (임의의 구현)</li>
<li>Xml의 경우, 스프링부트의 사용으로 인해 사용이 거의 없어짐. 단 컴파일 없이 빈 설정 정보를 변경할 수 있다는 장점이 있다.</li>
</ul>
<h3 id="스프링-빈-설정-메타-정보---beandefinition">스프링 빈 설정 메타 정보 - BeanDefinition</h3>
<ul>
<li>
<p>빈 설정 메타정보라 한다.</p>
</li>
<li>
<p>이 또한 추상화를 이용한 것이다.</p>
</li>
<li>
<p>스프링 컨테이너 -&gt; BeanDefinition 을 바라보고 있음,<br>
스프링 컨테이너는 BeanDefinition을 AppConfig.class가 구현하는지, appConfig.xml이 구현하는지 알 필요 없음.</p>
</li>
<li>
<p>ApplicationContext의 구현 AnnotationConfigApplicationContext의 AnnotatedBeanDefinitionReader가 AppConfig.class를 읽어서 BeanDefinition(빈 메타정보)를 생성한다.</p>
</li>
<li>
<p>BeanDefinition을 직접 생성해서 스프링 컨테이너에 등록할 수도 있다.</p>
</li>
<li>
<p>xml은 Bean을 직접 등록하는 방식</p>
</li>
<li>
<p>java코드 사용은 Bean을 팩토리 매서드로 등록하는 방식</p>
</li>
</ul>
<hr>
<h2 id="싱글톤-컨테이너">싱글톤 컨테이너</h2>
<h3 id="웹-어플리케이션과-싱글톤">웹 어플리케이션과 싱글톤</h3>
<ul>
<li>스프링을 적용하지 않은 DI컨테이너의 경우 요청 시마다 새로운 객체를 생성한다.<br>
-&gt; <strong>메모리 낭비</strong> 심함</li>
<li>스프링은 기본적으로 온라인 서비스 기술 지원이 주력이기에<br>
스프링 애플리케이션은 대부분 웹 어플리케이션이다.<br>
동시 요청이 잦은 웹 어플리케이션의 특성상 이는 치명적이다.<br>
-&gt; 이 해결을 위해 <strong>싱글톤</strong> 적용이 필요하다.</li>
</ul>
<h3 id="싱글톤-패턴">싱글톤 패턴</h3>
<ul>
<li>클래스의 인스턴스가 1개만 생성되게끔 보장하는 디자인 패턴</li>
<li>인스턴스를 2개 이상 생성하지 못하게 막음.</li>
<li>private 생성자를 이용, 외부에서 new 불가하게 함.</li>
</ul>
<pre class=" language-java"><code class="prism  language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SingletonService</span> <span class="token punctuation">{</span>  
  
    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> SingletonService instance <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SingletonService</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
 <span class="token keyword">public</span> <span class="token keyword">static</span> SingletonService <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  
        <span class="token keyword">return</span> instance<span class="token punctuation">;</span>  
  <span class="token punctuation">}</span>  
  
    <span class="token keyword">private</span> <span class="token function">SingletonService</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  
          
    <span class="token punctuation">}</span>  
      
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">logic</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"싱글톤 객체 로직 호출"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
  <span class="token punctuation">}</span>  
<span class="token punctuation">}</span>
</code></pre>
<ul>
<li>이 싱글톤 구현방식은 객체를 미리 생성해두는 가장 단순하고 안전한 방식이다.</li>
<li>static 영역에 객체 instance를 미리 하나 생성해서 올려둔다.</li>
<li>이 객체 인스턴스가 필요하면 오직 getInstatnce() 메소드를 통해서만 조회할 수 있음. 항상 같은 인스턴스 반환.</li>
<li>생성자를 private로 막아서 외부에서 new 키워드로 객체 인스턴스가 생성되는 것을 막음.</li>
<li>Same == 참조가 같음</li>
<li>Equal equals()와 같음</li>
<li>스프링 컨테이너는 기본적으로 객체를 싱글톤으로 관리한다.</li>
</ul>
<p><strong>싱글톤 패턴의 문제점</strong></p>
<ul>
<li>패턴 자체를 구현하기 위한 코드</li>
<li>의존관계상 클라이언트가 구체 클래스에 의존하게 됨<br>
-&gt; DIP를 위반, 때문에 OCP 위반 가능성 높아짐</li>
<li>유연한 테스트가 어려움</li>
<li>내부 속성을 변경하거나 초기화하기 어려움</li>
<li>private 생성자 사용으로 인해 자식 클래스를 만들기 어려움</li>
<li>즉, <strong>유연성이 떨어짐</strong></li>
<li>안티패턴으로 불리기도.</li>
</ul>
<h3 id="싱글톤-컨테이너-1">싱글톤 컨테이너</h3>
<ul>
<li>스프링 컨테이너는 객체를 싱글톤 방식으로 관리하며,<br>
이러한 객체 생성, 관리하는 기능을 <strong>싱글톤 레지스트리</strong>라 한다.</li>
<li>스프링 컨테이너는
<ul>
<li>싱글톤 패턴 구현을 위한 복잡한 코드가 불필요</li>
<li>DIP, OCP, 테스트, private 생성자로부터 자유롭게 싱글톤 사용 가능</li>
</ul>
</li>
</ul>
<h3 id="싱글톤-방식의-주의점">싱글톤 방식의 주의점</h3>
<p><strong>무상태(Stateless)로 설계해야 한다!</strong> 스프링 컨테이너를 이용한 싱글톤 방식에도 모두 해당하는 사항이다.</p>
<ul>
<li>특정 클라이언트에 의존적인 필드가 있어선 안 된다.</li>
<li>특정 클라이언트가 값을 변경할 수 있는 필드가 있으면 안 된다.</li>
<li>가급적 읽기만 가능해야 한다.</li>
<li>필드 대신에 자바에서 공유되지 않는, 지역변수, 파라미터, ThreadLocal 등을 사용해야 한다.</li>
<li>스프링 빈의 필드에 공유 값을 설정하면 큰 장애가 발생할 수 있다.</li>
</ul>
<pre class=" language-java"><code class="prism  language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">StatefulService</span> <span class="token punctuation">{</span>  
  
    <span class="token keyword">private</span> <span class="token keyword">int</span> price<span class="token punctuation">;</span> <span class="token comment">// 상태를 유지하는 필드  </span>
  
  <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">order</span><span class="token punctuation">(</span>String name<span class="token punctuation">,</span> <span class="token keyword">int</span> price<span class="token punctuation">)</span> <span class="token punctuation">{</span>  
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"name= "</span> <span class="token operator">+</span> name <span class="token operator">+</span> <span class="token string">" price= "</span> <span class="token operator">+</span> price<span class="token punctuation">)</span><span class="token punctuation">;</span>  
 <span class="token keyword">this</span><span class="token punctuation">.</span>price<span class="token operator">=</span>price<span class="token punctuation">;</span> <span class="token comment">// 문제 지점!  </span>
  <span class="token punctuation">}</span>  
  
    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">getPrice</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  
        <span class="token keyword">return</span> price<span class="token punctuation">;</span>  
  <span class="token punctuation">}</span>  
<span class="token punctuation">}</span>
</code></pre>
<p>일 때,</p>
<pre class=" language-java"><code class="prism  language-java"><span class="token keyword">class</span> <span class="token class-name">StatefulServiceTest</span> <span class="token punctuation">{</span>  
  
    <span class="token annotation punctuation">@Test</span>  
 <span class="token annotation punctuation">@DisplayName</span><span class="token punctuation">(</span><span class="token string">"stateful 경우"</span><span class="token punctuation">)</span>  
    <span class="token keyword">void</span> <span class="token function">statefulServiceSingleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  
        AnnotationConfigApplicationContext ac <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">AnnotationConfigApplicationContext</span><span class="token punctuation">(</span>TestConfig<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
  StatefulService statefulService1 <span class="token operator">=</span> ac<span class="token punctuation">.</span><span class="token function">getBean</span><span class="token punctuation">(</span>StatefulService<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
  StatefulService statefulService2 <span class="token operator">=</span> ac<span class="token punctuation">.</span><span class="token function">getBean</span><span class="token punctuation">(</span>StatefulService<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
  
  <span class="token comment">// ThreadA: userA가 10000 주문, userB가 20000 주문  </span>
  statefulService1<span class="token punctuation">.</span><span class="token function">order</span><span class="token punctuation">(</span><span class="token string">"userA"</span><span class="token punctuation">,</span> <span class="token number">10000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
  statefulService2<span class="token punctuation">.</span><span class="token function">order</span><span class="token punctuation">(</span><span class="token string">"userB"</span><span class="token punctuation">,</span> <span class="token number">20000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
  <span class="token comment">//statefulService's price 10000-&gt;20000  </span>
  
 <span class="token comment">// ThreadA: userA가 주문 금액 조회  </span>
  <span class="token function">assertThat</span><span class="token punctuation">(</span>statefulService1<span class="token punctuation">.</span><span class="token function">getPrice</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">isEqualTo</span><span class="token punctuation">(</span><span class="token number">20000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
  <span class="token punctuation">}</span>  
  
    <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">TestConfig</span> <span class="token punctuation">{</span>  
  
        <span class="token annotation punctuation">@Bean</span>  
  <span class="token keyword">public</span> StatefulService <span class="token function">statefulService</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  
            <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">StatefulService</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
  <span class="token punctuation">}</span>  
    <span class="token punctuation">}</span>  
<span class="token punctuation">}</span>
</code></pre>
<ul>
<li>실무의 경우 Thread 할당으로 인해 더 복잡해진다.</li>
<li>stateService의 price 필드는 공유되는 필드인데, 특정 클라이언트가 값을 변경했다.<br>
-&gt; <strong>반드시 무상태로 설계하라!</strong></li>
</ul>
<pre class=" language-java"><code class="prism  language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">StatefulService</span> <span class="token punctuation">{</span>  

  <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">order</span><span class="token punctuation">(</span>String name<span class="token punctuation">,</span> <span class="token keyword">int</span> price<span class="token punctuation">)</span> <span class="token punctuation">{</span>  
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"name= "</span> <span class="token operator">+</span> name <span class="token operator">+</span> <span class="token string">" price= "</span> <span class="token operator">+</span> price<span class="token punctuation">)</span><span class="token punctuation">;</span>  
 <span class="token keyword">return</span> price<span class="token punctuation">;</span>  
  <span class="token punctuation">}</span>  
<span class="token punctuation">}</span>
</code></pre>
<p>와</p>
<pre class=" language-java"><code class="prism  language-java">    <span class="token annotation punctuation">@Test</span>  
 <span class="token annotation punctuation">@DisplayName</span><span class="token punctuation">(</span><span class="token string">"stateful 경우"</span><span class="token punctuation">)</span>  
    <span class="token keyword">void</span> <span class="token function">statefulServiceSingleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  
        AnnotationConfigApplicationContext ac <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">AnnotationConfigApplicationContext</span><span class="token punctuation">(</span>TestConfig<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
  StatefulService statefulService1 <span class="token operator">=</span> ac<span class="token punctuation">.</span><span class="token function">getBean</span><span class="token punctuation">(</span>StatefulService<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
  StatefulService statefulService2 <span class="token operator">=</span> ac<span class="token punctuation">.</span><span class="token function">getBean</span><span class="token punctuation">(</span>StatefulService<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
  
  <span class="token comment">// ThreadA: userA가 10000 주문, userB가 20000 주문  </span>
  <span class="token keyword">int</span> userAPrice <span class="token operator">=</span> statefulService1<span class="token punctuation">.</span><span class="token function">order</span><span class="token punctuation">(</span><span class="token string">"userA"</span><span class="token punctuation">,</span> <span class="token number">10000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
 <span class="token keyword">int</span> userBPrice <span class="token operator">=</span> statefulService2<span class="token punctuation">.</span><span class="token function">order</span><span class="token punctuation">(</span><span class="token string">"userB"</span><span class="token punctuation">,</span> <span class="token number">20000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
  
 <span class="token comment">// ThreadA: userA가 주문 금액 조회  </span>
  <span class="token function">assertThat</span><span class="token punctuation">(</span>userAPrice<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">isEqualTo</span><span class="token punctuation">(</span><span class="token number">10000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
  <span class="token punctuation">}</span>  
  
    <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">TestConfig</span> <span class="token punctuation">{</span>  
  
        <span class="token annotation punctuation">@Bean</span>  
  <span class="token keyword">public</span> StatefulService <span class="token function">statefulService</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  
            <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">StatefulService</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
  <span class="token punctuation">}</span>  
    <span class="token punctuation">}</span>  
<span class="token punctuation">}</span>
</code></pre>
<p>경우 문제 해결된다.</p>
<h3 id="configuration과-싱글톤">@Configuration과 싱글톤</h3>
<pre class=" language-java"><code class="prism  language-java"><span class="token annotation punctuation">@Configuration</span>  
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">AppConfig</span> <span class="token punctuation">{</span>  
  
    <span class="token annotation punctuation">@Bean</span>  
  <span class="token keyword">public</span> MemberService <span class="token function">memberService</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  
        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">MemberServiceImpl</span><span class="token punctuation">(</span><span class="token function">memberRepository</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
  <span class="token punctuation">}</span>  
  
    <span class="token annotation punctuation">@Bean</span>  
  <span class="token keyword">public</span> MemberRepository <span class="token function">memberRepository</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  
        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">MemoryMemberRepository</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
  <span class="token punctuation">}</span>  
  
    <span class="token annotation punctuation">@Bean</span>  
  <span class="token keyword">public</span> OrderService <span class="token function">orderService</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  
        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">OrderServiceImpl</span><span class="token punctuation">(</span><span class="token function">memberRepository</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">discountPolicy</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
  <span class="token punctuation">}</span>  
  
    <span class="token annotation punctuation">@Bean</span>  
  <span class="token keyword">public</span> DiscountPolicy <span class="token function">discountPolicy</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  
        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">RateDiscountPolicy</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
  <span class="token punctuation">}</span>  
  
<span class="token punctuation">}</span>
</code></pre>
<p>에서<br>
@Bean memberService() -&gt; new MemoryMemberRepository()<br>
@Bean orderService() -&gt; new MemoryMemberRepository()<br>
인데, new 키워드가 두 번 나오는데 싱글톤이 깨지지 않을까?</p>
<blockquote>
<p>Call AppConfig.memberService<br>
Call AppConfig.memberRepository<br>
Call AppConfig.orderService<br>
Call AppConfig.discountPolicy</p>
</blockquote>
<p>깨지지 않으며, memberRepository 호출이 단 한번만 이루어졌음을 확인할 수 있다.</p>
<h3 id="configuration과-바이트코드-조작">@Configuration과 바이트코드 조작</h3>
<p>스프링은 자바 코드 자체를 조작하기는 어렵다. 그럼에도 위 사례에서 3회 호출이 이뤄져야 하는 것을 한 번만 이뤄지게 해서 싱글톤을 유지하게 한 방법은,<br>
스프링이 클래스의 <strong>바이트코드를 조작</strong>하는 라이브러리를 사용해서 이루어졌다.</p>
<p>AnnotationConfigApplicationContext ac를 생성한 이후에 Appconfig 클래스를 조회하니</p>
<blockquote>
<p><code>bean= class logos.springCore.AppConfig$$EnhancerBySpringCGLIB$$9911dcb1</code></p>
</blockquote>
<p>순수 클래스가 아니라 $$EnhancerBySpringCGLIB. . . 이 붙어서 출력된다.<br>
이는 스프링이 CGLIB이라는 바이트코드 조작 라이브러리를 조작하여 AppConfig 클래스를 상속받은 임의의 다른 클래스를 만들고 그것을 스프링 빈으로 등록한 것이다.<br>
@Bean이 붙은 메소드마다 이미 빈이 존재한다면 그것을 반환하고 없다면 기존 코드를 사용하여 생성, 등록, 반환하는 코드가 동적 생성된 것이다.</p>
<p>@Configuration이 빠질 경우 빈에 등록은 되지만 memberRepository 호출은 3회 이루어지고, 싱글톤은 깨진다.<br>
또한 이 경우 MemberService나 OrderService의 memberRepository는 빈에 등록되지 않는다.</p>
<hr>
<h2 id="컴포넌트-스캔">컴포넌트 스캔</h2>
<h3 id="컴포넌트-스캔과-의존관계-자동-주입-시작하기">컴포넌트 스캔과 의존관계 자동 주입 시작하기</h3>
<p>위와 같이 <code>@Bean</code>이나 xml의 <code>&lt;bean&gt;</code>을 이용하여 스프링 빈을 일일히 등록하는 것은 그 수가 많아질수록 비효율적이다. 다음과 같은 방법을 이용하면 된다:<br>
<strong>컴포넌트 스캔</strong> 기능을 이용하면 <strong>설정 정보 없이 스프링 빈을 등록</strong>할 수 있다.<br>
<strong><code>@Autowired</code></strong> 이용하여 <strong>의존관계 자동 주입</strong>이 가능하다.</p>
<p><strong>1. 컴포넌트 스캔 <code>@ComponentScan</code> <code>Component</code></strong></p>
<pre class=" language-java"><code class="prism  language-java"><span class="token annotation punctuation">@Configuration</span>  
<span class="token annotation punctuation">@ComponentScan</span><span class="token punctuation">(</span>  
        excludeFilters <span class="token operator">=</span> <span class="token annotation punctuation">@ComponentScan</span><span class="token punctuation">.</span><span class="token function">Filter</span><span class="token punctuation">(</span>type <span class="token operator">=</span> FilterType<span class="token punctuation">.</span>ANNOTATION<span class="token punctuation">,</span> classes <span class="token operator">=</span> Configuration<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span>  
<span class="token punctuation">)</span>  
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">AutoAppConfig</span> <span class="token punctuation">{</span>  
<span class="token punctuation">}</span>
</code></pre>
<p><strong><code>@ComponentScan</code></strong> 은 <strong><code>@Component</code></strong> 애노테이션이 붙은 클래스를 스캔, 스프링 빈으로 등록한다.<br>
기존 방식과 달리 <code>@Bean</code>으로 아무것도 등록할 필요 없음.</p>
<ul>
<li><code>@ComponentScan</code>은 <code>@Component</code>가 붙은 모든 클래스를 스프링 빈으로 등록</li>
<li>빈 기본이름은 클래스명, 단 첫 글자는 소문자</li>
<li>이름을 지정하고 싶다면 <code>@Component("name")</code> 방식으로 지정</li>
</ul>
<p><strong>2. 의존관계 자동 주입 <code>@AutoWired</code></strong></p>
<pre class=" language-java"><code class="prism  language-java"><span class="token annotation punctuation">@Component</span>  
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">OrderServiceImpl</span> <span class="token keyword">implements</span> <span class="token class-name">OrderService</span> <span class="token punctuation">{</span>  
  
    <span class="token keyword">private</span> <span class="token keyword">final</span> MemberRepository memberRepository<span class="token punctuation">;</span>  
 <span class="token keyword">private</span> <span class="token keyword">final</span> DiscountPolicy discountPolicy<span class="token punctuation">;</span>  
  
  <span class="token annotation punctuation">@Autowired</span>  
  <span class="token keyword">public</span> <span class="token function">OrderServiceImpl</span><span class="token punctuation">(</span>MemberRepository memberRepository<span class="token punctuation">,</span> DiscountPolicy discountPolicy<span class="token punctuation">)</span> <span class="token punctuation">{</span>  
        <span class="token keyword">this</span><span class="token punctuation">.</span>memberRepository <span class="token operator">=</span> memberRepository<span class="token punctuation">;</span>  
 <span class="token keyword">this</span><span class="token punctuation">.</span>discountPolicy <span class="token operator">=</span> discountPolicy<span class="token punctuation">;</span>  
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<p>Config파일에서 수동적으로 빈 등록 안하기에, 의존관계는 위와 같은 방식으로 주입해 준다.</p>
<ul>
<li>생성자에 <code>@Autowired</code> 입력시 스프링 컨테이너가 자동으로 해당 스프링 빈을 찾아서 주입</li>
<li>타입이 같은 빈을 찾아서 주입: `getBean(MemberRepository.class)'와 동일한 방식</li>
<li>생성자 패러미터가 많아도 무관</li>
</ul>
<h3 id="탐색-위치와-기본-스캔-대상">탐색 위치와 기본 스캔 대상</h3>
<p><strong>1. 탐색 위치</strong></p>
<pre class=" language-java"><code class="prism  language-java"><span class="token annotation punctuation">@ComponentScan</span><span class="token punctuation">(</span>  
        basePackages <span class="token operator">=</span>  <span class="token string">"logos.springCore.member"</span><span class="token punctuation">,</span>  
<span class="token punctuation">)</span>
</code></pre>
<ul>
<li><strong><code>basePackages</code></strong> = “경로”`로 탐색 위치 지정, 해당 패키지 포함 하위 패키지를 모두 탐색</li>
<li><strong><code>basePackages</code></strong><code>= "logos.springCore.member", "logos.springCore.Order"</code> 식으로 여러 시작 위치를 지정 가능</li>
<li><strong><code>basePakageClasses</code></strong><code>= AutoAppConfig.class</code> 해당 클래스의 패키지를 탐색 위치로 지정</li>
<li><strong>지정하지 않았을 경우</strong> <code>@ComponentScan</code> 붙은 설정 정보 클래스의 패키지가 시작 위치</li>
<li><strong>추천 방식</strong>: 위와 같은 지정을 하지 않고 설정 정보 클래스를 프로젝트 시작 루트에 둔다.<br>
프로젝트 메인 설정 정보는 프로젝트를 대표하는 정보라는 점에서도 추천할 만함.<br>
또한 <strong>스프링 부트</strong>의 경우, 시작 정보인 <strong><code>@SpringBootApplication</code></strong> 을 프로젝트 시작 루트 위치에 두는 것이 관례이며, 이 설정 내부에 <strong><code>@ComponentScan</code></strong> 이 들어있음.</li>
</ul>
<p><strong>2. 컴포넌트 스캔 기본 대상</strong></p>
<ul>
<li>
<p>컴포넌트 스캔은 <code>@Component</code>뿐만 아니라 다음 또한 대상에 포함한다: (<code>@Component</code>를 가지고 있기에)</p>
<ul>
<li><code>@Component</code>: 컴포넌트 스캔에서 사용</li>
<li><code>@Controller</code>: 스프링 MVC 컨트롤러에서 사용</li>
<li><code>@Service</code>: 스프링 비즈니스 로직에서 사용</li>
<li><code>@Repository</code>: 스프링 데이터 접근 계층에서 사용</li>
<li><code>@Configuration</code>: 스프링 설정 정보에서 사용</li>
</ul>
</li>
<li>
<p><strong>주의</strong>: 애노테이션에는 <strong>상속관계가 없다.</strong> 애노테이션이 애노테이션을 들고 있는 것은 <strong>자바가 아니라 스프링이 지원하는 것</strong>이다.</p>
</li>
<li>
<p><strong>애노테이션 부가 기능</strong>: 컴포넌트 스캔 외에 지원하는 기능</p>
<ul>
<li><code>@Controller</code>: 스프링 MVC 컨트롤러로 인식</li>
<li><code>@Repository</code>: 스프링 데이터 접근 계층으로 인식하고, 데이터 계층의 예외를 스프링 예외로 변환</li>
<li><code>@Configuration</code>: 스프링 설정 정보로 인식, 스프링 빈이 싱글톤을 유지하도록 추가 처리함</li>
<li><code>@Service</code>: 특별한 처리는 없으나 개발자 간 정보 전달에 용이</li>
</ul>
</li>
<li>
<p>참고, <code>useDefaultFilters</code> 옵션은 기본으로 켜져 있는데, 이를 끌 경우 기본 스캔 대상 제거됨.</p>
</li>
</ul>
<h3 id="필터">필터</h3>
<ul>
<li><strong><code>includeFilters</code></strong>: 컴포넌트 스캔 대상을 추가로 지정</li>
<li><strong><code>excludeFilters</code></strong>: 컴포넌트 스캔 제외할 대상 지정</li>
<li><strong>FilterType</strong> 옵션
<ul>
<li>ANNOTATION:기본값, 애노테이션을 인식해서 동작<br>
기본값이기에 <code>includeFilters = @Filter(type = FilterType.ANNOTATION, classes = MyIncludeComponent.class)</code>의  <strong><code>FilterType.ANNOTATION</code></strong> 은 생략 가능하다.</li>
<li>ASSIGNABLE_TYPE: 지정한 타입과 자식 타입을 인식해서 동작
<ul>
<li>ex) <code>logos.springCore.Member</code></li>
</ul>
</li>
<li>ASPECTJ: AspectJ 패턴 사용
<ul>
<li>ex) <code>logos.springCore. .*Service+</code></li>
</ul>
</li>
<li>REGEX: 정규 표현식
<ul>
<li>ex) <code>\logos\springCore\.Default.*</code></li>
</ul>
</li>
<li>CUSTOM: <code>TypeFilter</code>라는 인터페이스를 구현해서 처리
<ul>
<li>ex) <code>logos.springCore.MyTypeFilter</code></li>
</ul>
</li>
</ul>
</li>
<li>가급적이면 스프링 부트에서 기본으로 제공하는 컴포넌트 스캔 설정에 맞추자.
<ul>
<li><code>@Component</code>로 충분, <code>includeFilters</code>사용 적음.</li>
</ul>
</li>
</ul>
<h3 id="중복-등록과-충돌">중복 등록과 충돌</h3>
<ol>
<li>자동 빈 등록 vs 자동 빈 등록: <code>ConflictingBeanDefinitionException</code></li>
<li>수동 빈 등록 vs 자동 빈 등록:  수동 빈 등록이 우선순위를 가지며, 자동 빈을 수동 빈이 오버라이드 한다.
<ul>
<li>그러나 이것을 의도하지 않았을 경우 예기치 못한 버그가 발생하기 쉽다.</li>
<li>때문에 현재 스프링부트에서는 오류 발생하게 했다.</li>
<li>수동으로 사용 가능하게 하고 싶다면 <code>resources\application.properties</code>에 <code>spring.main.allow-bean-definition-overriding=true</code>로 변경해주면 되지만 권장하지 않는다.</li>
</ul>
</li>
</ol>
<hr>
<h2 id="의존관계-자동-주입">의존관계 자동 주입</h2>
<h3 id="다양한-의존관계-주입-방법">다양한 의존관계 주입 방법</h3>
<ol>
<li>생성자 주입</li>
<li>수정자 주입(setter)</li>
<li>필드 주입</li>
<li>일반 메소드 주입</li>
</ol>
<p><strong>1. 생성자 주입</strong></p>
<pre class=" language-java"><code class="prism  language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">OrderServiceImpl</span> <span class="token keyword">implements</span> <span class="token class-name">OrderService</span> <span class="token punctuation">{</span>
	<span class="token keyword">private</span> <span class="token keyword">final</span> MemberRepository memberRepository<span class="token punctuation">;</span>  
	<span class="token keyword">private</span> <span class="token keyword">final</span> DiscountPolicy discountPolicy<span class="token punctuation">;</span>

	<span class="token annotation punctuation">@Autowired</span>  
	<span class="token keyword">public</span> <span class="token function">OrderServiceImpl</span><span class="token punctuation">(</span>MemberRepository memberRepository<span class="token punctuation">,</span> DiscountPolicy discountPolicy<span class="token punctuation">)</span> <span class="token punctuation">{</span>  
		<span class="token keyword">this</span><span class="token punctuation">.</span>memberRepository <span class="token operator">=</span> memberRepository<span class="token punctuation">;</span>  
		<span class="token keyword">this</span><span class="token punctuation">.</span>discountPolicy <span class="token operator">=</span> discountPolicy<span class="token punctuation">;</span>  
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<ul>
<li>생성자 호출시첨에 딱 1회만 호출되는 것이 보장된다.</li>
<li>**불변, 필수(final) **의존관계에 사용
<ul>
<li>제약사항으로 인해서 원하지 않는 변화를 방지할 수 있음.</li>
</ul>
</li>
<li><strong>생성자가 단 하나만 있다면 <code>@Autowired</code>가 없어도 자동주입된다. (Spring Bean)</strong>
<ul>
<li>생성자 오버로딩 시에는 무조건 <code>@Autowired</code>가 있어야만 DI 가능하다.</li>
</ul>
</li>
</ul>
<p><strong>2. 수정자 주입(setter)</strong></p>
<pre class=" language-java"><code class="prism  language-java">	<span class="token annotation punctuation">@Autowired</span>  
	<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setMemberRepository</span><span class="token punctuation">(</span>MemberRepository memberRepository<span class="token punctuation">)</span> <span class="token punctuation">{</span>  
		<span class="token keyword">this</span><span class="token punctuation">.</span>memberRepository <span class="token operator">=</span> memberRepository<span class="token punctuation">;</span>  
	<span class="token punctuation">}</span>
</code></pre>
<ul>
<li>setter(자바빈 프로퍼티 규약)에 <code>@Autowired</code> 이용.</li>
<li>크게 보면 스프링의 <strong>Life Cycle</strong>은 두 단계로 나뉘어 있다:<br>
1. 빈을 생성하는 단계<br>
2. 의존관계를 주입하는 단계
<ul>
<li>생성자 주입을 사용한 경우 특이하게 빈 생성과 주입이 함께 일어난다.</li>
</ul>
</li>
<li><strong>선택, 변경</strong> 가능성이 있는 의존관계에 사용
<ul>
<li><code>@Autowired(required = false)</code>: 기본값은 true, 의존관계 주입이 필수적이지 않게 함으로써 주입이 불가능한 상황에도 생성자가 동작하게 한다. (true의 경우 오류 발생)</li>
</ul>
</li>
</ul>
<p><strong>3. 필드 주입</strong></p>
<pre class=" language-java"><code class="prism  language-java"><span class="token annotation punctuation">@Component</span>  
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">OrderServiceImpl</span> <span class="token keyword">implements</span> <span class="token class-name">OrderService</span> <span class="token punctuation">{</span>  
  
    <span class="token annotation punctuation">@Autowired</span> <span class="token keyword">private</span> MemberRepository memberRepository<span class="token punctuation">;</span>  
	<span class="token annotation punctuation">@Autowired</span> <span class="token keyword">private</span> DiscountPolicy discountPolicy<span class="token punctuation">;</span>
 <span class="token punctuation">}</span>
</code></pre>
<ul>
<li><strong>안티 패턴</strong>: 코드는 간결하지만 외부에서 변경이 불가, 테스트 하기 힘들다.
<ul>
<li>순수 자바 코드를 이용한 테스트 힘듦, DI 프레임워크가 항시 필요해짐</li>
</ul>
</li>
<li>실제 코드와 상관없는 테스트 코드나, <code>@Configuration</code> 정도에는 사용될 수는 있음. (어차피 스프링 사용하니까)</li>
</ul>
<p><strong>4. 일반 메서드 주입</strong></p>
<pre class=" language-java"><code class="prism  language-java"><span class="token annotation punctuation">@Autowired</span>
<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">init</span><span class="token punctuation">(</span>MemberRepository memberRepository<span class="token punctuation">,</span> DiscountPolicy discountPolicy<span class="token punctuation">)</span> <span class="token punctuation">{</span>  
	<span class="token keyword">this</span><span class="token punctuation">.</span>memberRepository <span class="token operator">=</span> memberRepository<span class="token punctuation">;</span>
	<span class="token keyword">this</span><span class="token punctuation">.</span>discountPolicy <span class="token operator">=</span> dicountPolicy<span class="token punctuation">;</span>	
<span class="token punctuation">}</span>
</code></pre>
<ul>
<li>한 번에 여러 필드를 주입받을 수 있다. (원리만 따지면 수정자와 다를 바 없음)</li>
</ul>
<p><strong>마지막으로, 이 모든 의존관계 주입은 당연히 스프링 컨테이너가 관리하는 스프링 빈이어야 동작!</strong></p>
<h3 id="옵션-처리">옵션 처리</h3>
<p>주입할 스프링 빈이 없어도 동작해야 할 경우<br>
- <code>@Autowired(required = false)</code>: 주입할 대상이 없을 경우 생성자 자체가 호출 안 됨.??<br>
- <code>org.springframework.lang.@Nullable</code> : 자동 주입할 대상이 없으면 null이 입력된다.<br>
- <code>Optional&lt;&gt;</code> : 자동 주입할 대상이 없으면 Optional.empty 가 입력된다.</p>
<h3 id="생성자-주입을-선택해라">생성자 주입을 선택해라!</h3>
<ul>
<li>최근에는 DI프레임워크 다수가 생성자 주입을 권장, 그 이유는:
<ul>
<li><strong>불변</strong>: 동적으로 의존 변경하는 일이 거의 없기에 의도치 않은 변경을 막기 위함</li>
<li><strong>누락</strong>: 프레임워크 없이 순수한 자바 코드를 단위 테스트 하는 경우
<ul>
<li>만약 수정자를 이용해 주입할 경우 테스트 코드를 짤 때 명확하게 DI 관계를 인지하기 힘듦. 별도의 수정자 호출이 필요.</li>
<li>하지만 생성자 호출의 경우 테스트 코드 작성시 생성자만으로 작성 가능하며, 생성자 호출 시 인자 요구로 인해 더 명확.</li>
</ul>
</li>
<li><strong>final 키워드</strong>: 값 지정을 안하는 실수도 막을 수 있음.
<ul>
<li>생성자 이외의 모든 DI 방식은 생성자 이후에 호출되기에, final 사용 불가!</li>
</ul>
</li>
</ul>
</li>
<li>즉, <strong>프레임워크에 의존하지 않고 순수한 자바 언어의 특징을 살릴 수 있음.</strong></li>
<li>필수 값이 아닌 경우 수정자 주입을 추가적으로 부여하라. <strong>(생성자 주입과 동시사용 가능)</strong></li>
</ul>
<h3 id="롬복과-최신-트렌드">롬복과 최신 트렌드</h3>
<ul>
<li>다수의 경우 final, 생성자 주입을 사용하는데, 이 경우 코드 량이 늘어남:<br>
-&gt; <strong>롬복(Lombok)</strong> 필요</li>
</ul>
<pre class=" language-java"><code class="prism  language-java"><span class="token annotation punctuation">@Component</span>  
<span class="token annotation punctuation">@RequiredArgsConstructor</span>  
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">OrderServiceImpl</span> <span class="token keyword">implements</span> <span class="token class-name">OrderService</span> <span class="token punctuation">{</span>  
  
    <span class="token keyword">private</span> <span class="token keyword">final</span> MemberRepository memberRepository<span class="token punctuation">;</span>  
    <span class="token keyword">private</span> <span class="token keyword">final</span> DiscountPolicy discountPolicy<span class="token punctuation">;</span>
 <span class="token punctuation">}</span>
</code></pre>
<ul>
<li>final이 붙어 있어서 바로 의존성 주입했다.</li>
<li>생성자를 하나만 사용하고, <code>@Autowired</code>는 생략, 롬복 라이브러리의 <code>@RequiredArgsConstructor</code>이용하여 더 단순화.</li>
<li>애노테이션 만으로 Getter/Setter/ToString/Constructor 등을 간편하게 사용 가능해짐.</li>
<li>자바의 AnnotationProcessor를 이용하여 컴파일 시점에 생성자 코드를 자동으로 생성해줌.</li>
</ul>
<h3 id="조회-빈이-2개-이상일-때-해결방식-autowired-필드명-qualifier-primary">조회 빈이 2개 이상일 때 해결방식: <code>@Autowired</code> 필드명, <code>@Qualifier</code>, <code>@Primary</code></h3>
<ul>
<li><code>@Autowired</code>는 타입으로 조회, 그렇다면 자동 주입시에 만약 동일 인터페이스에 대한 두 구현체에 <code>@Component</code>붙을 경우에는 문제 발생한다. 다음 3가지 해결법이 있다:</li>
</ul>
<ol>
<li><code>@Autowired</code> 필드명 매칭</li>
<li>@Qualifier` 사용</li>
<li><code>@Primary</code> 사용</li>
</ol>
<p><strong>1. <code>@Autowired</code> 필드명 매칭</strong>: 동일 타입 여러 개가 있을 경우 파라미터, 필드명으로 추가 매칭<br>
<strong>2. <code>@Qualifier</code> 사용</strong>:</p>
<pre class=" language-java"><code class="prism  language-java">  <span class="token annotation punctuation">@Autowired</span>  
  <span class="token keyword">public</span> <span class="token function">OrderServiceImpl</span><span class="token punctuation">(</span>MemberRepository memberRepository<span class="token punctuation">,</span> <span class="token annotation punctuation">@Qualifier</span><span class="token punctuation">(</span><span class="token string">"mainDiscountPolicy"</span><span class="token punctuation">)</span> DiscountPolicy discountPolicy<span class="token punctuation">)</span> <span class="token punctuation">{</span>  
      <span class="token keyword">this</span><span class="token punctuation">.</span>memberRepository <span class="token operator">=</span> memberRepository<span class="token punctuation">;</span>  
      <span class="token keyword">this</span><span class="token punctuation">.</span>discountPolicy <span class="token operator">=</span> discountPolicy<span class="token punctuation">;</span>  
<span class="token punctuation">}</span>
</code></pre>
<ol>
<li><code>@Qualifier</code>끼리 매칭:  <code>@Qualifier("mainDiscountPolicy")</code>등 이름을 붙여서 구분한다.</li>
<li>빈 이름 매칭: 1) 실패시 추가적으로 “mainDiscountPolicy” 이름의 스프링 빈을 찾음. (하지만 헷갈림)</li>
<li><code>NoSuchBeanDefinitionException</code></li>
</ol>
<p><strong>3. <code>@Primary</code> 사용</strong>: 우선순위를 지정하는 방식</p>
<pre class=" language-java"><code class="prism  language-java"><span class="token annotation punctuation">@Component</span>  
<span class="token annotation punctuation">@Primary</span>  
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">RateDiscountPolicy</span> <span class="token keyword">implements</span> <span class="token class-name">DiscountPolicy</span> <span class="token punctuation">{</span><span class="token punctuation">.</span> <span class="token punctuation">.</span> <span class="token punctuation">.</span><span class="token punctuation">}</span>
</code></pre>
<p>사용 빈도가 높은 곳에만 등록하는 것이 유용하다.</p>
<p><strong>활용</strong></p>
<ol>
<li>사용빈도가 매우 높은 빈에는 <code>@Primary</code>사용하여 추가적인 코드를 최소화한다.</li>
<li>사용빈도가 낮은 빈은 별도로 <code>@Qualifier</code>사용하여 필요한 경우만 처리해준다.<br>
-&gt; 가장 깔끔한 해결</li>
<li><code>@Primary</code>와 <code>@Qualifier</code>가 겹치는 상황이라면, <code>@Qualifier</code>가 우선권을 가짐-자동 방식보다 수동방식이, 넓은 선택 영역보다는 좁게 지정된 바가 더 우선순위가 높다는 기본 원칙과 같음.</li>
</ol>
<h3 id="애노테이션-직접-만들기">애노테이션 직접 만들기</h3>
<p><code>@Qualifier("mainDiscountPolicy)</code>와 같은 방식이면 타입 체크가 불가함</p>
<pre class=" language-java"><code class="prism  language-java"><span class="token annotation punctuation">@Target</span><span class="token punctuation">(</span><span class="token punctuation">{</span>ElementType<span class="token punctuation">.</span>FIELD<span class="token punctuation">,</span> ElementType<span class="token punctuation">.</span>METHOD<span class="token punctuation">,</span> ElementType<span class="token punctuation">.</span>PARAMETER<span class="token punctuation">,</span> ElementType<span class="token punctuation">.</span>TYPE<span class="token punctuation">,</span> ElementType<span class="token punctuation">.</span>ANNOTATION_TYPE<span class="token punctuation">}</span><span class="token punctuation">)</span>  
<span class="token annotation punctuation">@Retention</span><span class="token punctuation">(</span>RetentionPolicy<span class="token punctuation">.</span>RUNTIME<span class="token punctuation">)</span>  
<span class="token annotation punctuation">@Inherited</span>  
<span class="token annotation punctuation">@Documented</span>  
<span class="token annotation punctuation">@Qualifier</span><span class="token punctuation">(</span><span class="token string">"mainDiscountPolicy"</span><span class="token punctuation">)</span>  
<span class="token keyword">public</span> @<span class="token keyword">interface</span> <span class="token class-name">MainDiscountPolicy</span> <span class="token punctuation">{</span>  
<span class="token punctuation">}</span>
</code></pre>
<p>그리고</p>
<pre class=" language-java"><code class="prism  language-java">  <span class="token annotation punctuation">@Autowired</span>  
  <span class="token keyword">public</span> <span class="token function">OrderServiceImpl</span><span class="token punctuation">(</span>MemberRepository memberRepository<span class="token punctuation">,</span> <span class="token annotation punctuation">@MainDiscountPolicy</span> DiscountPolicy discountPolicy<span class="token punctuation">)</span> <span class="token punctuation">{</span>  
      <span class="token keyword">this</span><span class="token punctuation">.</span>memberRepository <span class="token operator">=</span> memberRepository<span class="token punctuation">;</span>  
 <span class="token keyword">this</span><span class="token punctuation">.</span>discountPolicy <span class="token operator">=</span> discountPolicy<span class="token punctuation">;</span>  
<span class="token punctuation">}</span>
</code></pre>
<p>이런 방식으로 명확하게 타입 체크가 가능하다.<br>
이 외의 다른 애노테이션들도 재정의 가능하지만, 기본 제공을 사용하는 것이 유지보수에 적절하다.</p>
<h3 id="조회한-빈이-모두-필요할때-list-map">조회한 빈이 모두 필요할때, List, Map</h3>
<p>해당 타입의 모든 빈이 필요한 경우:</p>
<ul>
<li>Ex) 클라이언트가 할인 서비스의 종류를 선택할 수 있는 경우: 전략 패턴</li>
</ul>
<pre class=" language-java"><code class="prism  language-java">  
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">AllBeanTest</span> <span class="token punctuation">{</span>  
  
    <span class="token annotation punctuation">@Test</span>  
    <span class="token annotation punctuation">@DisplayName</span><span class="token punctuation">(</span><span class="token string">"모든 빈을 찾기"</span><span class="token punctuation">)</span>  
    <span class="token keyword">void</span> <span class="token function">findAllBean</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  
    AnnotationConfigApplicationContext ac <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">AnnotationConfigApplicationContext</span><span class="token punctuation">(</span>AutoAppConfig<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span> DiscountService<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
  
    DiscountService discountService <span class="token operator">=</span> ac<span class="token punctuation">.</span><span class="token function">getBean</span><span class="token punctuation">(</span>DiscountService<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
    Member member <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Member</span><span class="token punctuation">(</span>1L<span class="token punctuation">,</span> <span class="token string">"userA"</span><span class="token punctuation">,</span> Grade<span class="token punctuation">.</span>VIP<span class="token punctuation">)</span><span class="token punctuation">;</span>  
    <span class="token keyword">int</span> discountPrice <span class="token operator">=</span> discountService<span class="token punctuation">.</span><span class="token function">discount</span><span class="token punctuation">(</span>member<span class="token punctuation">,</span> <span class="token number">10000</span><span class="token punctuation">,</span> <span class="token string">"fixDiscountPolicy"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
  
    <span class="token function">assertThat</span><span class="token punctuation">(</span><span class="token punctuation">(</span>discountService<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">isInstanceOf</span><span class="token punctuation">(</span>DiscountService<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
    <span class="token function">assertThat</span><span class="token punctuation">(</span>discountPrice<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">isEqualTo</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
  
    <span class="token keyword">int</span> rateDiscountPrice <span class="token operator">=</span> discountService<span class="token punctuation">.</span><span class="token function">discount</span><span class="token punctuation">(</span>member<span class="token punctuation">,</span> <span class="token number">20000</span><span class="token punctuation">,</span> <span class="token string">"rateDiscountPolicy"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
    <span class="token function">assertThat</span><span class="token punctuation">(</span>rateDiscountPrice<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">isEqualTo</span><span class="token punctuation">(</span><span class="token number">2000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
  <span class="token punctuation">}</span>  
  
    <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">DiscountService</span> <span class="token punctuation">{</span>  
        <span class="token keyword">private</span> <span class="token keyword">final</span> Map<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> DiscountPolicy<span class="token operator">&gt;</span> policyMap<span class="token punctuation">;</span>  
        <span class="token keyword">private</span> <span class="token keyword">final</span> List<span class="token operator">&lt;</span>DiscountPolicy<span class="token operator">&gt;</span> policies<span class="token punctuation">;</span>  
  
         <span class="token annotation punctuation">@Autowired</span>  
        <span class="token keyword">public</span> <span class="token function">DiscountService</span> <span class="token punctuation">(</span>Map<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> DiscountPolicy<span class="token operator">&gt;</span> policyMap<span class="token punctuation">,</span> List<span class="token operator">&lt;</span>DiscountPolicy<span class="token operator">&gt;</span> policies<span class="token punctuation">)</span> <span class="token punctuation">{</span>  
            <span class="token keyword">this</span><span class="token punctuation">.</span>policyMap <span class="token operator">=</span> policyMap<span class="token punctuation">;</span>  
            <span class="token keyword">this</span><span class="token punctuation">.</span>policies <span class="token operator">=</span> policies<span class="token punctuation">;</span>  
            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"policyMap = "</span> <span class="token operator">+</span> policyMap<span class="token punctuation">)</span><span class="token punctuation">;</span>  
            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"policies = "</span> <span class="token operator">+</span> policies<span class="token punctuation">)</span><span class="token punctuation">;</span>  
  <span class="token punctuation">}</span>  
  
        <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">discount</span><span class="token punctuation">(</span>Member member<span class="token punctuation">,</span> <span class="token keyword">int</span> price<span class="token punctuation">,</span> String discountCode<span class="token punctuation">)</span> <span class="token punctuation">{</span>  
        DiscountPolicy discountPolicy <span class="token operator">=</span> policyMap<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>discountCode<span class="token punctuation">)</span><span class="token punctuation">;</span>  
       <span class="token keyword">return</span> discountPolicy<span class="token punctuation">.</span><span class="token function">discount</span><span class="token punctuation">(</span>member<span class="token punctuation">,</span> price<span class="token punctuation">)</span><span class="token punctuation">;</span>  
       <span class="token punctuation">}</span>  
    <span class="token punctuation">}</span>  
<span class="token punctuation">}</span>
</code></pre>
<h3 id="자동-수동의-올바른-실무-운영-기준">자동, 수동의 올바른 실무 운영 기준</h3>
<ul>
<li>
<p><strong>기본은 컴포넌트 스캔을 이용한 자동 등록</strong>: 갈수록 자동적 방식이 선호됨. 생산성 증가</p>
<ul>
<li>자동 빈 등록 방식으로도 OCP, DIP 준수할 수 있음.</li>
</ul>
</li>
<li>
<p><strong>수동 빈 등록을 사용해야 할 경우</strong>: 애플리케이션을 두 로직으로 크게 나누면:</p>
<ul>
<li><strong>업무 로직</strong>: 웹을 지원하는 컨트롤러, 핵심 비즈니스 로직이 있는 서비스, 데이터 계층 로직을 처리하는 리포지토리. 비즈니스 요구사항 개발에 따라 추가, 변동.</li>
<li><strong>기술 지원 로직</strong>: 기술적 문제, AOP를 처리할 때 사용. 업무 로직 지원을 위한 하부, 공통 기술</li>
<li>업무 로직의 경우 수가 많으며, 일정한 패턴이 많기에 자동 기능이 유리하다. 문제 발생시에도 파악이 쉬운 편이다.</li>
<li>기술 지원 로직의 경우 수는 적지만, 공통적 처리 등이 많기에 그 영향이 광범위하다. 문제 발생을 파악하기도 힘들기 때문에 <strong>수동 빈 등록 등으로 명확하게 드러내는 편이 유리</strong>하다.</li>
</ul>
</li>
<li>
<p>단, 업무 로직에서 다형성을 적극 활용하는 경우 별도의 설정 정보로 만들고 등록한다면 일목요연하게 파악하기 쉽다. 만일 자동등록을 사용할 경우 패키지로 묶어서 파악을 도와야 한다. (위에서 <code>DiscountPolicyConfig</code>가 그 예)</p>
</li>
<li>
<p>스프링과 스프링부트가 자동 등록하는 빈들의 경우 예외. 그것들은 스프링의 의도대로 사용하는 것이 좋음. 내가 직접 등록한 스프링 빈에 등록할 경우에는 수동으로 하자.</p>
</li>
</ul>
<hr>
<h2 id="빈-생명주기-콜백">빈 생명주기 콜백</h2>
<h3 id="빈-생명주기-콜백-시작">빈 생명주기 콜백 시작</h3>
<p>데이터베이스 커넥션 풀이나 네트워크 소켓처럼 시작 시점에 필요한 연결을 미리 하고, 종료 시점에 연결을 종료하는 작업을 위한 객체 초기화 및 종료작업을 진행하는 방식이다.</p>
<ul>
<li>스프링 빈의 이벤트 라이프사이클(일반적인 싱글톤의 경우)
<ul>
<li>스프링 컨테이너 생성 -&gt; 스프링 빈 생성 -&gt; 의존관계 주입 -&gt; 초기화 콜백 -&gt; 사용 -&gt; 소멸 전 콜백 -&gt; 스프링 종료</li>
</ul>
</li>
<li>객체의 생성과 초기화의 구별
<ul>
<li>객체생성: 메모리 할당, 파라미터 전달</li>
<li>초기화: 실제 동작 등 무거운 작업</li>
<li>둘을 명확하게 구별하는 것이 유지보수에 용이
<ul>
<li>가령 초기 작업이 들어오기 전 까지 동작을 지연하는 등의 방식이 가능</li>
</ul>
</li>
<li>초기화 작업이 내부 값 변경 수준으로 단순할 경우 생성자로 한 번에 처리하는 것을 고려</li>
<li>스프링의 빈 생명주기 콜백 지원방식 크게 3가지:
<ol>
<li>인터페이스InitializingBean, DisposableBean</li>
<li>설정 정보에 초기화 메서드, 종료 메서드 지정</li>
<li><code>@PostConstruct</code>, <code>@PreDestroy</code>애노테이션 지원</li>
</ol>
</li>
</ul>
</li>
</ul>
<h3 id="인터페이스initializingbean-disposablebean">인터페이스InitializingBean, DisposableBean</h3>
<p>NetworkClient 클래스</p>
<pre class=" language-java"><code class="prism  language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">NetworkClient</span> <span class="token keyword">implements</span> <span class="token class-name">InitializingBean</span><span class="token punctuation">,</span> DisposableBean <span class="token punctuation">{</span>  
  
    <span class="token keyword">private</span> String url<span class="token punctuation">;</span>  
  
 <span class="token keyword">public</span> <span class="token function">NetworkClient</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"생성자 호출, url = "</span> <span class="token operator">+</span> url<span class="token punctuation">)</span><span class="token punctuation">;</span>  
  <span class="token punctuation">}</span>  
  
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setUrl</span><span class="token punctuation">(</span>String url<span class="token punctuation">)</span> <span class="token punctuation">{</span>  
        <span class="token keyword">this</span><span class="token punctuation">.</span>url <span class="token operator">=</span> url<span class="token punctuation">;</span>  
  <span class="token punctuation">}</span>  
  
    <span class="token comment">// 서비스 시작시 호출  </span>
  <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">connect</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"connect, url = "</span> <span class="token operator">+</span> url<span class="token punctuation">)</span><span class="token punctuation">;</span>  
  <span class="token punctuation">}</span>  
  
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">call</span><span class="token punctuation">(</span>String message<span class="token punctuation">)</span> <span class="token punctuation">{</span>  
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"call, url = "</span> <span class="token operator">+</span> url <span class="token operator">+</span> <span class="token string">" message = "</span> <span class="token operator">+</span> message<span class="token punctuation">)</span><span class="token punctuation">;</span>  
  <span class="token punctuation">}</span>  
  
    <span class="token comment">// 서비스 종료시 호출  </span>
  <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">disconnect</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"close, url = "</span> <span class="token operator">+</span> url<span class="token punctuation">)</span><span class="token punctuation">;</span>  
  <span class="token punctuation">}</span>  
  
    <span class="token annotation punctuation">@Override</span>  
  <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">afterPropertiesSet</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token punctuation">{</span>  
        <span class="token function">connect</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
  <span class="token function">call</span><span class="token punctuation">(</span><span class="token string">"초기화 연결 메세지"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
  <span class="token punctuation">}</span>  
  
  
    <span class="token annotation punctuation">@Override</span>  
  <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">destroy</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token punctuation">{</span>  
        <span class="token function">disconnect</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
  <span class="token punctuation">}</span>  
<span class="token punctuation">}</span>
</code></pre>
<p>위를 사용한 테스트 코드</p>
<pre class=" language-java"><code class="prism  language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">BeanLifeCycleTest</span> <span class="token punctuation">{</span>  
  
    <span class="token annotation punctuation">@Test</span>  
  <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">lifeCycleTest</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  
        ConfigurableApplicationContext ac <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">AnnotationConfigApplicationContext</span><span class="token punctuation">(</span>LifeCycleConfig<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
  NetworkClient client <span class="token operator">=</span> ac<span class="token punctuation">.</span><span class="token function">getBean</span><span class="token punctuation">(</span>NetworkClient<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
  ac<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
  <span class="token punctuation">}</span>  
  
    <span class="token annotation punctuation">@Configuration</span>  
  <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">LifeCycleConfig</span> <span class="token punctuation">{</span>  
  
        <span class="token annotation punctuation">@Bean</span>  
  <span class="token keyword">public</span> NetworkClient <span class="token function">networkClient</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  
            NetworkClient networkClient <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">NetworkClient</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
  networkClient<span class="token punctuation">.</span><span class="token function">setUrl</span><span class="token punctuation">(</span><span class="token string">"http://hello-spring.dev"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
 <span class="token keyword">return</span> networkClient<span class="token punctuation">;</span>  
  <span class="token punctuation">}</span>  
    <span class="token punctuation">}</span>  
<span class="token punctuation">}</span>
</code></pre>
<ul>
<li>
<p><code>implements InitializingBean, DisposableBean</code></p>
<ul>
<li><code>public void afterPropertiesSet() throws Exception {}</code></li>
<li><code>public void destroy() throws Exception {}</code></li>
<li>각각을 오버라이드 해서 사용한다: 빈 생성 이후, 소멸 전 호출된다.</li>
</ul>
</li>
<li>
<p>초기화, 소멸 인터페이스의 단점(오래된 방식: 2003)</p>
<ul>
<li>스프링 전용 인터페이스: 애노테이션 레벨이 아닌, 인터페이스 레벨로 가져올 때는 부담스러움</li>
<li>초기화, 소멸 메서드의 이름을 변경할 수 없음</li>
<li>내가 코드를 고칠 수 없는 외부 라이브러에 적용할 수는 없음</li>
</ul>
</li>
</ul>
<h3 id="빈-등록-초기화-소멸-메서드">빈 등록 초기화, 소멸 메서드</h3>
<p><code>@Bean(initMethod = "init", destroyMethod = "close"</code>와 같은 방식으로 지정</p>
<pre class=" language-java"><code class="prism  language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">NetworkClient</span> <span class="token punctuation">{</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
   <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">init</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"NetworkClient.init"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
  <span class="token function">connect</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
  <span class="token function">call</span><span class="token punctuation">(</span><span class="token string">"초기화 연결 메세지"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
  <span class="token punctuation">}</span>  
  
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"NetworkClient.close"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
  <span class="token function">disconnect</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
  <span class="token punctuation">}</span>  
<span class="token punctuation">}</span>
</code></pre>
<p>init과 close 메서드 정의</p>
<ul>
<li>특징
<ul>
<li>메서드 이름을 자유롭게 설정 가능</li>
<li>스프링 빈이 스프링 코드에 의존하지 않음</li>
<li>코드가 아니라 설정 정보를 사용하기에 외부 라이브러리에도 초기화 종료 메서드를 적용가능.</li>
</ul>
</li>
<li>이 방식으로 등록할 경우 특별한 기능이 있음
<ul>
<li>라이브러리는 대부분 <code>close</code>나 <code>shutdown</code> 이름의 종료 메서드를 사용</li>
<li><code>@Bean</code>의 <code>destroyMethod</code>는 기본값이 <code>(inferred)</code>인데 이는 <code>close</code>나 <code>shutdown</code>이라는 이름의 메서드를 자동으로 호출한다.</li>
<li>직접 빈으로 등록할 경우 따로 적어주지 않아도 가능</li>
<li><code>destroyMethod=""</code>로 추론 기능을 사용 안 할 수 있다.</li>
</ul>
</li>
</ul>
<h3 id="postconstruct-predestroy애노테이션">3. <code>@PostConstruct</code>, <code>@PreDestroy</code>애노테이션</h3>
<ul>
<li>스프링에서 권고하는 방식</li>
<li><code>@PostConstruct</code>, <code>PreDestroy</code>붙여서 사용</li>
<li><code>import javax.annotation.PostConstruct;</code> JSR:250 자바표준. 스프링 외 컨테이너 사용시에도 사용 가능</li>
<li>컴포넌트 스캔과 잘 맞음</li>
<li>단 외부 라이브러리에는 적용하지 못함</li>
<li>정리: 일반적으로는
<ul>
<li><code>@PostConstruct</code>, <code>PreDestroy</code>사용하고,</li>
<li>코드를 고칠 수 없는 외부 라이브러리의 경우 <code>@Bean(initMethod = "init", destroyMethod = "close"</code>사용하라.</li>
</ul>
</li>
</ul>
<hr>
<h2 id="빈-스코프">빈 스코프</h2>
<h3 id="빈-스코프란">빈 스코프란?</h3>
<ul>
<li><strong>스코프</strong>: 빈이 존재할 수 있는 범위</li>
<li>스프링이 지원하는 스코프
<ul>
<li><strong>싱글톤</strong>: 기본 스코프, 스프링 컨테이너의 시작 ~ 종료</li>
<li><strong>프로토타입</strong>: 빈 생성, 의존관계 주입까지만</li>
<li><strong>웹 관련 스코프</strong>
<ul>
<li><strong>request</strong>: 요청이 들어오고 나갈 때까지</li>
<li><strong>session</strong>: 웹세션이 생성되고 종료될 때까지</li>
<li><strong>application</strong>: 웹 서블릿 컨텍스와 같은 범위로 유지</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="프로토타입-스코프">프로토타입 스코프</h3>
<ul>
<li>프로토타입 빈을 스프링 컨테이너에 요청하면 컨테이너는 항상 새로운 인스턴스를 생성, DI, 반환한다.</li>
<li>프로토타입 빈의 관리 책임은 호출 클라이언트가 갖는다.</li>
<li>때문에 <code>@PreDestroy</code> 등 호출 안 된다. 각 빈 별로 호출이 필요하다.</li>
</ul>
<h3 id="프로토타입-스코프와-싱글톤-빈-함께-사용할-시-문제점">프로토타입 스코프와 싱글톤 빈 함께 사용할 시 문제점</h3>
<ul>
<li>싱글톤 빈 내에 DI된 프로토타입 빈의 경우 싱글톤처럼 동작하게 된다.</li>
<li>스프링 컨테이너 생성과 동시에 싱글톤 빈이 생성되는데, 싱글톤 빈은 생성 시점에서 의존관계를 주입받는다. 주입과 동시에 프로토타입 빈도 생성되는데, 이 프로토타입 빈이 그 싱글톤 빈에 연결된다. 만일 다른 클라이언트가 싱글톤 빈의 프로토타입 빈을 호출한다면 싱글톤 빈이기 때문에 같은 프로토타입 빈을 반환할 것이고, 이는 사용 시마다 새로 생성되기를 의도한 것과 맞지 않게 작동하는 것이다.</li>
<li><strong>참고: 여러 빈에서 같은 프로토타입 빈을 주입받으면 주입받는 시점에 각각 새 프로토타입 빈이 생성된다.</strong></li>
</ul>
<h3 id="provider를-이용한-문제해결">Provider를 이용한 문제해결</h3>
<p><strong>Dependency Lookup</strong></p>
<ul>
<li>만일 싱글톤 빈 내에 ApplicationContext를 주입받고, 프로토타입 빈을 호출하는 로직 내부에서 ApplicationContext를 이용해 새 프로토타입 빈을 요청한다면 문제가 해결은 되겠지만 상당히 난잡하다.</li>
<li>의존관계를 외부에서 주입(DI) vs 직접 필요한 의존관계를 찾는 것: Dependency Lookup(DL), 의존관계 조회(탐색)</li>
<li>DL은 스프링 컨테이너에 종속적인 코드를 만듦 -&gt; 단위테스트를 힘들게 함</li>
<li>지연된 인스턴스 생성</li>
<li>순환참조 문제 해결</li>
</ul>
<p><strong>ObjectFactory, ObjectProvider</strong></p>
<pre class=" language-java"><code class="prism  language-java"> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">ClientBean</span> <span class="token punctuation">{</span>  
  
     <span class="token annotation punctuation">@Autowired</span>  
  <span class="token keyword">private</span> ObjectProvider<span class="token operator">&lt;</span>PrototypeBean<span class="token operator">&gt;</span> prototypeBeanProvider<span class="token punctuation">;</span>  
  
 <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">logic</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  
         PrototypeBean prototypeBean <span class="token operator">=</span> prototypeBeanProvider<span class="token punctuation">.</span><span class="token function">getObject</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
  prototypeBean<span class="token punctuation">.</span><span class="token function">addCount</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
 <span class="token keyword">return</span> prototypeBean<span class="token punctuation">.</span><span class="token function">getCount</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
  <span class="token punctuation">}</span>  
  
<span class="token punctuation">}</span>
</code></pre>
<ul>
<li><code>ObjectProvider</code>는 <code>ObjectFactory</code>를 extends한 인터페이스로 더 많은 기능(상속, 옵션, 스트림 처리 등) 제공</li>
<li><code>ObjectProvider</code>는 스프링 컨테이너 조회를 대신 해줌</li>
<li>스프링 기능을 사용하지만 기능이 단순하기에 단위테스트와 mock코드 만들기에 용이</li>
</ul>
<p><strong>JSR-330 Provider</strong></p>
<ul>
<li>JSR-330 자바 표준 <code>javax.inject.Provider</code>를 사용하는 방법</li>
<li><code>javax.inject:javax.inject1</code>라이브러리를 gradle에 추가해야 한다.</li>
</ul>
<pre class=" language-java"><code class="prism  language-java"> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">ClientBean</span> <span class="token punctuation">{</span>  
  
     <span class="token annotation punctuation">@Autowired</span>  
  <span class="token keyword">private</span> Provider<span class="token operator">&lt;</span>PrototypeBean<span class="token operator">&gt;</span> prototypeBeanProvider<span class="token punctuation">;</span>  
  
 <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">logic</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  
         PrototypeBean prototypeBean <span class="token operator">=</span> prototypeBeanProvider<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
  prototypeBean<span class="token punctuation">.</span><span class="token function">addCount</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
 <span class="token keyword">return</span> prototypeBean<span class="token punctuation">.</span><span class="token function">getCount</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
  <span class="token punctuation">}</span>  
  
<span class="token punctuation">}</span>
</code></pre>
<ul>
<li><code>provider</code>의 get()을 호출하면 DL</li>
<li>자바 표준이고 단순 기능이므로 단위테스트와 mock코드 만들기에 용이</li>
<li><strong>특징</strong>
<ul>
<li><code>get()</code>메서드 하나 -&gt; 기능이 단순</li>
<li>별도 라이브러리 필요</li>
<li>자바 표준이므로 스프링 외의 컨테이너에서도 사용가능</li>
</ul>
</li>
</ul>
<p><strong>정리</strong></p>
<ul>
<li>프로토타입 빈을 사용하는 경우: 사용 시마다 의존관계 주입된 객체가 필요할 경우(드물다)</li>
<li><code>ObjectProvider</code>와 <code>JSR-330 Provider</code>는 DL이 필요한 경우 사용</li>
<li>이 외에도 스프링 메서드에<code>@Lookup</code>도 가능</li>
<li><code>ObjectProvider</code>가 유용한 기능이 다수, 별도의 의존관계 추가가 불필요하기에 사용권장</li>
<li>하지만 스프링이 아닌 다른 컨테이너에서도 사용하려면 <code>JSR-330 Provider</code>를 사용하라.</li>
<li>자바 표준과 스프링 기능이 겹치는 경우가 많음 -&gt; 유용한 기능을 제공하는 쪽을 선택</li>
</ul>
<h3 id="웹-스코프">웹 스코프</h3>
<p><strong>특징</strong></p>
<ul>
<li>웹 환경에서만 동작</li>
<li>종료시점까지 관리됨</li>
</ul>
<p><strong>종류</strong></p>
<ul>
<li><strong>request</strong>: HTTP요청 하나가 들어오고 나갈 때까지 유지되는 스코프, 각 HTTP 요청마다 별도의 빈 인스턴스가 생성, 관리됨
<ul>
<li>ex) CLI1이 Controller에 요청시 빈 생성 이후 Service에 요청시 그 빈 반환, 응답이 끝나면 destroy</li>
</ul>
</li>
<li><strong>session</strong>: HTTP session과 동일한 생명주기</li>
<li><strong>application</strong>: 서블릿 컨텍스트(<code>Servlet Context</code>)와 동일 생명주기</li>
<li><strong>websocket</strong>: 웹 소켓과 동일한 생명주기</li>
</ul>
<h3 id="request-스코프-예제-만들기">request 스코프 예제 만들기</h3>
<p><strong>웹 환경 추가</strong><br>
웹 라이브러리가 없다면 <code>AnnotationConfigApplicationContext</code>기반으로 애플리케이션 구동, 추가시 <code>AnnotationConfigServletWebServerApplicationContext</code>기반으로 구동.</p>
<p><strong>request 스코프 예제 개발</strong><br>
여러 HTTP 요청이 왔을 때 어떤 요청이 남긴 로그인지 구별하기 용이한 request 스코프<br>
공통포맷 <code>[UUID][requestURL]{message}</code> 이용하여 구별할 것</p>
<ul>
<li>요청 마다 uuid 생성되므로 다른 요청과 구별 가능</li>
<li>requestUrl은 빈 생성 시점에는 모르기에 외부에서 넣어줌<br>
-request 스코프를 갖는 MyLogger 인스턴스 myLogger를 주입받는 LogDemoController, LogDemoService 추가하고 스프링 실행하면 실패 -&gt; 빈 주입 시점에 <code>@Request</code>는 생성되지 않았기 때문(HTTP 요청이 없으니) -&gt; DL 방식으로 해결</li>
<li>requestURL을 MyLogger에 저장하는 부분은 컨트롤러 보다는 공통 처리가 가능한 <strong>스프링 인터셉터</strong>나 <strong>서블릿 필터</strong>를 활용하는 것이 좋다.</li>
</ul>
<blockquote>
<p>비즈니스 로직이 있는 서비스 계층에서도 로그를 출력해보자.<br>
여기서 중요한점이 있다. request scope를 사용하지 않고 파라미터로 이 모든 정보를 서비스 계층에 넘긴 다면, 파라미터가 많아서 지저분해진다. 더 문제는 requestURL 같은 웹과 관련된 정보가 웹과 관련없는 서 비스 계층까지 넘어가게 된다. 웹과 관련된 부분은 컨트롤러까지만 사용해야 한다. 서비스 계층은 웹 기술에 종속되지 않고, 가급적 순수하게 유지하는 것이 유지보수 관점에서 좋다.<br>
request scope의 MyLogger 덕분에 이런 부분을 파라미터로 넘기지 않고, MyLogger의 멤버변수에 저 장해서 코드와 계층을 깔끔하게 유지할 수 있다.</p>
</blockquote>
<h3 id="스코프와-provider">스코프와 Provider</h3>
<ul>
<li>Provider를 이용하여 문제 해결 가능하다</li>
<li>uuid 이용하여 여러 요청이 올 때 로그를 쉽게 읽을 수 있다.</li>
<li>controller service 따로 요청 시에도 같은 빈 반환</li>
</ul>
<h3 id="스코프와-프록시">스코프와 프록시</h3>
<pre class=" language-java"><code class="prism  language-java"><span class="token annotation punctuation">@Component</span>  
<span class="token annotation punctuation">@Scope</span><span class="token punctuation">(</span>value <span class="token operator">=</span> <span class="token string">"request"</span><span class="token punctuation">,</span> proxyMode <span class="token operator">=</span> ScopedProxyMode<span class="token punctuation">.</span>TARGET_CLASS<span class="token punctuation">)</span>  
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MyLogger</span> <span class="token punctuation">{</span>
</code></pre>
<ul>
<li>Provider 사용한 것과 동일하게 사용 가능하다.</li>
<li>대상이 클래스면 TARGET_CLASS, 인터페이스면 TARGET_INTERFACES</li>
<li>HTTP request와 무관하게 가짜 프록시 클래스를 다른 빈에 미리 주입</li>
<li>CGLIB 이용, 스프링이 임의의 다른 클래스 등록</li>
<li>CLIA, CLIB -&gt; MyLoggerProxy -&gt; 진짜 myLogger.logic() 호출(A, B 전용 별도)</li>
<li>프록시에는 진짜 빈을 요청하는 위임 로직 가짐</li>
<li>클라이언트가 메서드 호출 시, 가짜 프록시 메서드를 호출하게 됨</li>
<li>프록시 객체는 원본을 상속 받은 것으로 클라이언트 입장에서는 그냥 사용한다.</li>
<li>프록시 객체는 실제 required scope와는 무관하며 싱글톤처럼 동작</li>
</ul>
<p><strong>정리</strong></p>
<ul>
<li>프록시 객체 덕분에 싱글톤 빈을 사용하듯이 편리하게 required scope 사용가능</li>
<li>핵심은 지연된 객체 조회(Provider와 프록시 공통)</li>
<li>@설정 변경만으로 프록시 객체로 대체 가능함, 클라이언트 코드 변경은 없다: 다형성과 DI 컨테이너의 장점</li>
<li>프록시는 웹 스코프 외에도 사용가능</li>
<li>스프링 AOP와 유사한 동작방식</li>
</ul>
<p><strong>주의사항</strong></p>
<ul>
<li>특수 스코프를 필요 이상으로 남발시 유지보수가 힘듦</li>
<li>싱글톤과 같은 방식으로 쓰지만 동작 방식은 다름</li>
</ul>

