# 스프링 핵심 원리 - 고급편

## 목차

[TOC]

# 예제: 로그 추적기

## 요구사항

- 현재 운영중인 거대 프로젝트에서
- 모든 `public` 메서드의 호출과 응답 정보를 로그로 출력
- 애플리케이션의 흐름을 변경해선 안 됨(비즈니스 로직의 동작은 그대로)
- 메서드 호출에 걸린 시간
- 정상 흐름과 예외 흐름 구분
  - 예외 발생시 예외 정보가 남아야 함
- 메서드 호출의 깊이 표현
- HTTP 요청을 구분
  - HTTP 요청 단위로 ID를 남겨서 어떤 요청에서 시작된 것인지 구별 가능해야
  - 트랜잭션 ID: 여기서는 하나의 HTTP 요청이 발생하여 끝날 때 까지를 하나의 트랜잭션이라 함

- **번외**
  - 실제 상황이라면, 모니터링 툴을 사용하여 다수의 요구사항이 해결 가능
  - 로깅이라서 더 잘 기록되는 정보가 있기도 함



## 프로토타입 구현: V1

- `TraceId`

  ```java
  public class TraceId {
  
  	private String id;
  	private int level;
  
  	public TraceId() {
  		this.id = createId();
  		this.level = 0;
  	}
  
  	public TraceId(String id, int level) {
  		this.id = id;
  		this.level = level;
  	}
  
  	private String createId() {
  		return UUID.randomUUID().toString().substring(0, 8);
  	}
  
  	public TraceId createNextId() {
  		return new TraceId(id, level + 1);
  	}
  
  	public TraceId createPreviousId() {
  		return new TraceId(id, level - 1);
  	}
  
  	public boolean isFirstLevel() {
  		return this.level == 0;
  	}
  
  	... getter
  }
  ```

- `TraceStatus`

  ```java
  public class TraceStatus {
  
  	private TraceId traceId;
  	private Long startTimeMs;
  	private String message;
  
  	public TraceStatus(TraceId traceId, Long startTimeMs, String message) {
  		this.traceId = traceId;
  		this.startTimeMs = startTimeMs;
  		this.message = message;
  	}
      ...getter
  }
  ```

- `HelloTraceV1`

  ```java
  @Slf4j
  @Component
  public class HelloTraceV1 {
  
  	private static final String START_PREFIX = "-->";
  	private static final String COMPLETE_PREFIX = "<--";
  	private static final String EX_PREFIX = "<X-";
  
  	public TraceStatus begin(String message) {
  		TraceId traceId = new TraceId();
  		Long startTimeMs = System.currentTimeMillis();
  		log.info("[{}] {}{}", traceId.getId(), addSpace(START_PREFIX, traceId.getLevel()), message);
  		return new TraceStatus(traceId, startTimeMs, message);
  	}
  
  	public void end(TraceStatus status) {
  		complete(status, null);
  	}
  
  	public void exception(TraceStatus status, Exception e) {
  		complete(status, e);
  	}
  
  	private void complete(TraceStatus status, Exception e) {
  		Long stopTimeMs = System.currentTimeMillis();
  		long resultTimeMs = stopTimeMs - status.getStartTimeMs();
  		TraceId traceId = status.getTraceId();
  		if (e == null) {
  			log.info("[{}] {}{} time={}ms", traceId.getId(), addSpace(COMPLETE_PREFIX, traceId.getLevel()), status.getMessage(), resultTimeMs);
  		}
  		else {
  			log.info("[{}] {}{} time={}ms ex={}", traceId.getId(), addSpace(COMPLETE_PREFIX, traceId.getLevel()), status.getMessage(), resultTimeMs, e.toString());
  		}
  	}
  
  	private static String addSpace(String prefix, int level) {
  		StringBuilder sb = new StringBuilder();
  		for (int i = 0; i < level; i++) {
  			sb.append((i == level -1) ? "|" + prefix : "|	");
  		}
  		return sb.toString();
  	}
  }
  ```

  

### 적용

- 컨트롤러 적용

  ```java
  @RestController
  @RequiredArgsConstructor
  public class OrderControllerV1 {
  
  	private final OrderServiceV1 orderService;
  	private final HelloTraceV1 trace;
  
  	@GetMapping("/v1/request")
  	public String request(String itemId) {
  		TraceStatus status = null;
  		try {
  			status = trace.begin("OrderController.request()");
  			orderService.orderItem(itemId);
  			trace.end(status);
  			return "ok";
  		} catch(Exception e) {
  			trace.exception(status, e);
  			throw e;
  		}
  	}
  }
  ```



## V2: 파라미터로 동기화 개발

- `HelloTraceV2`

  ```java
  	public TraceStatus beginSync(TraceId beforeTraceId, String message) {
  		TraceId traceId = beforeTraceId.createNextId();
  		Long startTimeMs = System.currentTimeMillis();
  		log.info("[{}] {}{}", traceId.getId(), addSpace(START_PREFIX, traceId.getLevel()), message);
  		return new TraceStatus(traceId, startTimeMs, message);
  	}
  ```

  - `TraceId`를 넘겨주는 방식 추가



### 적용

- 컨트롤러 코드

  ```java
  	@GetMapping("/v2/request")
  	public String request(String itemId) {
  		TraceStatus status = null;
  		try {
  			status = trace.begin("OrderController.request()");
  			orderService.orderItem(status.getTraceId(), itemId);
  			trace.end(status);
  			return "ok";
  		} catch (Exception e) {
  			trace.exception(status, e);
  			throw e;
  		}
  	}
  ```

- 서비스 코드

  ```java
  	public void orderItem(TraceId traceId, String orderId) {
  		TraceStatus status = null;
  		try {
  			status = trace.beginSync(traceId, "OrderService.orderItem()");
  			orderRepository.save(status.getTraceId(), orderId);
  			trace.end(status);
  		} catch(Exception e) {
  			trace.exception(status, e);
  			throw e;
  		}
  	}
  ```

- `TraceId`를 메서드 호출 시 인자로 같이 넘겨주는 방식



## 정리: 남은 문제들

- 모든 메서드 인자에 `TraceId`를 넘겨줘야 함
  - 모든 파라미터, 경우에 따라 인터페이스까지 수정해야 함
- 로그를 처음 시작할 때는 `begin()`을, 아닐 때는 `beginSync()`를 호출해줘야 함
  - 컨트롤러가 아닌 곳에서 서비스 호출이 발생할 경우 파라미터로 넘길 `TraceId`가 없음



# 쓰레드 로컬 - Thread Local

## 필드 동기화

- 로그 추적기 구현 중에 `TraceId`를 동기화해야 했음

  - 파라미터로 넘기는 방식은
    일일히 파라미터를 넘겨야 하는 문제가 발생했음

- `FieldLogTrace`

  ```java
  @Slf4j
  public class FieldLogTrace implements LogTrace {
  
  	...
      
  	private TraceId traceIdHolder;    //traceId 동기화, 동시성 이슈 발생
  
      ...
          
  	private void syncTraceId() {
  		if (traceIdHolder == null) {
  			traceIdHolder = new TraceId();
  		} else {
  			traceIdHolder = traceIdHolder.createNextId();
  		}
  	}
  
      ...
          
  	private void releaseTraceId() {
  		if (traceIdHolder.isFirstLevel()) {
  			traceIdHolder = null;
  		} else {
  			traceIdHolder = traceIdHolder.createPreviousId();
  		}
  	}
  
      ...
  }
  ```



#### 동시성 문제

- `FieldLogTrace`는 싱글톤 스프링 빈
  - 해당 인스턴스의 동일 필드에 여러 쓰레드가 동시 접근하기에 문제 발생

- 예제 코드

  - SUT: `FieldService`

    ```java
    @Slf4j
    public class FieldService {
    
    	private String nameStore;
    
    	public String logic(String name) {
    		log.info("저장 name={} -> nameStore={}", name, nameStore);
    		nameStore = name;
    		sleep(1000);
    		log.info("조회 nameStore={}", nameStore);
    		return nameStore;
    	}
    
    	private void sleep(int millis) {
    		try {
    			Thread.sleep(millis);
    		} catch (InterruptedException e) {
    			e.printStackTrace();
    		}
    	}
    }
    ```

  - 테스트 코드

    ```java
    @Slf4j
    public class FieldServiceTest {
    
    	private FieldService fieldService = new FieldService();
    
    	@Test
    	void field() {
    		log.info("main Start");
    		Runnable userA = () -> {
    			fieldService.logic("userA");
    		};
    		Runnable userB = () -> {
    			fieldService.logic("userB");
    		};
    
    		Thread threadA = new Thread(userA);
    		threadA.setName("thread-A");
    		Thread threadB = new Thread(userB);
    		threadB.setName("thread-B");
    
    		threadA.start();
    		// sleep(2000);	//동시성 문제 발생하지 않음
    		sleep(100);	//동시성 문제 발생
    		threadB.start();
    
    		//threadB가 도는 중에 메인이 닫힐 수 있기에
    		sleep(3000);	//제대로 만들고 싶다면 countDownLatch 참고
    		log.info("main exit");
    	}
    
    	private void sleep(int millis) {
    		try {
    			Thread.sleep(millis);
    		} catch (InterruptedException e) {
    			e.printStackTrace();
    		}
    	}
    }
    ```

- 동시성 문제

  - 트래픽이 많아질수록 자주 발생
  - **스프링 빈처럼 싱글톤 객체의 필드를 변경하며 사용시에 특히 위험!**
  - `static` 영역, 인스턴스 필드에서 발생
  - 동시성 문제는 값을 읽기만 하면 발생하지 않음

- 싱글톤 객체의 필드를 사용하면서 동시성 문제를 해결하는 방법: **쓰레드 로컬**



## 쓰레드 로컬

- 쓰레드 로컬(ThreadLocal)
  - 해당 쓰레드만 접근 가능한 특별한 저장소
  - 같은 인스턴스의 쓰레드 로컬 필드에 접근해도 동시성 문제 없음
  - 자바에서 `java.lang.ThreadLocal`을 제공

- 기존의 `FieldService`에 적용해보기

  ```java
  @Slf4j
  public class ThreadLocalService {
  
  	private ThreadLocal<String> nameStore = new ThreadLocal<>();
  
  	public String logic(String name) {
  		log.info("저장 name={} -> nameStore={}", name, nameStore.get());
  		nameStore.set(name);
  		sleep(1000);
  		log.info("조회 nameStore={}", nameStore);
  		return nameStore.get();
  	}
  
  	private void sleep(int millis) {
  		try {
  			Thread.sleep(millis);
  		} catch (InterruptedException e) {
  			e.printStackTrace();
  		}
  	}
  }
  ```

- `ThreadLocal` 사용법

  - 값 저장: `ThreadLocal.set(xxx)`
  - 값 조회: `ThreadLocal.get()`
  - 값 제거: `ThreadLocal.remove()`

- **주의사항**
  - **해당 쓰레드가 쓰레드 로컬을 모두 사용하고 난 후 `remove()` 이용해서 꼭 제거해주자!**
- **`remove()` 하지 않을 경우 문제점**
  - WAS(톰캣)처럼 쓰레드 풀을 사용하는 경우 문제 발생 가능
  - 기존 사용자가 사용이 끝나고 쓰레드를 반납한 후에도 해당 쓰레드에 정보가 남아서,
    다른 사용자에게 해당 쓰레드를 할당될 때도 그 데이터가 남게 됨