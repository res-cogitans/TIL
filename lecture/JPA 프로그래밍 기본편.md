# 자바 ORM 표준 JPA 프로그래밍 - 기본편(김영한)
- JPA - Java Persistence API
- JDBC나 MyBatis, JdbcTemplate보다 진보
- SQL을 직접 작성할 필요가 없기 때문에 생산성 및 유지보수성 상승
- JPA가 실무에서 어려운 이유?
	1. 객체와 테이블을 올바르게 매핑하고 설계하는 방법에 무지
		- 실무에서는 많은 객체와 테이블을 복잡하게 사용하게 되기에 문제
	2. JPA의 내부 동작 방식에 대한 이해 결여
		- 장애 상황에서 대응 못 함

<br>

## JPA 소개
### SQL 중심적인 언어의 문제점
- 현재의 개발 패러다임
	-  객체 지향 언어
	- 관계형 DB
	-> 객체를 관계형 DB에 관리 -> SQL !!!
- **SQL 중심적인 개발로 문제 발생**
	- 반복: 자바 객체를 SQL로, SQL을 자바 객체로 바꾸는 등
	- 변동 발생 시마다 객체, SQL 양쪽 반영하는 과정에서 문제 발생하기도
	- **패러다임의 불일치**
		- 개발자가 SQL 매퍼가 됨
		- 객체와 관계형 DB의 차이
			- 상속
				- 테이블의 슈퍼타입 서브타입 관계가 그나마 유사
				- 그러나 이는 매우 복잡
			- 연관관계
				- 객체는 참조를 사용: `member.getTeam()`
				- 테이블은 외래 키를 사용: `JOIN ON M.TEAM_ID = T.TEAM_ID`
				- 객체를 테이블에 맞춰서 모델링, 저장
					- 만일 객체다운 설계를 적용하려고 한다면 오히려 번거로운 작업들을 해야 함 -> 생산성 저하
				- 객체 그래프 탐색
					- 객체는 자유롭게 객체 그래프를 탐색 할 수 있어야 한다. (`.get...()`)
					- 그러나 처음 실행하는 SQL에 따라 탐색 범위가 결정된다.
					- 엔티티 신뢰 문제
					- 모든 객체를 미리 로딩할 수는 없다. 조회범위를 정하는 get을 만드는 방법 등 ...
			- 데이터 타입
			- 데이터 식별방법 등
				- 비교하기에서 차이가 발생하기도(SQL쿼리를 날리고, 새 객체에 담다보면, 컬렉션에서 동일 key로 value를 꺼냈을 때와는 달리, 서로 다르다고 판정)
	-> SQL을 직접 다루게 되면 계층형 아키텍처의 계층 분할이 어려움
	- 객체를 객체지향적으로 다룰수록 문제 발생!
	-> 객체를 자바 컬렉션에 저장하는 것처럼 DB에 저장하는 방법? -> JPA

### JPA 소개
- 자바 진영의 ORM 표준
	- **ORM**
		- **O**bject-**R**elational **M**apping(객체관계매핑)
		- 객체는 객체대로, RBD는 RBD대로
		- 객체와 RDB를 중간에서 매핑해주는 ORM 프레임워크
	- JPA는 애플리케이션과 JDBC 사이에서 동작
