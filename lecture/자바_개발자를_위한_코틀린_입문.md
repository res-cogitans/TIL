# 자바 개발자를 위한 코틀린 입문

- 코틀린
  - JetBrains에서 만든 언어
  - JVM에서 작동
  - 정적 타입 언어
  - OOP + FP
  - 아파치 2.0 라이센스: 소스코드 공개 의무 없음, 상업적 이용 가능
  - `;` 붙이지 않아도 됨
  - 기본 접근 제한자는 `public`
  - `val number : Int = 100` (타입스크립트와 유사한 변수 선언)
  - InteliJ의 Tools - Kotlin - Show Kotlin Bytecode 이용하여 자바 코드를 확인 가능



# 코틀린에서 변수와 타입, 연산자를 다루는 방법

## 1강. 코틀린에서 변수를 다루는 방법

### 1. 변수 선언 키워드 - `var`와 `val`의 차이점

- 가변과 불변
  - `var ` 가변
  - `val` 불변
- `var` 혹은 `val`을 반드시 명시해 줘야 함

- 타입을 작성해주지 않아도 되지만, 명시적 작성도 가능하다.

  ```kotlin
  var number1: Long = 10L
  val number2 = 10L
  ```

- 초기값을 할당하지 않는다면?

  - 타입 추론이 불가능하기에 타입을 명시해줘야 함
  - `val`의 경우 최초 한 번 할당 가능

- `val` 컬렉션에는 element 추가 가능(자바 컬렉션과 동일)

> 기본적으로는 `val`로 선언하고, 필요시 `var`로 변경



### 2. Kotlin에서의 Primitive Type

- 코틀린의 경우 `long`과 `Long`의 구별이 없음
  - 일부 타입들(숫자, 불리언, 문자)의 경우 연산시 내부적으로 `primitive type`으로 바꿔서 작동
  - 외적으로는 구별할 필요 없음



### 3. Kotlin에서의 nullable 변수

```kotlin
var notNullableNumber = 10L
var nullableNumber: Long? = 1_000L
```

- 해당 변수에 `null`이 들어갈 수 있는 경우 타입에 `?` 붙여야 함



### 4. Kotlin에서의 객체 인스턴스화

```kotlin
var person = Person("Sample")
```

- `new` 연산자 붙이지 않음



## 2강. 코틀린에서 `null`을 다루는 방법

### 1. Kotlin에서의 `null` 체크

- 자바 코드

  - null-safety를 갖추지 못한 코드

    ```java
    public boolean startsWithA(String str) {
        return str.startsWith("A");
    }
    ```

  - 보완 코드

    - 예외 발생시키는 방식

      ```java
      public boolean startsWithA(String str) {
          if (str == null) {
              throw new IllegalArgumentException("null이 들어왔습니다.")
          }
          return str.startsWith("A");
      }
      ```

    - `null` 반환하는 방식

      ```java
      public Boolean startsWithA(String str) {
          if (str == null) {
              return null;
          }
          return str.startsWith("A");
      }
      ```

    - `null`일 경우 기본값(`false`) 설정하는 방식

      ```java
      public boolean startsWithA(String str) {
          if (str == null) {
              return false;
          }
          return str.startsWith("A");
      }
      ```

- 코틀린으로 표현한 코드

  - 예외 발생시키는 방식

    ```kotlin
    fun startsWithA(str: String?): Boolean {
        if (str == null) {
            throw IllegalArgumentException("null이 들어왔습니다.")
        }
        return str.startsWith("A")
    }
    ```

    - 매개변수가 `null`일 수 있기에 `String?`로 표기함
    - 반환 타입이 `null`일 수 없기에 `?` 붙이지 않고 `Boolean`으로 표기함

  - `null` 반환하는 방식

    ```kotlin
    fun startsWith(str: String?): Boolean? {
        if (str == null) {
            return null
        }
        return str.startsWith("A")
    }
    ```

    - `null` 값이 가능하기에 반환 타입은 `Boolean?`

  - `null`일 경우 기본값 설정하는 방식

    ```kotlin
    fun startsWith(str: String?): Boolean {
        if (str == null) {
            return false
        }
        return str.startsWith("A")
    }
    ```

- **코틀린은 `null`이 가능한 타입을 완전히 다르게 취급한다!**



### 2. Safe Call과 Elvis 연산자

- 코틀린에서는 nullable한 타입만을 위한 기능이 있음

- **Safe Call**

  - `null`이 아니면 실행하고, `null`이면 실행하지 않는다(그대로 `null`)

  - 예시 코드

    ```kotlin
    val str: String? = "ABC"
    str.length 	//호출이 불가능하다!
    str?.length	//가능하다
    ```

    - `null`이 아닌 경우에만 호출이 발생, `null`일 경우 `null`을 그대로 반환

- **Elvis 연산자**

  - 예시 코드

    ```kotlin
    val str: String? = "ABC"
    str?.length ?: 0
    ```

    - 앞의 연산 결과가 `null`이면 뒤의 값을 사용

- 예시 코드의 수정

  - 예외 발생시키는 방식

    ```kotlin
    fun startsWithA(str: String?): Boolean {
        return str?.startsWith("A") 
        ?: throw IllegalArgumentException("null이 들어왔습니다.")
    }
    ```

  - `null`을 반환하는 방식

    ```kotlin
    fun startsWithA(str: String?): Boolean? {
        return str?.startsWith("A")
    }
    ```

  - `null`일 경우 기본값 설정하는 방식

    ```kotlin
    fun startsWithA(str: String?): Boolean {
        return str?.startsWith("A") ?: false
    }
    ```

- **Elvis 연산자와 early return**

  - 자바의 경우

    ```java
    public long calculate(Long number) {
        if (number == null) {
            return 0;
        }
        //로직
    }
    ```

  - 코틀린의 경우

    ```kotlin
    fun calculate(number: Long?): Long {
        number ?: return 0;
        //로직
    }
    ```

    - `if`문을 사용하지 않음



### 3. `null` 아님 단언

- nullable한 타입이지만 `null`이 될 수 없는 경우

  - 예시 코드

    ```kotlin
    fun startsWithA(str: String?): Boolean {
        return str!!.startsWith("A")
    }
    ```

    - `!!`을 이용하여 단언 가능
    - 사용하지 않을 경우 컴파일 에러 발생
    - ***단, 위의 경우 `null`이 들어올 경우에 NPE 발생! 확실한 경우에만 단언 사용할 것!***



### 4. 플랫폼 타입

- 코틀린에서 자바 코드를 가져다 쓸 경우 

- 예시

  - 자바 클래스

    ```java
    public class Person {
        private final String name;
        
        public Person(String name) {
            this.name = name;
        }
        
        @Nullable
        public String getName() {
            return name;
        }
    }
    ```

  - 코틀린이 위의 자바 코드를 사용할 경우

    - `@Nullable`이나 `@NotNull` 등의 자바 애노테이션을 코틀린이 이해함
    - 하지만 위와 같은 애노테이션 정보가 없을 경우 코틀린은 해당 자바 코드에서 정보를 받지 못함
      - `javax.annotation` 패키지
      - `android.support.annotation` 패키지
      - `org.jetbrains.annotation` 패키지

- **플랫폼 타입**

  - 코틀린이 `null` 관련 정보를 알 수 없는 타입
  - 런타임에 `Exception` 발생 가능!

- **코틀린에서 자바 코드를 사용할 경우 대응법**

  - 자바 코드에 `null` 관련 정보를 명시해준다.
  - 외부 라이브러리를 사용할 경우
    - 라이브러리 내부 코드에서 nullable을 확인하고 사용하자
    - 코틀린에서 자바 라이브러리를 최초로 사용한 지점을 wrapping을 통해 단일지점으로 변경, 이슈에 대응하기 용이하게 만들자



## 3강. 코틀린에서 Type을 다루는 방법

### 1. 기본 타입

- 코틀린에서는 선언된 기본값을 보고 타입을 추론한다.

  - 정수

    ```kotlin
    val number1 = 3		//Int
    val number2 = 3L	//Long
    ```

  - 소수

    ```kotlin
    val number1 = 3.0f	//Float
    val number2 = 3.0	//Double
    ```

- **기본 타입간의 변환: 자바와의 차이점**

  - 자바의 경우 기본 타입간의 변환은 **암시적으로 이뤄질 수 있다.**

    ```java
    int number1 = 4;
    long number2 = number1;
    ```

    - `int` 타입 값이 `long` 타입으로 암시적 변경(더 큰 타입으로는 암시적 변경)

  - 코틀린의 경우 기본 타입간의 변환이 **명시적으로 이루어져야 한다.**

    ```kotlin
    val number1 = 4
    val number2: Long = number1	//Type mismatch로 컴파일 에러
    ```

    - 대신 `to변환타입()`을 사용하여 명시적 변경이 필요

      ```kotlin
      val number1 = 4
      val number2: Long = number1.toLong()
      ```

    - 예시2: 나눗셈 값을 실수로 받고 싶을 때

      ```kotlin
      val number1 = 3
      val number2 = 5
      val result = number1 / number2.toDouble()
      ```

      - 자바의 경우 `(double)` 이용했지만, 코틀린의 경우 `toDouble()`이용

- nullable 변수의 경우 Safe Call과 Elvis 연산자 이용하여 처리해줘야 함

  ```kotlin
  val number1: Int? =  3
  val number2: Long = number.toLong()		//불가능
  val number2: Long = number?.toLong() ?: 0L
  ```



### 2. 형변환

- 기본 타입이 아닌 일반 타입의 경우에는?

- 자바의 경우

  ```java
  public static void printAgeIfPerson(Object obj) {
      if (obj instanceof Person) {
          Person person = (Person) obj;
          System.out.println(person.getAge();
      }
  }
  ```

  - `instanceof`로 타입 검사, `(Person)`으로 형변환

- 코틀린의 경우

  ```kotlin
  fun printAgeIfPerson(obj: Any) {
      if (obj is Person) {
          val person = obj as Person
          println(person.age)
      }
  }
  ```

  - `instanceof` 대신에 `is`

  - `(Person)` 대신에  `as Person`

  - 사실 `as Person`은 생략 가능함

    ```kotlin
    println(obj.age)
    ```

    - 위의 호출이 가능: **스마트 캐스트**

- `as?`

  ```kotlin
  fun printAgeIfPerson(obj: Any?) {
      val person = obj as? Person
      println(person?.age)
  }
  ```

  - `as?` 만약 `null`이거나 해당 타입이 아닌 경우 `null`이 된다.
  - `person` 변수가 nullable하기에 `person?.age`로 처리했다.

- 정리

  - `is`: 해당 타입인지에 따라 T/F 반환
    - `value !is Type` 형태로 부정도 가능
  - `as`: 해당 타입일 경우에는 타입 캐스팅, 아닐 경우 `ClassCastException` 발생
    - `as?`: value가 해당 타입인 경우에는 타입 캐스팅, `null`이거나 해당 타입이 아닌 경우 `null`



### 3. Kotlin의 특이 타입 3가지

- **Any**

  - 자바의 `Object` 역할(모든 객체의 최상위 타입)
    - 모든 기본 자료형의 최상위 타입이기도 함
  - `Any` 만으로는 `null`을 포함 불가, `null`을 포함하고 싶을 경우 `Any?`
  - `equals` / `hashCode` / `toString` 존재

- **Unit**

  - 자바의 `void`와 동일한 역할
  - `void`와 달리 `Unit`은 그 자체로 타입 인자로 사용 가능
    - 자바의 경우 제네릭 사용을 위한 `Void`가 따로 있었음
  - 함수형 프로그래밍에서 `Unit`은 단 하나의 인스턴스만 갖는 타입을 의미한다.
    - 코틀린의 `Unit`은 실제 존재하는 타입임을 강조하기 위해 사용한 네이밍

- **Nothing**

  - 함수가 정상적으로 끝나지 않았음을 표현하는 역할

  - 무조건 예외를 반환하는 함수 / 무한 루프 함수 등을 표현하는 데 사용함

    ```kotlin
    fun fail(message: String): Noting {
        throw IlleagalArgumentException(message)
    }
    ```



### 4. String interpolation / String indexing

- 예시 코드

  - 자바의 경우

    ```java
    Person person = new Person("이름", 50);
    String log = String.format("이름은 %s이고 나이는 %s세 입니다.", person.getName(), person.getAge());
    ```

    - 혹은 `StringBuilder` 이용하여 동적으로 `String` 생성

  - 코틀린의 경우

    ```kotlin
    val person = Person("이름", 50)
    val log = "이름은 ${person.name}이고 나이는 ${person.age}세 입니다."
    ```

    - `${변수}`를 사용하여 값을 넣을 수 있음

    ```kotlin
    val name = "이름"
    println("이름: $name")
    ```

    - 중괄호 생략도 가능하다. (객체 내 프로퍼티 접근이 아닌 변수 바로 접근인 경우 사용 가능)
    - 변수 이름만 사용하더라도 **중괄호 포함하여 `${변수}` 형태로 사용함이 낫다.**
      - 가독성
      - 일괄 변환
      - 정규식 활용의 측면에서 그렇다.

- `"""` 이용한 문자열 표현

  ```kotlin
  val str = """
  	ABC
  	DEF
  	${name}
  """.trimIndent()
  ```

- 문자열의 특정 문자 가져오기

  - 자바의 경우 `str.charAt()` 사용했음

  - 코틀린의 경우 대괄호 사용하여 접근 가능

    ```kotlin
    val str = "ABC"
    println(str[2])		//C 출력됨
    ```



## 4강. 코틀린에서 연산자를 다루는 방법

### 1. 단항 연산자 / 산술 연산자

- 단항 연산자: `++`, `--`

- 산술 연산자: `+`, `-`, `*`, `/`, `%`

- 산술 대입 연산자: `+=`, `-=`, `*=`, `/=`, `%=`
- **자바와 모두 동일하다!**



### 2. 비교 연산자와 동등성, 동일성

- 비교 연산자: `>`, `<`, `>=`, `<=`
  - **자바와 달리 객체를 비교할 때 비교 연산자를 사용하면
    자동으로 `compareTo()`를 호출한다!**
- 코틀린에서 동일성과 동등성
  - `===`: 동일성
  - `==`: 동등성, **간접적으로 equals() 호출**



### 3. 논리 연산자와 코틀린에 있는 특이한 연산자

- 논리 연산자: 자바와 완전히 동일(`&&`, `||`, `!`)

  - 자바처럼 Lazy evaluation 수행함

- `in` / `!in` 연산자

  - 컬렉션이나 범위에 포함되어 있는지 검사

    ```kotlin
    println(1 in numbers)
    ```

- `..` 연산자 (`a..b`)

  - `a`에서 `b`까지의 범위 객체를 생성한다.

- `a[i]`

  - `a`에서 특정 Index `i`로 값을 가져온다.

- `a[i] = b`

  - `a`의 특정 index `i`에 `b`를 넣는다.



### 4. 연산자 오버로딩

- 코틀린에서는 객체마다 연산자를 직접 정의할 수 있다.

- 예시 코드

  ```kotlin
  data class Money(
      val amount: Long
  ) {
      operator fun plus(other: Money): Money {
          return Money(this.amount + other.amount)
      }
  }
  ```

  ```kotlin
  fun main() {
      val money1 = Money(1_000L)
      val money2 = Money(2_000L)
      println(money1 + money2)
  }
  ```



# 코틀린에서 코드를 제어하는 방법

## 5강. 코틀린에서 조건문을 다루는 방법

### 1. if문

- 자바의 경우

  ```java
  private void validateScoreIsNotNegative(int score) {
      if (score < 0) {
          throw new IllegalArgumentException(String.format("%s는 0보다 작을 수 없습니다.", score));
      }
  }
  ```

- 코틀린의 경우

  ```kotlin
  fun validateScoreIsNotNegative(score: Int) {
      if (score < 0) {
          throw IllegalArgumentException("${score}는 0보다 작을 수 없습니다.")
      }
  }
  ```

  - `Unit`(`void`)이 생략됨
  - `if` 문 문법 자체는 동일

- `else`

  ```kotlin
  fun getPassOrFail(score: Int): String {
      if (score >= 50) {
          return "P"
      } else {
          return "F"
      }
  }
  ```

  - 코드 형태 자체는 동일하다.



### 2. Expression과 Statement

- **자바와 코틀린에서 `if-else` 차이점!**

  - **자바의 `if-else`는 Statement지만,
    코틀린에서는 Expression이다!**

  - Expression은 하나의 값으로 도출되는 Statement

  - 때문에 위의 코틀린 코드는 다음과 같이 바꿀 수 있다:

    ```kotlin
    fun getPassOrFail(score: Int): String {
        return if (score >= 50) {
            "P"
        } else {
            "F"
        }
    }
    ```

  - **코틀린에서는 `if-else`를 Expression으로 취급하기에 3항 연산자가 없다!**

- 값이 특정 범위에 포함되어 있는지 검사하는 코드도 다르다!

  - 자바의 경우

    ```java
    if (0 <= score && score <= 100)
    ```

  - 코틀린의 경우

    ```kotlin
    if (score in 0..100)
    ```



### 3. switch와 when

- 코틀린은 `switch` 삭제되었으며, 대신 `when` 사용

  ```kotlin
  fun getGrade(socre: Int): String {
      return when(score / 10) {
          9 -> "A"
          8 -> "B"
          7 -> "C"
          else -> "D"
      }
  }
  ```

  - `when`도 Expression으로 취급됨

  - 분기 표현도 더 편리하게 가능: 범위 및 조건 표현

    ```kotlin
    fun getGrade(socre: Int): String {
        return when(score / 10) {
            in 90..99 -> "A"
            in 80..89 -> "B"
            in 70..79 -> "C"
            else -> "D"
        }
    }
    ```

    - 조건부에는 어떠한 Expression도 들어갈 수 있음
      - ex) `is` 연산자를 이용한 타입 검사

  - 여러개의 조건을 검사할 수도 있음(`,` 이용)

    ```kotlin
    fun judgeNumber(number: Int) {
        when (number) {
            1, 0, -1 -> println("의도한 숫자입니다.")
            else -> println("의도한 숫자가 아닙니다.")
        }
    }
    ```

  - `when(value)`의 `value`가 없을 수도 있음

    ```kotlin
    fun judgeNumber(number: Int) {
        when {
            number == 0 -> println("주어진 숫자는 0입니다.")
            number % 2 == 0 -> println("주어진 숫자는 짝수입니다.")
            else -> println("주어진 숫자는 홀수입니다.")
        }
    }
    ```

  - `when`은 Enum Class 혹은 Sealed Class 와 함께 사용할 경우 더 유용



## 6강. 코틀린에서 반복문을 다루는 방법

### 1. for-each문(향상된 for문)

```kotlin
val numbers = listOf(1L, 2L, 3L)
for (number in numbers) {
    println(number)
}
```

- `:` 대신 `in` 사용한 것 외에는 거의 동일
- `Iterable`이 구현된 타입이라면 모두 사용 가능



### 2. 전통적인 for문

```kotlin
for (i in 1..3) {
    println(i)
}
```

- 1부터 3까지 모두 출력: 3까지 포함한다는 것을 혼동하지 말자

- 감산의 경우

  ```kotlin
  for (i in 3 downTo 1) {
      println(i)
  }
  ```

  - `downTo` 사용

- 1씩 변화하지 않는 경우

  ```kotlin
  for (i in 1..5 step 2) {
      println(i)
  }
  ```

  - `step` 사용



### 3. Progression과 Range

- `..` 연산자: 범위를 만들어 내는 연산자
- `IntRange` 클래스는 `IntProgression`(등차수열)을 상속받고 있다.
- `downTo`, `step `도 함수다!
  - 중위 호출 함수: 다른 함수 호출법



### 4. while문

- 자바와 동일(`do-while`도 동일)



## 7강. 코틀린에서 예외를 다루는 방법

### 1. try catch finally 구문

```kotlin
fun parseIntOrThrow(str: String): Int {
    try {
        return str.toInt()
    } catch (e: NumberFormatException) {
        throw IllegalArgumentException("주어진 ${str}는 숫자가 아닙니다.")
    }
}
```

- 문법 자체는 자바와 동일

- `null`을 반환하는 버전

  ```kotlin
  fun parseIntOrThrow(str: String): Int? {
      return try {
          str.toInt()
      } catch (e: NumberFormatException) {
          null
      }
  }
  ```

  - try catch문도 Expression으로 취급된다!



### 2. Checked Exception과 Unchecked Exception

```kotlin
fun readFile() {
    val currentFile = File(".")
    val file = File(currentFile.absolutePath + "/a.txt")
    val reader = BufferedReader(FileReader(file))
    println(reader.readLine())
    reader.close()
}
```

- 코틀린에서는 Checked / Unchecked Exception을 구별하지 않는다! -> 모두 Unchecked Exception이다.



### 3. try with resources

```kotlin
fun readFile(path: String) {
    BufferedReader(FileReader(path)).use { reader ->
        println(reader.readLine())
    }
}
```

- 코틀린에서는 try with resources 구문이 없다!
- `use`를 사용함(인라인 확장 함수)



## 8강. 코틀린에서 함수를 다루는 방법

### 1. 함수 선언 문법

```kotlin
fun max(a: Int, b: Int): Int =
    return if (a > b) {
        a
    } else {
        b
    }
```

- 리턴 타입 `Unit`은 생략 가능

- 함수가 하나의 결과값인 경우 코드 블록 대신 `=` 사용 가능

- 코드 줄 수를 줄일 수도 있음

  ```kotlin
  fun max(a: Int, b: Int): Int = if (a > b) a else b
  ```

  - `=`을 사용했기 때문에 반환 타입(`: Int`)도 생략 가능
  - 단, 중괄호 사용한 경우에는 반환 타입이 `Unit` 아닐 경우 반환 타입을 명시해 주어야 한다.

- 함수는 클래스 안에 있을수도, 파일 최상단에 있을 수도, 한 파일 안에 여럿이 있을 수도 있다.



### 2. default parameter

- 자바의 경우 오버로딩 등을 이용하여 메서드 기본 파라미터를 설정할 수 있지만, 코드 수가 쓸데 없이 길어진다는 문제

```kotlin
fun repeat(
    str: String, 
    num: Int = 3, 
    useNewLine: Boolean = true) {
    for (i in 1..num) {
        if (useNewLine) {
            println(str)
        } else {
            print(str)
        }
    }
}
```

- 코틀린의 경우 위와 같이 파라미터가 넘어오지 않았을 경우 기본값을 지정해줄 수 있다. (default parameter)



### 3. named argument

- 위의 경우 두 번째 파라미터인 `num`은 기본값을 넣어주지만 마지막 파라미터만 특정 값을 넣어 사용하고 싶을 수도 있다.
  - 이 경우 `num` 값 설정을 하지 않으면서 호출할 수 있는 방법을 제공한다.

```kotlin
repeat("Hello World", useNewLine = false)
```

- 매개변수 이름을 통해 직접 지정해줄 수 있다.
- 빌더를 만들지 않으면서 빌더의 강점을 가져올 수 있다.
- ***코틀린에서 자바 메서드를 가져와 사용할 경우 named argument는 사용 불가능하다!***
  - 자바 바이트 코드 상으로 매개변수 이름 정보가 남아 있지 않기 때문이다!



### 4. 가변인자

- 자바의 경우

  ```java
  public static void printAll(String... strings) {
      //로직
  }
  ```

- 코틀린의 경우

  ```kotlin
  fun printAll(vararg strings String) {
      //로직
  }
  ```

  - `...` 대신에 `vararg` 명시

- 사용 코드

  ```kotlin
  printAll("A", "B", "C")
  
  val array = arrayOf("A", "B", "C")
  printAll(*array)
  ```

  - 두 가지 모두 가능하다.
  - `*`: spread 연산자
