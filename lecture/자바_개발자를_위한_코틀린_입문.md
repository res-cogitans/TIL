# 자바 개발자를 위한 코틀린 입문

- 코틀린
  - JetBrains에서 만든 언어
  - JVM에서 작동
  - 정적 타입 언어
  - OOP + FP
  - 아파치 2.0 라이센스: 소스코드 공개 의무 없음, 상업적 이용 가능
  - `;` 붙이지 않아도 됨
  - 기본 접근 제한자는 `public`
  - `val number : Int = 100` (타입스크립트와 유사한 변수 선언)
  - InteliJ의 Tools - Kotlin - Show Kotlin Bytecode 이용하여 자바 코드를 확인 가능



# 코틀린에서 변수와 타입, 연산자를 다루는 방법

## 1강. 코틀린에서 변수를 다루는 방법

### 1. 변수 선언 키워드 - `var`와 `val`의 차이점

- 가변과 불변
  - `var ` 가변
  - `val` 불변
- `var` 혹은 `val`을 반드시 명시해 줘야 함

- 타입을 작성해주지 않아도 되지만, 명시적 작성도 가능하다.

  ```kotlin
  var number1: Long = 10L
  val number2 = 10L
  ```

- 초기값을 할당하지 않는다면?

  - 타입 추론이 불가능하기에 타입을 명시해줘야 함
  - `val`의 경우 최초 한 번 할당 가능

- `val` 컬렉션에는 element 추가 가능(자바 컬렉션과 동일)

> 기본적으로는 `val`로 선언하고, 필요시 `var`로 변경



### 2. Kotlin에서의 Primitive Type

- 코틀린의 경우 `long`과 `Long`의 구별이 없음
  - 일부 타입들(숫자, 불리언, 문자)의 경우 연산시 내부적으로 `primitive type`으로 바꿔서 작동
  - 외적으로는 구별할 필요 없음



### 3. Kotlin에서의 nullable 변수

```kotlin
var notNullableNumber = 10L
var nullableNumber: Long? = 1_000L
```

- 해당 변수에 `null`이 들어갈 수 있는 경우 타입에 `?` 붙여야 함



### 4. Kotlin에서의 객체 인스턴스화

```kotlin
var person = Person("Sample")
```

- `new` 연산자 붙이지 않음



## 2강. 코틀린에서 `null`을 다루는 방법

### 1. Kotlin에서의 `null` 체크

- 자바 코드

  - null-safety를 갖추지 못한 코드

    ```java
    public boolean startsWithA(String str) {
        return str.startsWith("A");
    }
    ```

  - 보완 코드

    - 예외 발생시키는 방식

      ```java
      public boolean startsWithA(String str) {
          if (str == null) {
              throw new IllegalArgumentException("null이 들어왔습니다.")
          }
          return str.startsWith("A");
      }
      ```

    - `null` 반환하는 방식

      ```java
      public Boolean startsWithA(String str) {
          if (str == null) {
              return null;
          }
          return str.startsWith("A");
      }
      ```

    - `null`일 경우 기본값(`false`) 설정하는 방식

      ```java
      public boolean startsWithA(String str) {
          if (str == null) {
              return false;
          }
          return str.startsWith("A");
      }
      ```

- 코틀린으로 표현한 코드

  - 예외 발생시키는 방식

    ```kotlin
    fun startsWithA(str: String?): Boolean {
        if (str == null) {
            throw IllegalArgumentException("null이 들어왔습니다.")
        }
        return str.startsWith("A")
    }
    ```

    - 매개변수가 `null`일 수 있기에 `String?`로 표기함
    - 반환 타입이 `null`일 수 없기에 `?` 붙이지 않고 `Boolean`으로 표기함

  - `null` 반환하는 방식

    ```kotlin
    fun startsWith(str: String?): Boolean? {
        if (str == null) {
            return null
        }
        return str.startsWith("A")
    }
    ```

    - `null` 값이 가능하기에 반환 타입은 `Boolean?`

  - `null`일 경우 기본값 설정하는 방식

    ```kotlin
    fun startsWith(str: String?): Boolean {
        if (str == null) {
            return false
        }
        return str.startsWith("A")
    }
    ```

- **코틀린은 `null`이 가능한 타입을 완전히 다르게 취급한다!**



### 2. Safe Call과 Elvis 연산자

- 코틀린에서는 nullable한 타입만을 위한 기능이 있음

- **Safe Call**

  - `null`이 아니면 실행하고, `null`이면 실행하지 않는다(그대로 `null`)

  - 예시 코드

    ```kotlin
    val str: String? = "ABC"
    str.length 	//호출이 불가능하다!
    str?.length	//가능하다
    ```

    - `null`이 아닌 경우에만 호출이 발생, `null`일 경우 `null`을 그대로 반환

- **Elvis 연산자**

  - 예시 코드

    ```kotlin
    val str: String? = "ABC"
    str?.length ?: 0
    ```

    - 앞의 연산 결과가 `null`이면 뒤의 값을 사용

- 예시 코드의 수정

  - 예외 발생시키는 방식

    ```kotlin
    fun startsWithA(str: String?): Boolean {
        return str?.startsWith("A") 
        ?: throw IllegalArgumentException("null이 들어왔습니다.")
    }
    ```

  - `null`을 반환하는 방식

    ```kotlin
    fun startsWithA(str: String?): Boolean? {
        return str?.startsWith("A")
    }
    ```

  - `null`일 경우 기본값 설정하는 방식

    ```kotlin
    fun startsWithA(str: String?): Boolean {
        return str?.startsWith("A") ?: false
    }
    ```

- **Elvis 연산자와 early return**

  - 자바의 경우

    ```java
    public long calculate(Long number) {
        if (number == null) {
            return 0;
        }
        //로직
    }
    ```

  - 코틀린의 경우

    ```kotlin
    fun calculate(number: Long?): Long {
        number ?: return 0;
        //로직
    }
    ```

    - `if`문을 사용하지 않음



### 3. `null` 아님 단언

- nullable한 타입이지만 `null`이 될 수 없는 경우

  - 예시 코드

    ```kotlin
    fun startsWithA(str: String?): Boolean {
        return str!!.startsWith("A")
    }
    ```

    - `!!`을 이용하여 단언 가능
    - 사용하지 않을 경우 컴파일 에러 발생
    - ***단, 위의 경우 `null`이 들어올 경우에 NPE 발생! 확실한 경우에만 단언 사용할 것!***



### 4. 플랫폼 타입

- 코틀린에서 자바 코드를 가져다 쓸 경우 

- 예시

  - 자바 클래스

    ```java
    public class Person {
        private final String name;
        
        public Person(String name) {
            this.name = name;
        }
        
        @Nullable
        public String getName() {
            return name;
        }
    }
    ```

  - 코틀린이 위의 자바 코드를 사용할 경우

    - `@Nullable`이나 `@NotNull` 등의 자바 애노테이션을 코틀린이 이해함
    - 하지만 위와 같은 애노테이션 정보가 없을 경우 코틀린은 해당 자바 코드에서 정보를 받지 못함
      - `javax.annotation` 패키지
      - `android.support.annotation` 패키지
      - `org.jetbrains.annotation` 패키지

- **플랫폼 타입**

  - 코틀린이 `null` 관련 정보를 알 수 없는 타입
  - 런타임에 `Exception` 발생 가능!

- **코틀린에서 자바 코드를 사용할 경우 대응법**

  - 자바 코드에 `null` 관련 정보를 명시해준다.
  - 외부 라이브러리를 사용할 경우
    - 라이브러리 내부 코드에서 nullable을 확인하고 사용하자
    - 코틀린에서 자바 라이브러리를 최초로 사용한 지점을 wrapping을 통해 단일지점으로 변경, 이슈에 대응하기 용이하게 만들자



## 3강. 코틀린에서 Type을 다루는 방법

### 1. 기본 타입

- 코틀린에서는 선언된 기본값을 보고 타입을 추론한다.

  - 정수

    ```kotlin
    val number1 = 3		//Int
    val number2 = 3L	//Long
    ```

  - 소수

    ```kotlin
    val number1 = 3.0f	//Float
    val number2 = 3.0	//Double
    ```

- **기본 타입간의 변환: 자바와의 차이점**

  - 자바의 경우 기본 타입간의 변환은 **암시적으로 이뤄질 수 있다.**

    ```java
    int number1 = 4;
    long number2 = number1;
    ```

    - `int` 타입 값이 `long` 타입으로 암시적 변경(더 큰 타입으로는 암시적 변경)

  - 코틀린의 경우 기본 타입간의 변환이 **명시적으로 이루어져야 한다.**

    ```kotlin
    val number1 = 4
    val number2: Long = number1	//Type mismatch로 컴파일 에러
    ```

    - 대신 `to변환타입()`을 사용하여 명시적 변경이 필요

      ```kotlin
      val number1 = 4
      val number2: Long = number1.toLong()
      ```

    - 예시2: 나눗셈 값을 실수로 받고 싶을 때

      ```kotlin
      val number1 = 3
      val number2 = 5
      val result = number1 / number2.toDouble()
      ```

      - 자바의 경우 `(double)` 이용했지만, 코틀린의 경우 `toDouble()`이용

- nullable 변수의 경우 Safe Call과 Elvis 연산자 이용하여 처리해줘야 함

  ```kotlin
  val number1: Int? =  3
  val number2: Long = number.toLong()		//불가능
  val number2: Long = number?.toLong() ?: 0L
  ```



### 2. 형변환

- 기본 타입이 아닌 일반 타입의 경우에는?

- 자바의 경우

  ```java
  public static void printAgeIfPerson(Object obj) {
      if (obj instanceof Person) {
          Person person = (Person) obj;
          System.out.println(person.getAge();
      }
  }
  ```

  - `instanceof`로 타입 검사, `(Person)`으로 형변환

- 코틀린의 경우

  ```kotlin
  fun printAgeIfPerson(obj: Any) {
      if (obj is Person) {
          val person = obj as Person
          println(person.age)
      }
  }
  ```

  - `instanceof` 대신에 `is`

  - `(Person)` 대신에  `as Person`

  - 사실 `as Person`은 생략 가능함

    ```kotlin
    println(obj.age)
    ```

    - 위의 호출이 가능: **스마트 캐스트**

- `as?`

  ```kotlin
  fun printAgeIfPerson(obj: Any?) {
      val person = obj as? Person
      println(person?.age)
  }
  ```

  - `as?` 만약 `null`이거나 해당 타입이 아닌 경우 `null`이 된다.
  - `person` 변수가 nullable하기에 `person?.age`로 처리했다.

- 정리

  - `is`: 해당 타입인지에 따라 T/F 반환
    - `value !is Type` 형태로 부정도 가능
  - `as`: 해당 타입일 경우에는 타입 캐스팅, 아닐 경우 `ClassCastException` 발생
    - `as?`: value가 해당 타입인 경우에는 타입 캐스팅, `null`이거나 해당 타입이 아닌 경우 `null`



### 3. Kotlin의 특이 타입 3가지

- **Any**

  - 자바의 `Object` 역할(모든 객체의 최상위 타입)
    - 모든 기본 자료형의 최상위 타입이기도 함
  - `Any` 만으로는 `null`을 포함 불가, `null`을 포함하고 싶을 경우 `Any?`
  - `equals` / `hashCode` / `toString` 존재

- **Unit**

  - 자바의 `void`와 동일한 역할
  - `void`와 달리 `Unit`은 그 자체로 타입 인자로 사용 가능
    - 자바의 경우 제네릭 사용을 위한 `Void`가 따로 있었음
  - 함수형 프로그래밍에서 `Unit`은 단 하나의 인스턴스만 갖는 타입을 의미한다.
    - 코틀린의 `Unit`은 실제 존재하는 타입임을 강조하기 위해 사용한 네이밍

- **Nothing**

  - 함수가 정상적으로 끝나지 않았음을 표현하는 역할

  - 무조건 예외를 반환하는 함수 / 무한 루프 함수 등을 표현하는 데 사용함

    ```kotlin
    fun fail(message: String): Noting {
        throw IlleagalArgumentException(message)
    }
    ```



### 4. String interpolation / String indexing

- 예시 코드

  - 자바의 경우

    ```java
    Person person = new Person("이름", 50);
    String log = String.format("이름은 %s이고 나이는 %s세 입니다.", person.getName(), person.getAge());
    ```

    - 혹은 `StringBuilder` 이용하여 동적으로 `String` 생성

  - 코틀린의 경우

    ```kotlin
    val person = Person("이름", 50)
    val log = "이름은 ${person.name}이고 나이는 ${person.age}세 입니다."
    ```

    - `${변수}`를 사용하여 값을 넣을 수 있음

    ```kotlin
    val name = "이름"
    println("이름: $name")
    ```

    - 중괄호 생략도 가능하다. (객체 내 프로퍼티 접근이 아닌 변수 바로 접근인 경우 사용 가능)
    - 변수 이름만 사용하더라도 **중괄호 포함하여 `${변수}` 형태로 사용함이 낫다.**
      - 가독성
      - 일괄 변환
      - 정규식 활용의 측면에서 그렇다.

- `"""` 이용한 문자열 표현

  ```kotlin
  val str = """
  	ABC
  	DEF
  	${name}
  """.trimIndent()
  ```

- 문자열의 특정 문자 가져오기

  - 자바의 경우 `str.charAt()` 사용했음

  - 코틀린의 경우 대괄호 사용하여 접근 가능

    ```kotlin
    val str = "ABC"
    println(str[2])		//C 출력됨
    ```



## 4강. 코틀린에서 연산자를 다루는 방법

### 1. 단항 연산자 / 산술 연산자

- 단항 연산자: `++`, `--`

- 산술 연산자: `+`, `-`, `*`, `/`, `%`

- 산술 대입 연산자: `+=`, `-=`, `*=`, `/=`, `%=`
- **자바와 모두 동일하다!**



### 2. 비교 연산자와 동등성, 동일성

- 비교 연산자: `>`, `<`, `>=`, `<=`
  - **자바와 달리 객체를 비교할 때 비교 연산자를 사용하면
    자동으로 `compareTo()`를 호출한다!**
- 코틀린에서 동일성과 동등성
  - `===`: 동일성
  - `==`: 동등성, **간접적으로 equals() 호출**



### 3. 논리 연산자와 코틀린에 있는 특이한 연산자

- 논리 연산자: 자바와 완전히 동일(`&&`, `||`, `!`)

  - 자바처럼 Lazy evaluation 수행함

- `in` / `!in` 연산자

  - 컬렉션이나 범위에 포함되어 있는지 검사

    ```kotlin
    println(1 in numbers)
    ```

- `..` 연산자 (`a..b`)

  - `a`에서 `b`까지의 범위 객체를 생성한다.

- `a[i]`

  - `a`에서 특정 Index `i`로 값을 가져온다.

- `a[i] = b`

  - `a`의 특정 index `i`에 `b`를 넣는다.



### 4. 연산자 오버로딩

- 코틀린에서는 객체마다 연산자를 직접 정의할 수 있다.

- 예시 코드

  ```kotlin
  data class Money(
      val amount: Long
  ) {
      operator fun plus(other: Money): Money {
          return Money(this.amount + other.amount)
      }
  }
  ```

  ```kotlin
  fun main() {
      val money1 = Money(1_000L)
      val money2 = Money(2_000L)
      println(money1 + money2)
  }
  ```

