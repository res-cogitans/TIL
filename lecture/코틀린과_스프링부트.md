# 코틀린과 스프링부트

## 리팩토링 준비하기

- H2 In-memory DB 사용시 콘솔 설정

  - `application.yml`

    ```yaml
      h2:
        console:
          enabled: true
          path: '/h2-console'
    ```

  - `localhost:8080/` + 설정한 `path`로 접근



### 코틀린 코드 작성 준비

- `build.gradle` 설정 추가

  ```groovy
  plugins {
      ...
      id 'org.jetbrains.kotlin.jvm' version '1.6.21'
  }
  
  dependencies {
    	...
      implementation 'org.jetbrains.kotlin:kotlin-stdlib-jdk8:'
    	...
  }
  
  compileKotlin {
      kotlinOptions {
          jvmTarget = "11"
      }
  }
  
  compileTestKotlin {
      kotlinOptions {
          jvmTarget = "11"
      }
  }
  ```

- 패키지 작업

  - `src`와 `test` 하위에 `kotlin` 경로를 추가해준다.
  - 만일 `gradle`이 경로를 인식하지 못했을 경우 디렉토리에 우클릭 -> `mark directory as` 통해 설정해준다.



### JUnit5 Test

#### 단언문

- `hasSize()`: 주어진 컬렉션의 `size` 검증

- 컬렉션 프로퍼티 검증

  ```kotlin
  val people = listOf(Person("A"), Person("B"))
  assertThat(people).extracting("name").containsExcactlyInAnyOrder("A", "B")
  ```

  - 주어진 컬렉션 내의 element들에서 `name`이라는 프로퍼티를 추출(`extracting`)한 후, 특정 값들이 포함되어 있는가를 검증

- 예외 검증: `assertThrows<>()`

  ```kotlin
  assertThrows<IllegalArgumentException> {
      function1()
  }
  ```

  - 자바와 달리 코틀린에서는 위와 같은 방식으로 실행 가능

  - 프로퍼티로 예외 메시지를 가짐

    ```kotlin
    val message = assertThrows<IllegalArgumentException> {
        function1()
    }.message
    ```

    

#### SpringBoot Test

- 레이어드 아키텍처

  ```mermaid
  flowchart BT
  A[Controller]
  B[Service]
  C[Domain]
  D[Repository]
  B-->A
  C-->B
  D-->B
  C-->D
  ```

  - Domain: POJO(순수한 자바객체)
  - Controller, Service, Repository: 스프링 빈
    - Service, Repository
      - 스프링 빈을 사용하는 테스트(`@SpringBootTest`)
      - 데이터 위주의 검증
    - Controller
      - 스프링 빈을 사용하는 테스트
      - 응답받은 JSON을 비롯한 HTTP 위주 검증
  - 테스트 코드와 `@Transactional`
    - [강사의 경우](https://www.youtube.com/watch?v=S_66BYHWT2A) 해당 애노테이션을 테스트에서 사용하는 것을 권장하지 않는다.
    - 나의 경우 `@PersistenceContext` 이용하여 해결하였다.

- 터미널에 `.gradlew test` 실행하여 전체 테스트 돌릴 수 있다.



## 자바 -> 코틀린 리팩토링

### 설정

- 플러그인 추가(`build.gradle`)

  - JPA 사용으로 인한 문제 해결

    ```groovy
    plugins {
            id 'org.jetbrains.kotlin.plugin.jpa' version '1.6.21'
    }
    ```

    - JPA `@Entity` 등의 경우 기본생성자가 존재해야 하는데, 이 부분을 해결해준다.

  - 코틀린 리플랙션 처리

    ```groovy
    dependencies {
        implementation 'org.jetbrains.kotlin:kotlin-reflect:1.6.21'
    }
    ```

    - `Caused by: java.lang.ClassNotFoundException: kotlin.reflect.full.KClasses` 해결



### Domain 리팩토링

- `User` 엔티티의 예시

  ```kotlin
  @Entity
  class User(
      var name: String,
      val age: Int?,
      @OneToMany(mappedBy = "user", cascade = [CascadeType.ALL], orphanRemoval = true) val userLoanHistories: MutableList<UserLoanHistory> = mutableListOf(),
      @Id @GeneratedValue(strategy = IDENTITY) val id: Long? = null,
  ) {
      init {
          if (name.isBlank()) {
              throw IllegalArgumentException("이름은 비어 있을 수 없습니다")
          }
      }
  
      fun updateName(name: String) {
          this.name = name
      }
  
      fun loanBook(book: Book) {
          this.userLoanHistories.add(UserLoanHistory(this, book.name, false))
      }
  
      fun returnBook(bookName: String) {
          this.userLoanHistories.first { history ->
              history.bookName == bookName
          }.doReturn()
      }
  }
  ```

  - 코틀린 관례상 **초기값이 할당되는 프로퍼티**인 `id`는 마지막 순서에 두었다.
  - `cascade`의 경우 설정 값을 배열로 받기 때문에 `[]` 내부에 값을 넣어준다.
  - 자바와 달리 코틀린의 경우 가변 / 불변 컬렉션을 구별하기에 변화할 수 있는 프로퍼티에 `MutableList` 사용한다. (할당된 `MutableList` 자체는 재할당되지 않기에 `val`로 선언한다.)
  - 불변식 검증은 `init` 블록으로 처리한다.
  - `.first`를 이용하여 컬렉션 내에서 조건에 맞는 첫 번째 element를 찾을 수 있다. 



### 코틀린 JPA

#### Setter

```kotlin
@Entity
class User(
    var name: String,
    ...
)

fun updateName(name: String) {
    this.name = name
}
```

- 생성자 내에 `var` 프로퍼티를 가지고 있음에도, 별도의 `setter` 역할 함수를 만들어주었다.

  - 별도의 이름을 붙인 함수가 더 표현력이 있기 때문임
  - `name`의 `setter`가 `public`이기에 해당 프로퍼티 업데이트 시에 `setter` 사용이 가능하다.
    - 굳이 같은 기능을 가진 `setter`를 `public`하게 열어주는 것은 혼란을 주기에 잠그는 것이 좋다!

- `getter`에 영향 주지 않으면서 `setter` 접근 제어자 변경

  - `backing property` 사용하는 방식

    ```kotlin
    class User(
        private var _name: String
    ) {
        
        val name: String
        	get() = this._name
    }
    ```

    - `backing property`
      - 위 코드의 `_name`에 해당

  - `custom setter` 사용하기

    ```kotlin
    class User(
        name: String
    ) {
        
        var name: = name
        	private set
        
    }
    ```

  - 두 방식 모두 프로퍼티가 많아질수록 코드가 지나치게 길어진다는 문제가 있다!
    팀 내 모두가 `setter`를 사용하지 않는다면 `setter`를 `public`으로 열어두는 방법도 가능하다.
    (Trade-off의 영역)



#### 생성자 내의 프로퍼티 vs 클래스 body의 프로퍼티

- 꼭 생성자 안에 모든 프로퍼티를 쑤셔넣을 필요는 없다. Java 스타일로 클래스 body 안에 프로퍼티를 넣을 수도 있다.
- 다음 두 가지 중 하나를 선택함이 좋다:
  - 모든 프로퍼티를 생성자에 넣기
  - 생성자 vs 클래스 body에 넣는 명확한 기준을 가지기



#### JPA와 data class

> **Entity는 data class를 피하는 것이 좋다**

- `equals`, `hashCode`, `toString` 모두 JPA와는 어울리지 않기 때문이다.
  - 연관관계를 따라 무환 순환 문제가 발생하는 위험을 생각해보자.



#### 그외의 팁

- Entity 생성 로직을 찾고 싶다면 `constructor` 키워드를 명시적으로 작성하고 추적하자!
  - 생성자에 `constructor` 명시하고 IDE를 이용하여 쉽게 검색 가능하다.



### Service 리팩토링

- 스프링 AOP 관련 처리

  - `@Transactional` 애너테이션을 붙이려고 하면, 기본적으로 상속 불가인 코틀린의 특성상 추가적인 처리(`open` 키워드 붙이기)가 필요하다. 일일히 `open` 키워드를 붙여주는 것은 불편하니 플러그인을 추가하는 방식으로 해결한다.

  - `build.gradle`

    ```groovy
    plugins {
        id 'org.jetbrains.kotlin.plugin.spring' version '1.6.21'
    }
    ```

- `Optional` 제거하기

  - 자바와 달리 코틀린의 경우 `?` 연산자를 이용한 `null` 처리가 가능하기에 굳이 `Optional`을 사용할 필요가 없다.

  - `Optional` 제거한 1차 리팩토링

    ```kotlin
            val user = userRepository.findByName(name) ?: throw IllegalArgumentException()
            userRepository.delete(user)
    ```

    - 그런데, nullable한 엔티티를 불러오는 코드 부분마다 위와 같이 `throw IllegalArgumentException()` 반복해주는 것은 불편하다.

    - 이를 별도의 유틸 함수로 분리할 수 있다:

      ```kotlin
      fun fail(): Nothing {
          throw IllegalArgumentException()
      }
      ```

  - 유틸 함수로 빼낸 2차 리팩토링

    ```kotlin
        @Transactional
        fun returnBook(request: BookReturnRequest) {
            val user = userRepository.findByName(request.userName) ?: fail()
            user.returnBook(request.bookName)
        }
    ```

    - 한 군데로 실패 로직을 빼낼 수 있다.

  - `findById()` 관련 리팩토링

    - Spring Data JPA 사용 시 `JpaRepository` 이용했을때 자동 생성되는 메서드는 `Optional`을 반환하게 되어 있다.
    - `CrudRepositoryExtensions`의 확장 함수 `findByIdOrNull()`을 이용하여 `Optional` 사용하지 않는 형태로 활용 가능하다.

    ````kotlin
        @Transactional
        fun updateUserName(request: UserUpdateRequest) {
            val user = userRepository.findByIdOrNull(request.id) ?: fail()
            user.updateName(request.name)
        }
    ````

  - `findById()` 2차 리팩토링
  
    ```kotlin
    fun <T, ID> CrudRepository<T, ID>.findByIdOrThrows(id: ID): T {
        return this.findByIdOrNull(id) ?: fail()
    }
    ```
  
    - 확장 함수로 `null`일 경우 `fail()` 호출하는 로직까지 묶어서 관리할 수 있다.
  
    - 호출 코드: 좀 더 간결해졌다.
  
      ```kotlin
          @Transactional
          fun updateUserName(request: UserUpdateRequest) {
              val user = userRepository.findByIdOrThrows(request.id)
              user.updateName(request.name)
          }
      ```



### DTO 리팩토링

- convert java file to kotlin
  - 여러 파일을 변경하고 싶을 때 사용
  - 패키지 경로에서 우클릭 혹은 `Shift + Option + Command + K`
- 컨벤션에 따라 고려해보자:
  - `data class`로 만들기
  - 생성자 체이닝을 사용하거나, 정적 팩토리 메서드 사용하기



### Controller 리팩토링

- `@RequestParam`

  ```kotlin
      @DeleteMapping("/user")
      fun deleteUser(@RequestParam name: String) {
          userService.deleteUser(name)
      }
  ```

  - `@RequestParam`의 `required` 기본값은 `true`다. 하지만 코틀린 스프링의 경우 해당 매개변수의 타입을 `nullable`하게 줄 경우(ex. String?) `required` 값을 자동적으로 `false`로 처리해준다.
  - `required`를 `false`로 처리하고 싶다면 해당 매개변수의 타입을 `nullable`하지 않게 선언해주자.



### `@SpringBootApplication` 리팩토링

```kotlin
@SpringBootApplication
class LibraryAppApplication

fun main(args: Array<String>) {
    runApplication<LibraryAppApplication>(*args)
}
```

- 해당 클래스 최상단에 있는 함수는 정적 함수와 동일하게 취급된다.



### Jackson 직렬화 이슈 해결

- 전체 프로젝트를 코틀린으로 변경하고 나면 직렬화 문제로 인해 오작동하는 부분이 있음을 확인할 수 있다.

- `build.gradle`

  ```kotlin
  dependencies{
      implementation 'com.fasterxml.jackson.module:jackson-module-kotlin:2.13.3'
  }
  ```


