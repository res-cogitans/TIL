# 코틀린과 스프링부트

## 리팩토링 준비하기

- H2 In-memory DB 사용시 콘솔 설정

  - `application.yml`

    ```yaml
      h2:
        console:
          enabled: true
          path: '/h2-console'
    ```

  - `localhost:8080/` + 설정한 `path`로 접근



### 코틀린 코드 작성 준비

- `build.gradle` 설정 추가

  ```groovy
  plugins {
      ...
      id 'org.jetbrains.kotlin.jvm' version '1.6.21'
  }
  
  dependencies {
    	...
      implementation 'org.jetbrains.kotlin:kotlin-stdlib-jdk8:'
    	...
  }
  
  compileKotlin {
      kotlinOptions {
          jvmTarget = "11"
      }
  }
  
  compileTestKotlin {
      kotlinOptions {
          jvmTarget = "11"
      }
  }
  ```

- 패키지 작업

  - `src`와 `test` 하위에 `kotlin` 경로를 추가해준다.
  - 만일 `gradle`이 경로를 인식하지 못했을 경우 디렉토리에 우클릭 -> `mark directory as` 통해 설정해준다.



### JUnit5 Test

#### 단언문

- `hasSize()`: 주어진 컬렉션의 `size` 검증

- 컬렉션 프로퍼티 검증

  ```kotlin
  val people = listOf(Person("A"), Person("B"))
  assertThat(people).extracting("name").containsExcactlyInAnyOrder("A", "B")
  ```

  - 주어진 컬렉션 내의 element들에서 `name`이라는 프로퍼티를 추출(`extracting`)한 후, 특정 값들이 포함되어 있는가를 검증

- 예외 검증: `assertThrows<>()`

  ```kotlin
  assertThrows<IllegalArgumentException> {
      function1()
  }
  ```

  - 자바와 달리 코틀린에서는 위와 같은 방식으로 실행 가능

  - 프로퍼티로 예외 메시지를 가짐

    ```kotlin
    val message = assertThrows<IllegalArgumentException> {
        function1()
    }.message
    ```

    

#### SpringBoot Test

- 레이어드 아키텍처

  ```mermaid
  flowchart BT
  A[Controller]
  B[Service]
  C[Domain]
  D[Repository]
  B-->A
  C-->B
  D-->B
  C-->D
  ```

  - Domain: POJO(순수한 자바객체)
  - Controller, Service, Repository: 스프링 빈
    - Service, Repository
      - 스프링 빈을 사용하는 테스트(`@SpringBootTest`)
      - 데이터 위주의 검증
    - Controller
      - 스프링 빈을 사용하는 테스트
      - 응답받은 JSON을 비롯한 HTTP 위주 검증
  - 테스트 코드와 `@Transactional`
    - [강사의 경우](https://www.youtube.com/watch?v=S_66BYHWT2A) 해당 애노테이션을 테스트에서 사용하는 것을 권장하지 않는다.
    - 나의 경우 `@PersistenceContext` 이용하여 해결하였다.

- 터미널에 `.gradlew test` 실행하여 전체 테스트 돌릴 수 있다.



## 자바 -> 코틀린 리팩토링

