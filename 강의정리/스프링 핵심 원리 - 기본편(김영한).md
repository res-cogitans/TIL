---


---

<h1 id="스프링-핵심-원리---기본편김영한">스프링 핵심 원리 - 기본편(김영한)</h1>
<h2 id="객체-지향-설계와-스프링">객체 지향 설계와 스프링</h2>
<p><strong>E</strong>nterprise <strong>J</strong>ava <strong>B</strong>eans: 자바 표준 기술<br>
EJB는 다수의 기능을 지원했지만, 사용하기 복잡하고 어려웠으며, 성능이 느렸다. 심지어 값비쌌음.<br>
EJB의 복잡성으로 인해 <strong>P</strong>lain <strong>O</strong>ld <strong>J</strong>ava <strong>O</strong>bject가 등장하기도 함.<br>
EJB의 문제 해결을 위해 대두한 오픈 소스 기술들: <strong>스프링, 하이버네이트</strong></p>
<p><strong>스프링</strong></p>
<ul>
<li>EJB 컨테이너 대체</li>
<li>단순함</li>
<li>현재 사실상 표준 기술</li>
</ul>
<p><strong>하이버네이트(Hibernate)</strong></p>
<ul>
<li>EJB 엔티티빈 기술을 대체</li>
<li><strong>J</strong>ava <strong>P</strong>ersistence <strong>A</strong>PI의 새로운 표준을 정의<br>
EJB 엔티티빈 -&gt; 하이버네이트 -&gt; JPA(자바표준)</li>
<li>표준 인터페이스 JPA와 그 구현체 (주로) 하이버네이트, EclipseLink 등</li>
</ul>
<p>-&gt; 현대 자바 개발자에게 가장 중요한 두 기술: <strong>스프링, 하이버네이트</strong></p>
<hr>
<h3 id="스프링의-역사">스프링의 역사</h3>
<p><strong>Rod Johnson, “J2EE Design and Development”(2002)</strong></p>
<ul>
<li>EJB의 문제점 지적</li>
<li>EJB 없이 제작한 애플리케이션 예시, 스프링 핵심 개념, 기반 코드</li>
<li><strong>BeanFactory, ApplicationContext, POJO, 제어의 역전, 의존관계 주입(DI)</strong></li>
<li>Juergen Hoeller, Yann Caroff가 오픈소스 프로젝트 제안, 개발</li>
<li>J2EE(EJB)-겨울을 넘어서 새로운 시작이라는 의미로 스프링</li>
</ul>
<p><strong>릴리즈</strong></p>
<ul>
<li>2003, 1.0 - Xml 기반</li>
<li>2006, 2.0 - Xml 편의기능</li>
<li>2009, 3.0 - 자바 코드로 설정(스프링은 설정이 매우 난해했음)</li>
<li>2013, 4.0 - 자바8</li>
<li>2014, 스프링부트 1.0</li>
<li>2017, 5.0, 부트 2.0 -리엑티브 프로그래밍 지원(비동기 NumBlocking Node.js유사</li>
<li>현재 5.2.x 부트 2.3x</li>
</ul>
<hr>
<h3 id="스프링이란">스프링이란?</h3>
<p>스프링은 단일 기술이 아니라 다수 기술의 모음</p>
<ul>
<li>핵심: 스프링 프레임워크, 스프링 부트</li>
<li>선택:
<ul>
<li>스프링 데이터: DB사용을 도움, ex) 스프링데이터 Jpa</li>
<li>스프링 세션</li>
<li>스프링 시큐리티</li>
<li>스프링 Rest Docs(API문서화, 테스트)</li>
<li>스프링 배치</li>
<li>스프링 클라우드</li>
<li>etc . . . (공식 사이트의 project 참조)</li>
</ul>
</li>
</ul>
<p><strong>스프링 프레임워크</strong></p>
<ul>
<li>핵심 기술: 스프링 DI 컨테이너, AOP, 이벤트, 기타</li>
<li>웹 기술: 스프링 MVC, 스프링 WebFlux</li>
<li>데이터 접근 기술: 트랜젝션, JDBC, ORM 지원, XML 지원</li>
<li>기술 통합: 캐시, 이메일, 원격접근, 스케줄링</li>
<li>테스트: 스프링 기반 테스트 지원</li>
<li>언어: 코틀린, 그루비</li>
<li>스프링 부트를 통해서 스프링 / 스프링 프레임워크의 기술들을 편리하게 사용 가능.</li>
</ul>
<p><strong>스프링 부트</strong></p>
<ul>
<li>단독 실행 가능한 스프링 애플리케이션을 쉽게 생성</li>
<li>Tomcat 같은 웹 서버를 내장, 별도의 웹 서버 설치 불필요.</li>
<li>손쉬운 빌드 구성을 위한 starter 종속성 제공(라이브러리 종속성 관리 build.gradle 참조)</li>
<li>스프링과 3rd party(외부) 라이브러리 자동 구성(버전당 써드파티 라이브러리 호환성 관리)</li>
<li>메트릭, 상태 확인, 외부 구성 같은 프로덕션 준비 기능 제공(모니터링 환경)</li>
<li>관례에 의한 간결한 설정(디폴트 설정 + 메뉴얼이 잘 되어있음)</li>
</ul>
<p><strong>스프링이라는 단어</strong></p>
<ul>
<li>스프링 DI 컨테이너 기술</li>
<li>스프링 프레임워크</li>
<li><strong>스프링 생태계 전체</strong></li>
</ul>
<p><strong>스프링의 제작 이유 - 핵심 개념</strong></p>
<ul>
<li><strong>자바</strong> 기반 프레임워크: <strong>객체 지향</strong></li>
<li>스프링은 <strong>좋은 객체 지향</strong> 애플리케이션 개발을 돕는 프레임워크</li>
<li>그것을 돕는 <strong>DI 컨테이너</strong></li>
</ul>
<hr>
<h3 id="좋은-객체-지향-프로그래밍">좋은 객체 지향 프로그래밍</h3>
<p><strong>다형성(Polymorphism)</strong></p>
<ul>
<li>객체지향 프로그래밍이 컴포넌트 교체 등으로 인해 <strong>단순, 유연, 변경 용이</strong>하게 만드는 이유.</li>
<li>자동차의 예시) 개별 자동차들이 자동차라는 인터페이스의 구현체이기에, 무한히 확장 가능하며(<strong>확장 가능한 설계</strong>), 운전자에게 영향을 주지 않아도 됨.</li>
<li><strong>역할</strong>과 <strong>구현</strong>을 분리해서 가능한 것!</li>
</ul>
<p><strong>역할과 구현의 분리</strong></p>
<ul>
<li>클라이언트는
<ul>
<li>대상의 역할(인터페이스)만 알면 된다.</li>
<li>대상의 내부 구조를 몰라도 된다.</li>
<li>대상의 내부 구조가 변경되어도 영향 받지 않는다.</li>
<li>구현 대상 자체가 변경되어도 영향 받지 않는다.<br>
-&gt; <strong>추상화, 캡슐화</strong> 등과도 일맥상통.</li>
</ul>
</li>
<li>자바 언어의 다형성:
<ul>
<li>역할 = 인터페이스</li>
<li>구현 = 구현 클래스, 객체</li>
</ul>
</li>
<li>객체 설계시 역할과 구현의 분리</li>
<li>역할(인터페이스)를 먼저 부여하고, 그것의 구현체를 만들어야.</li>
</ul>
<p><strong>객체의 협력</strong></p>
<ul>
<li>객체는 협력관계
<ul>
<li>클라이언트는 요청, 서버는 응답</li>
<li>이런 구조는 중첩될 수도 있다.</li>
</ul>
</li>
</ul>
<p><strong>자바 언어의 다형성 - 오버라이딩</strong></p>
<ul>
<li>다형성으로 인터페이스를 구현한 객체를 실행 시점에 유연하게 변경 가능</li>
<li>클래스 상속 관계에서도 마찬가지</li>
<li>예시: 클라이언트는 MemberRepository에 의존(인식), 이 MemberRepository 자리에 여러 구현체들로 역할 구현 가능.</li>
<li><strong>클라이언트를 변경하지 않고, 서버의 구현 기능을 유연하게 변경 가능.</strong></li>
</ul>
<p><strong>한계점</strong></p>
<ul>
<li>역할 자체의 변화가 발생시 큰 변경 발생.<br>
-&gt; <strong>인터페이스의 설계 중요성</strong></li>
</ul>
<p><strong>스프링과 객체 지향</strong></p>
<ul>
<li><strong>제어의 역전(IoC), 의존관계 주입(DI)</strong> 등은 <strong>다형성</strong>을 활용하여 <strong>역할</strong>과 <strong>구현</strong>을 편리하게 다룰 수 있게 지원함.</li>
</ul>
<hr>
<h3 id="solid-원칙">SOLID 원칙</h3>
<p><strong>SOLID</strong>: 로버트 마틴(클린 코드)가 정리한 좋은 객체 지향 설계의 5원칙</p>
<ul>
<li><strong>SRP</strong>: 단일 책임 원칙(<strong>S</strong>ingle <strong>R</strong>esponsibility <strong>P</strong>rinciple)</li>
<li><strong>OCP</strong>: 개방-폐쇄 원칙(<strong>O</strong>pen/<strong>C</strong>losed <strong>P</strong>rinciple)</li>
<li><strong>LSP</strong>: 리스코프 치환 원칙(<strong>L</strong>iskov <strong>S</strong>ubstitution <strong>P</strong>rinciple)</li>
<li><strong>ISP</strong>: 인터페이스 분리 원칙(<strong>I</strong>nterface <strong>S</strong>egregation <strong>P</strong>rinciple)</li>
<li><strong>DIP</strong>: 의존관계 분리 원칙(<strong>D</strong>ependency <strong>I</strong>nversion <strong>P</strong>rinciple)</li>
</ul>
<p><strong>SRP 단일 책임 원칙</strong>(<strong>S</strong>ingle <strong>R</strong>esponsibility <strong>P</strong>rinciple)</p>
<ul>
<li>한 클래스는 하나의 책임만 가져야 한다.</li>
<li>이 범위를 적절히 조절하는 것이 핵심.</li>
<li>중요한 기준은 <strong>변경</strong>, 변경 시 파급 효과가 적다면 이 원칙을 잘 따른 것.</li>
</ul>
<p><strong>OCP 개방-폐쇄 원칙</strong>(<strong>O</strong>pen/<strong>C</strong>losed <strong>P</strong>rinciple)</p>
<ul>
<li>소프트웨어 요소는 <strong>확장에는 열려</strong> 있으나 <strong>변경에는 닫혀</strong> 있어야 한다.</li>
<li>인터페이스의 새 구현체를 만들어서 새로운 기능을 구현<br>
<strong>문제점</strong>
<ul>
<li>MemberService 클라이언트가 구현 클래스를 직접 선택</li>
<li><code>MemberRepository m = new MemoryMemberRepository();</code>에서</li>
<li><code>MemberRepository m = new JdbcMemberRepository();</code>로 변경</li>
<li>구현 객체를 변경하려면 클라이언트 코드를 변경해야 함.</li>
<li><strong>다형성을 사용했으나, OCP를 지키지 못함.</strong></li>
<li><strong>해결</strong>:객체를 생성하고, 연관관계를 맺어주는 별도의 조립, 설정자가 필요.<br>
-&gt; <strong>스프링의 필요</strong></li>
</ul>
</li>
</ul>
<p><strong>LSP 리스코프 치환 원칙</strong>(<strong>L</strong>iskov <strong>S</strong>ubstitution <strong>P</strong>rinciple)</p>
<ul>
<li>프로그램의 객체는 프로그램의 정확성을 깨뜨리지 않으면서 하위 타입의 인스턴스로 바꿀 수 있어야 한다.</li>
<li>다형성에서 하위 클래스는 인터페이스 규약을 다 지켜야 한다는 것.</li>
</ul>
<p><strong>ISP 인터페이스 분리 원칙</strong>(<strong>I</strong>nterface <strong>S</strong>egregation <strong>P</strong>rinciple)</p>
<ul>
<li>특정 클라이언트를 위한 인터페이스 여러 개가 범용 인터페이스 하나보다 낫다. -&gt; <strong>쪼개라</strong></li>
<li>인터페이스가 명확해지고 대체 가능성이 높아진다.</li>
</ul>
<p><strong>DIP 의존관계 분리 원칙</strong>(<strong>D</strong>ependency <strong>I</strong>nversion <strong>P</strong>rinciple)</p>
<ul>
<li><strong>"프로그래머는 추상화에 의존해야지 구체화에 의존하면 안 된다."</strong></li>
<li>구현에 의존하지 말고 <strong>역할(인터페이스)에 의존</strong>하라, 구현이 아닌 역할을 알게끔 하라.<br>
<strong>위반사례</strong>
<ul>
<li>클래스 MemberService의 코드 <code>MemberRepository m = new MemoryMemberRepository();</code>의 경우</li>
<li>인터페이스 MemberRepository 뿐만 아니라 MemoryMemberRepository 구현체에도 동시 의존한다.</li>
<li>클라이언트가 구현 클래스를 직접 선택하고 있음.</li>
</ul>
</li>
</ul>
<p><strong>정리</strong><br>
다형성 만으로는</p>
<ul>
<li>클라이언트 코드 변경 없이 구현체의 유연한 교체가 불가능하다!</li>
<li>OCP, DIP를 지킬 수 없다.<br>
-&gt; 스프링의 필요성</li>
</ul>
<hr>
<h3 id="객체-지향-설계와-스프링-1">객체 지향 설계와 스프링</h3>
<p>스프링이 <strong>다형성 + OCP, DIP</strong> 가능하게 지원하는 수단</p>
<ul>
<li>DI: 의존관계, 의존성 주입</li>
<li>DI 컨테이너 제공</li>
<li>순수 자바로 객체지향적 개발을 하려면 생산성이 낮음<br>
-&gt; 스프링 프레임워크의 등장.</li>
</ul>
<p><strong>정리</strong></p>
<ul>
<li>설계와 구현의 분리</li>
<li><strong>이상적으로, 모든 설계에 인터페이스를 부여하라.</strong></li>
<li><strong>현실적으로, 인터페이스 남발은 추상화 비용(생산성)이 발생</strong><br>
때문에 기능 확장 가능성이 없을 때는 구체적 클래스를 사용하고 필요할 때 리팩토링으로 인터페이스를 도입하는 방법을 고려.</li>
</ul>
<hr>
<h2 id="스프링-핵심-원리-이해1---예제-만들기">스프링 핵심 원리 이해1 - 예제 만들기</h2>
<ul>
<li>
<p>회원 도메인 협력관계: 기획자들도 볼 수 있는 레벨</p>
</li>
<li>
<p>클라이언트 -&gt; 회원 서비스 -&gt; 회원 저장소</p>
</li>
<li>
<p>회원 클래스 다이어그램(구체화) - 정적</p>
</li>
<li>
<p>회원 객체 다이어그램(실사용-인스턴스간 참조) - 동적</p>
</li>
<li>
<p>MMR =&gt; HashMap 대신 ConcurrentHashMap(동시성 이슈 대비)</p>
</li>
<li>
<p>MemberServiceImpl -&gt; 단일 구현체면 Impl식 작명</p>
</li>
<li>
<p>역할을 먼저 만들고, 구현체를 나중에 만듦 -&gt; 유연한 교체가 가능</p>
</li>
</ul>
<h2 id="스프링-핵심-원리-이해2---객체-지향-원리-적용">스프링 핵심 원리 이해2 - 객체 지향 원리 적용</h2>
<ul>
<li>@Test 아래의 @Displayname(String value) 어노테이션은 테스트시 제목표시</li>
<li>테스트에는 반대 케이스도 만들어야 한다.</li>
</ul>
<p>-&gt; 예제에서 DIP OCP 위반한다.<br>
-&gt; 인터페이스만 바라보게 하면 구현체가 없음. NPE<br>
-&gt; 외부에서 DI 해줘야함.</p>
<p>구현체가 다른 인터페이스 뿐만 아니라 그 구현체까지 바라보고 있음. <strong>관심사의 분리</strong>가 필요.</p>
<h3 id="appconfig">AppConfig</h3>
<p><strong>구현 객체를 생성하고 연결하는 책임</strong>을 갖는 별도의 설정 클래스</p>
<pre class=" language-java"><code class="prism  language-java"><span class="token keyword">package</span> logos<span class="token punctuation">.</span>springCore<span class="token punctuation">;</span>  
  
<span class="token keyword">import</span> logos<span class="token punctuation">.</span>springCore<span class="token punctuation">.</span>discount<span class="token punctuation">.</span>RateDiscountPolicy<span class="token punctuation">;</span>  
<span class="token keyword">import</span> logos<span class="token punctuation">.</span>springCore<span class="token punctuation">.</span>member<span class="token punctuation">.</span>MemberService<span class="token punctuation">;</span>  
<span class="token keyword">import</span> logos<span class="token punctuation">.</span>springCore<span class="token punctuation">.</span>member<span class="token punctuation">.</span>MemberServiceImpl<span class="token punctuation">;</span>  
<span class="token keyword">import</span> logos<span class="token punctuation">.</span>springCore<span class="token punctuation">.</span>member<span class="token punctuation">.</span>MemoryMemberRepository<span class="token punctuation">;</span>  
<span class="token keyword">import</span> logos<span class="token punctuation">.</span>springCore<span class="token punctuation">.</span>order<span class="token punctuation">.</span>OrderService<span class="token punctuation">;</span>  
<span class="token keyword">import</span> logos<span class="token punctuation">.</span>springCore<span class="token punctuation">.</span>order<span class="token punctuation">.</span>OrderServiceImpl<span class="token punctuation">;</span>  
  
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">AppConfig</span> <span class="token punctuation">{</span>  
  
    <span class="token punctuation">;</span>  
  
 <span class="token keyword">public</span> MemberService <span class="token function">memberService</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  
        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">MemberServiceImpl</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">MemoryMemberRepository</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
  <span class="token punctuation">}</span>  
  
    <span class="token keyword">public</span> OrderService <span class="token function">orderService</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  
        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">OrderServiceImpl</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">MemoryMemberRepository</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">RateDiscountPolicy</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
  <span class="token punctuation">}</span>
  
<span class="token punctuation">}</span>
</code></pre>
<p>생성 객체 인스턴스의 참조(레퍼런스)를 생성자를 통해서 주입(연결) 해준다. (<strong>생성자 주입</strong>)<br>
-&gt; <strong>DIP 완성, 관심사의 분리</strong></p>
<ul>
<li>리팩토링을 통해 의존관계, 어떤 구현체 사용하는지를 잘 드러내줘야 한다.</li>
<li>사용 영역과 구성 영역(AppConfig)의 분리</li>
</ul>
<h3 id="ioc-di-컨테이너">IOC, DI, 컨테이너</h3>
<dl>
<dt><strong>제어의 역전 IoC(Inversion of Control)</strong></dt>
<dd>AppConfig가 제어흐름을 통제</dd>
</dl>
<p><strong>프레임워크 vs 라이브러리</strong></p>
<ul>
<li>프레임워크가 내가 작성한 코드를 제어하고, 대신 실행하면 그것은 프레임워크가 맞다. (JUnit)</li>
<li>반면에 내가 작성한 코드가 직접 제어의 흐름을 담당한다면 그것은 라이브러리다.</li>
</ul>
<dl>
<dt><strong>의존관계 주입Dependency Injection</strong></dt>
<dd>정적인 클래스 의존 관계와 동적 객체 의존관계를 구별하라.<br>
정적인 클래스 의존관계만으로는 실제로 어떤 구현체가 주입되는지는 모름, 이는 런타임에 외부에서 실제 구현객체를 생성, 전달하여 그 관계가 연결된다.</dd>
<dt><strong>IoC 컨테이너, DI 컨테이너</strong></dt>
<dd>위의 AppConfig처럼 객체를 생성, 관리, 의존관계 연결해주는 것.<br>
최근에는 DI에 초점을 맞춰 DI컨테이너라 주로 말함.<br>
혹은 어셈블러, 오브젝트 팩토리 등으로 불리기도 함.</dd>
</dl>
<h2 id="스프링-컨테이너와-스프링-빈">스프링 컨테이너와 스프링 빈</h2>
<h3 id="스프링-컨테이너">스프링 컨테이너</h3>
<ul>
<li>ApplicationContext / BeanFactory를 스프링 컨테이너라 한다.</li>
<li>기존에는 개발자가 AppConfig를 이용, 객체 생성, DI했지만 이제 스프링 컨테이너를 통해 사용한다.</li>
<li>스프링 컨테이너는 @Configuration이 붙은 AppConfig를 설정(구성) 정보로 사용한다. 여기서 @Bean이라 적힌 메소드를 모두 호출, 반환된 객체를 스프링 컨테이너에 등록한다. 이 등록된 객체를 스프링 빈이라 한다.</li>
<li>객체를 직접 생성, 호출이 아니라 스프링 컨테이너를 이용해서 찾아야 함. 스프링 빈은 <code>applicationContext.getBean()</code>메서드 사용해서 찾을 수 있다.</li>
<li>스프링 컨테이너는 XML기반으로 혹은 어노테이션 기반 자바 설정 클래스로 만들 수 있다.</li>
<li>ApplicationContext는 인터페이스, AnnotationConfigApplicationContext는 그것의 구현체.</li>
</ul>
<ol>
<li>스프링 컨테이너 생성</li>
</ol>
<table border="2"><tbody><tr><td>스프링 컨테이너<table border="2"><tbody><tr><td>스프링 빈 저장소</td></tr><tr><td>빈 이름</td><td>빈 객체</td></tr></tbody></table></td></tr></tbody></table>
<ol start="2">
<li>구성 정보 활용(AppConfig.class가 구성 정보로 지정)</li>
<li>스프링 빈 등록(컨테이너가 설정 클래스 정보로 스프링 빈을 등록)
<ul>
<li>주의! 빈 이름은 직접 부여할 수도 있지만, 빈 이름은 항상 다른 이름을 부여해야 한다! 무시되게나, 덮거나, 오류 발생 가능.</li>
</ul>
</li>
<li>스프링 빈 의존관계 설정-준비</li>
<li>스프링 빈 의존관계 설정-완료(설정관계를 참고해서 의존관계를 주입)</li>
</ol>
<ul>
<li>스프링은 빈을 생성하고, 의존관계를 주입하는 단계가 나누어져 있음. 단 자바 코드로 스프링 빈은 등록하면 빈 생성과 의존관계 주입이 동시 처리됨.</li>
</ul>
<h3 id="스프링-빈-조회">스프링 빈 조회</h3>
<ul>
<li>동일한 타입의 빈이 둘 이상일 때 오류가 발생한다(<code>NoUniqueBeanDefinitionException</code>). 이 경우 빈 이름을 지정해야.</li>
<li>부모 타입 스프링 빈 조회시 자식 타입 모두가 조회된다.</li>
</ul>
<h3 id="beanfactory와-applicationcontext">BeanFactory와 ApplicationContext</h3>
<p>Interface <strong>BeanFactory</strong><br>
Interface <strong>ApplicationContext</strong> implements BeanFactory<br>
class <strong>AnnotationConfigApplicationContext</strong> implements ApplicationContext</p>
<p><strong>BeanFactory</strong></p>
<ul>
<li>스프링 컨테이너의 최상위 인터페이스</li>
<li>스프링 빈을 관리, 조회</li>
<li><code>getBean()</code>을 제공</li>
</ul>
<p><strong>ApplicationContext</strong></p>
<ul>
<li>BeanFactory 기능을 모두 상속</li>
<li>부가기능들: implements MessageSource, EnvironmentCapable, ApplicationEventPublisher, ResourceLoader (모두 Interface)
<ul>
<li>MessageSource: 국제화 기능(접속위치에 따라 다른 언어로 출력)</li>
<li>EnvironmentCapable: 환경변수로 로컬, 개발, 운영등을 구분해서 처리, 환경별로 어떤 DB 연결할지 등</li>
<li>ApplicationEventPublisher: 이벤트를 발행하고 구독하는 모델 지원</li>
<li>ResourceLoader: 편리한 리소스 조회</li>
</ul>
</li>
</ul>
<h3 id="xml로-설정">XML로 설정</h3>
<ul>
<li>스프링 컨테이너는 자바 코드, XML, Groovy 등 여러 방식의 설정 정보를 받아들일 수 있다.</li>
<li>AnnotationConfigApplicationContext implements ApplicationContext -&gt; AppConfig.class</li>
<li>GenericXmlApplicationContext implements ApplicationContext -&gt; appConfig.xml</li>
<li>???ApplicationContext implements ApplicationContext -&gt; appConfig.??? (임의의 구현)</li>
<li>Xml의 경우, 스프링부트의 사용으로 인해 사용이 거의 없어짐. 단 컴파일 없이 빈 설정 정보를 변경할 수 있다는 장점이 있다.</li>
</ul>
<h3 id="스프링-빈-설정-메타-정보---beandefinition">스프링 빈 설정 메타 정보 - BeanDefinition</h3>
<ul>
<li>
<p>빈 설정 메타정보라 한다.</p>
</li>
<li>
<p>이 또한 추상화를 이용한 것이다.</p>
</li>
<li>
<p>스프링 컨테이너 -&gt; BeanDefinition 을 바라보고 있음,<br>
스프링 컨테이너는 BeanDefinition을 AppConfig.class가 구현하는지, appConfig.xml이 구현하는지 알 필요 없음.</p>
</li>
<li>
<p>ApplicationContext의 구현 AnnotationConfigApplicationContext의 AnnotatedBeanDefinitionReader가 AppConfig.class를 읽어서 BeanDefinition(빈 메타정보)를 생성한다.</p>
</li>
<li>
<p>BeanDefinition을 직접 생성해서 스프링 컨테이너에 등록할 수도 있다.</p>
</li>
<li>
<p>xml은 Bean을 직접 등록하는 방식</p>
</li>
<li>
<p>java코드 사용은 Bean을 팩토리 매서드로 등록하는 방식</p>
</li>
</ul>
<hr>
<h2 id="싱글톤-컨테이너">싱글톤 컨테이너</h2>
<h3 id="웹-어플리케이션과-싱글톤">웹 어플리케이션과 싱글톤</h3>
<ul>
<li>스프링을 적용하지 않은 DI컨테이너의 경우 요청 시마다 새로운 객체를 생성한다.<br>
-&gt; <strong>메모리 낭비</strong> 심함</li>
<li>스프링은 기본적으로 온라인 서비스 기술 지원이 주력이기에<br>
스프링 애플리케이션은 대부분 웹 어플리케이션이다.<br>
동시 요청이 잦은 웹 어플리케이션의 특성상 이는 치명적이다.<br>
-&gt; 이 해결을 위해 <strong>싱글톤</strong> 적용이 필요하다.</li>
</ul>
<h3 id="싱글톤-패턴">싱글톤 패턴</h3>
<ul>
<li>클래스의 인스턴스가 1개만 생성되게끔 보장하는 디자인 패턴</li>
<li>인스턴스를 2개 이상 생성하지 못하게 막음.</li>
<li>private 생성자를 이용, 외부에서 new 불가하게 함.</li>
</ul>
<pre class=" language-java"><code class="prism  language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SingletonService</span> <span class="token punctuation">{</span>  
  
    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> SingletonService instance <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SingletonService</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
 <span class="token keyword">public</span> <span class="token keyword">static</span> SingletonService <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  
        <span class="token keyword">return</span> instance<span class="token punctuation">;</span>  
  <span class="token punctuation">}</span>  
  
    <span class="token keyword">private</span> <span class="token function">SingletonService</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  
          
    <span class="token punctuation">}</span>  
      
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">logic</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"싱글톤 객체 로직 호출"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
  <span class="token punctuation">}</span>  
<span class="token punctuation">}</span>
</code></pre>
<ul>
<li>이 싱글톤 구현방식은 객체를 미리 생성해두는 가장 단순하고 안전한 방식이다.</li>
<li>static 영역에 객체 instance를 미리 하나 생성해서 올려둔다.</li>
<li>이 객체 인스턴스가 필요하면 오직 getInstatnce() 메소드를 통해서만 조회할 수 있음. 항상 같은 인스턴스 반환.</li>
<li>생성자를 private로 막아서 외부에서 new 키워드로 객체 인스턴스가 생성되는 것을 막음.</li>
<li>Same == 참조가 같음</li>
<li>Equal equals()와 같음</li>
<li>스프링 컨테이너는 기본적으로 객체를 싱글톤으로 관리한다.</li>
</ul>
<p><strong>싱글톤 패턴의 문제점</strong></p>
<ul>
<li>패턴 자체를 구현하기 위한 코드</li>
<li>의존관계상 클라이언트가 구체 클래스에 의존하게 됨<br>
-&gt; DIP를 위반, 때문에 OCP 위반 가능성 높아짐</li>
<li>유연한 테스트가 어려움</li>
<li>내부 속성을 변경하거나 초기화하기 어려움</li>
<li>private 생성자 사용으로 인해 자식 클래스를 만들기 어려움</li>
<li>즉, <strong>유연성이 떨어짐</strong></li>
<li>안티패턴으로 불리기도.</li>
</ul>
<h3 id="싱글톤-컨테이너-1">싱글톤 컨테이너</h3>
<ul>
<li>스프링 컨테이너는 객체를 싱글톤 방식으로 관리하며,<br>
이러한 객체 생성, 관리하는 기능을 <strong>싱글톤 레지스트리</strong>라 한다.</li>
<li>스프링 컨테이너는
<ul>
<li>싱글톤 패턴 구현을 위한 복잡한 코드가 불필요</li>
<li>DIP, OCP, 테스트, private 생성자로부터 자유롭게 싱글톤 사용 가능</li>
</ul>
</li>
</ul>
<h3 id="싱글톤-방식의-주의점">싱글톤 방식의 주의점</h3>
<p><strong>무상태(Stateless)로 설계해야 한다!</strong> 스프링 컨테이너를 이용한 싱글톤 방식에도 모두 해당하는 사항이다.</p>
<ul>
<li>특정 클라이언트에 의존적인 필드가 있어선 안 된다.</li>
<li>특정 클라이언트가 값을 변경할 수 있는 필드가 있으면 안 된다.</li>
<li>가급적 읽기만 가능해야 한다.</li>
<li>필드 대신에 자바에서 공유되지 않는, 지역변수, 파라미터, ThreadLocal 등을 사용해야 한다.</li>
<li>스프링 빈의 필드에 공유 값을 설정하면 큰 장애가 발생할 수 있다.</li>
</ul>
<pre class=" language-java"><code class="prism  language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">StatefulService</span> <span class="token punctuation">{</span>  
  
    <span class="token keyword">private</span> <span class="token keyword">int</span> price<span class="token punctuation">;</span> <span class="token comment">// 상태를 유지하는 필드  </span>
  
  <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">order</span><span class="token punctuation">(</span>String name<span class="token punctuation">,</span> <span class="token keyword">int</span> price<span class="token punctuation">)</span> <span class="token punctuation">{</span>  
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"name= "</span> <span class="token operator">+</span> name <span class="token operator">+</span> <span class="token string">" price= "</span> <span class="token operator">+</span> price<span class="token punctuation">)</span><span class="token punctuation">;</span>  
 <span class="token keyword">this</span><span class="token punctuation">.</span>price<span class="token operator">=</span>price<span class="token punctuation">;</span> <span class="token comment">// 문제 지점!  </span>
  <span class="token punctuation">}</span>  
  
    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">getPrice</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  
        <span class="token keyword">return</span> price<span class="token punctuation">;</span>  
  <span class="token punctuation">}</span>  
<span class="token punctuation">}</span>
</code></pre>
<p>일 때,</p>
<pre class=" language-java"><code class="prism  language-java"><span class="token keyword">class</span> <span class="token class-name">StatefulServiceTest</span> <span class="token punctuation">{</span>  
  
    <span class="token annotation punctuation">@Test</span>  
 <span class="token annotation punctuation">@DisplayName</span><span class="token punctuation">(</span><span class="token string">"stateful 경우"</span><span class="token punctuation">)</span>  
    <span class="token keyword">void</span> <span class="token function">statefulServiceSingleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  
        AnnotationConfigApplicationContext ac <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">AnnotationConfigApplicationContext</span><span class="token punctuation">(</span>TestConfig<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
  StatefulService statefulService1 <span class="token operator">=</span> ac<span class="token punctuation">.</span><span class="token function">getBean</span><span class="token punctuation">(</span>StatefulService<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
  StatefulService statefulService2 <span class="token operator">=</span> ac<span class="token punctuation">.</span><span class="token function">getBean</span><span class="token punctuation">(</span>StatefulService<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
  
  <span class="token comment">// ThreadA: userA가 10000 주문, userB가 20000 주문  </span>
  statefulService1<span class="token punctuation">.</span><span class="token function">order</span><span class="token punctuation">(</span><span class="token string">"userA"</span><span class="token punctuation">,</span> <span class="token number">10000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
  statefulService2<span class="token punctuation">.</span><span class="token function">order</span><span class="token punctuation">(</span><span class="token string">"userB"</span><span class="token punctuation">,</span> <span class="token number">20000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
  <span class="token comment">//statefulService's price 10000-&gt;20000  </span>
  
 <span class="token comment">// ThreadA: userA가 주문 금액 조회  </span>
  <span class="token function">assertThat</span><span class="token punctuation">(</span>statefulService1<span class="token punctuation">.</span><span class="token function">getPrice</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">isEqualTo</span><span class="token punctuation">(</span><span class="token number">20000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
  <span class="token punctuation">}</span>  
  
    <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">TestConfig</span> <span class="token punctuation">{</span>  
  
        <span class="token annotation punctuation">@Bean</span>  
  <span class="token keyword">public</span> StatefulService <span class="token function">statefulService</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  
            <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">StatefulService</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
  <span class="token punctuation">}</span>  
    <span class="token punctuation">}</span>  
<span class="token punctuation">}</span>
</code></pre>
<ul>
<li>실무의 경우 Thread 할당으로 인해 더 복잡해진다.</li>
<li>stateService의 price 필드는 공유되는 필드인데, 특정 클라이언트가 값을 변경했다.<br>
-&gt; <strong>반드시 무상태로 설계하라!</strong></li>
</ul>
<pre class=" language-java"><code class="prism  language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">StatefulService</span> <span class="token punctuation">{</span>  

  <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">order</span><span class="token punctuation">(</span>String name<span class="token punctuation">,</span> <span class="token keyword">int</span> price<span class="token punctuation">)</span> <span class="token punctuation">{</span>  
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"name= "</span> <span class="token operator">+</span> name <span class="token operator">+</span> <span class="token string">" price= "</span> <span class="token operator">+</span> price<span class="token punctuation">)</span><span class="token punctuation">;</span>  
 <span class="token keyword">return</span> price<span class="token punctuation">;</span>  
  <span class="token punctuation">}</span>  
<span class="token punctuation">}</span>
</code></pre>
<p>와</p>
<pre class=" language-java"><code class="prism  language-java">    <span class="token annotation punctuation">@Test</span>  
 <span class="token annotation punctuation">@DisplayName</span><span class="token punctuation">(</span><span class="token string">"stateful 경우"</span><span class="token punctuation">)</span>  
    <span class="token keyword">void</span> <span class="token function">statefulServiceSingleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  
        AnnotationConfigApplicationContext ac <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">AnnotationConfigApplicationContext</span><span class="token punctuation">(</span>TestConfig<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
  StatefulService statefulService1 <span class="token operator">=</span> ac<span class="token punctuation">.</span><span class="token function">getBean</span><span class="token punctuation">(</span>StatefulService<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
  StatefulService statefulService2 <span class="token operator">=</span> ac<span class="token punctuation">.</span><span class="token function">getBean</span><span class="token punctuation">(</span>StatefulService<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
  
  <span class="token comment">// ThreadA: userA가 10000 주문, userB가 20000 주문  </span>
  <span class="token keyword">int</span> userAPrice <span class="token operator">=</span> statefulService1<span class="token punctuation">.</span><span class="token function">order</span><span class="token punctuation">(</span><span class="token string">"userA"</span><span class="token punctuation">,</span> <span class="token number">10000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
 <span class="token keyword">int</span> userBPrice <span class="token operator">=</span> statefulService2<span class="token punctuation">.</span><span class="token function">order</span><span class="token punctuation">(</span><span class="token string">"userB"</span><span class="token punctuation">,</span> <span class="token number">20000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
  
 <span class="token comment">// ThreadA: userA가 주문 금액 조회  </span>
  <span class="token function">assertThat</span><span class="token punctuation">(</span>userAPrice<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">isEqualTo</span><span class="token punctuation">(</span><span class="token number">10000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
  <span class="token punctuation">}</span>  
  
    <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">TestConfig</span> <span class="token punctuation">{</span>  
  
        <span class="token annotation punctuation">@Bean</span>  
  <span class="token keyword">public</span> StatefulService <span class="token function">statefulService</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  
            <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">StatefulService</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
  <span class="token punctuation">}</span>  
    <span class="token punctuation">}</span>  
<span class="token punctuation">}</span>
</code></pre>
<p>경우 문제 해결된다.</p>
<h3 id="configuration과-싱글톤">@Configuration과 싱글톤</h3>
<pre class=" language-java"><code class="prism  language-java"><span class="token annotation punctuation">@Configuration</span>  
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">AppConfig</span> <span class="token punctuation">{</span>  
  
    <span class="token annotation punctuation">@Bean</span>  
  <span class="token keyword">public</span> MemberService <span class="token function">memberService</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  
        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">MemberServiceImpl</span><span class="token punctuation">(</span><span class="token function">memberRepository</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
  <span class="token punctuation">}</span>  
  
    <span class="token annotation punctuation">@Bean</span>  
  <span class="token keyword">public</span> MemberRepository <span class="token function">memberRepository</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  
        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">MemoryMemberRepository</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
  <span class="token punctuation">}</span>  
  
    <span class="token annotation punctuation">@Bean</span>  
  <span class="token keyword">public</span> OrderService <span class="token function">orderService</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  
        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">OrderServiceImpl</span><span class="token punctuation">(</span><span class="token function">memberRepository</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">discountPolicy</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
  <span class="token punctuation">}</span>  
  
    <span class="token annotation punctuation">@Bean</span>  
  <span class="token keyword">public</span> DiscountPolicy <span class="token function">discountPolicy</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  
        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">RateDiscountPolicy</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
  <span class="token punctuation">}</span>  
  
<span class="token punctuation">}</span>
</code></pre>
<p>에서<br>
@Bean memberService() -&gt; new MemoryMemberRepository()<br>
@Bean orderService() -&gt; new MemoryMemberRepository()<br>
인데, new 키워드가 두 번 나오는데 싱글톤이 깨지지 않을까?</p>
<blockquote>
<p>Call AppConfig.memberService<br>
Call AppConfig.memberRepository<br>
Call AppConfig.orderService<br>
Call AppConfig.discountPolicy</p>
</blockquote>
<p>깨지지 않으며, memberRepository 호출이 단 한번만 이루어졌음을 확인할 수 있다.</p>
<h3 id="configuration과-바이트코드-조작">@Configuration과 바이트코드 조작</h3>
<p>스프링은 자바 코드 자체를 조작하기는 어렵다. 그럼에도 위 사례에서 3회 호출이 이뤄져야 하는 것을 한 번만 이뤄지게 해서 싱글톤을 유지하게 한 방법은,<br>
스프링이 클래스의 <strong>바이트코드를 조작</strong>하는 라이브러리를 사용해서 이루어졌다.</p>
<p>AnnotationConfigApplicationContext ac를 생성한 이후에 Appconfig 클래스를 조회하니</p>
<blockquote>
<p><code>bean= class logos.springCore.AppConfig$$EnhancerBySpringCGLIB$$9911dcb1</code></p>
</blockquote>
<p>순수 클래스가 아니라 $$EnhancerBySpringCGLIB. . . 이 붙어서 출력된다.<br>
이는 스프링이 CGLIB이라는 바이트코드 조작 라이브러리를 조작하여 AppConfig 클래스를 상속받은 임의의 다른 클래스를 만들고 그것을 스프링 빈으로 등록한 것이다.<br>
@Bean이 붙은 메소드마다 이미 빈이 존재한다면 그것을 반환하고 없다면 기존 코드를 사용하여 생성, 등록, 반환하는 코드가 동적 생성된 것이다.</p>
<p>@Configuration이 빠질 경우 빈에 등록은 되지만 memberRepository 호출은 3회 이루어지고, 싱글톤은 깨진다.<br>
또한 이 경우 MemberService나 OrderService의 memberRepository는 빈에 등록되지 않는다.</p>
<hr>
<h2 id="컴포넌트-스캔">컴포넌트 스캔</h2>

