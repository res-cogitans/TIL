---


---

<h1 id="스프링-핵심-원리---기본편김영한">스프링 핵심 원리 - 기본편(김영한)</h1>
<h2 id="객체-지향-설계와-스프링">객체 지향 설계와 스프링</h2>
<p><strong>E</strong>nterprise <strong>J</strong>ava <strong>B</strong>eans: 자바 표준 기술<br>
EJB는 다수의 기능을 지원했지만, 사용하기 복잡하고 어려웠으며, 성능이 느렸다. 심지어 값비쌌음.<br>
EJB의 복잡성으로 인해 <strong>P</strong>lain <strong>O</strong>ld <strong>J</strong>ava <strong>O</strong>bject가 등장하기도 함.<br>
EJB의 문제 해결을 위해 대두한 오픈 소스 기술들: <strong>스프링, 하이버네이트</strong></p>
<p><strong>스프링</strong></p>
<ul>
<li>EJB 컨테이너 대체</li>
<li>단순함</li>
<li>현재 사실상 표준 기술</li>
</ul>
<p><strong>하이버네이트(Hibernate)</strong></p>
<ul>
<li>EJB 엔티티빈 기술을 대체</li>
<li><strong>J</strong>ava <strong>P</strong>ersistence <strong>A</strong>PI의 새로운 표준을 정의<br>
EJB 엔티티빈 -&gt; 하이버네이트 -&gt; JPA(자바표준)</li>
<li>표준 인터페이스 JPA와 그 구현체 (주로) 하이버네이트, EclipseLink 등</li>
</ul>
<p>-&gt; 현대 자바 개발자에게 가장 중요한 두 기술: <strong>스프링, 하이버네이트</strong></p>
<hr>
<h3 id="스프링의-역사">스프링의 역사</h3>
<p><strong>Rod Johnson, “J2EE Design and Development”(2002)</strong></p>
<ul>
<li>EJB의 문제점 지적</li>
<li>EJB 없이 제작한 애플리케이션 예시, 스프링 핵심 개념, 기반 코드</li>
<li><strong>BeanFactory, ApplicationContext, POJO, 제어의 역전, 의존관계 주입(DI)</strong></li>
<li>Juergen Hoeller, Yann Caroff가 오픈소스 프로젝트 제안, 개발</li>
<li>J2EE(EJB)-겨울을 넘어서 새로운 시작이라는 의미로 스프링</li>
</ul>
<p><strong>릴리즈</strong></p>
<ul>
<li>2003, 1.0 - Xml 기반</li>
<li>2006, 2.0 - Xml 편의기능</li>
<li>2009, 3.0 - 자바 코드로 설정(스프링은 설정이 매우 난해했음)</li>
<li>2013, 4.0 - 자바8</li>
<li>2014, 스프링부트 1.0</li>
<li>2017, 5.0, 부트 2.0 -리엑티브 프로그래밍 지원(비동기 NumBlocking Node.js유사</li>
<li>현재 5.2.x 부트 2.3x</li>
</ul>
<hr>
<h3 id="스프링이란">스프링이란?</h3>
<p>스프링은 단일 기술이 아니라 다수 기술의 모음</p>
<ul>
<li>핵심: 스프링 프레임워크, 스프링 부트</li>
<li>선택:
<ul>
<li>스프링 데이터: DB사용을 도움, ex) 스프링데이터 Jpa</li>
<li>스프링 세션</li>
<li>스프링 시큐리티</li>
<li>스프링 Rest Docs(API문서화, 테스트)</li>
<li>스프링 배치</li>
<li>스프링 클라우드</li>
<li>etc . . . (공식 사이트의 project 참조)</li>
</ul>
</li>
</ul>
<p><strong>스프링 프레임워크</strong></p>
<ul>
<li>핵심 기술: 스프링 DI 컨테이너, AOP, 이벤트, 기타</li>
<li>웹 기술: 스프링 MVC, 스프링 WebFlux</li>
<li>데이터 접근 기술: 트랜젝션, JDBC, ORM 지원, XML 지원</li>
<li>기술 통합: 캐시, 이메일, 원격접근, 스케줄링</li>
<li>테스트: 스프링 기반 테스트 지원</li>
<li>언어: 코틀린, 그루비</li>
<li>스프링 부트를 통해서 스프링 / 스프링 프레임워크의 기술들을 편리하게 사용 가능.</li>
</ul>
<p><strong>스프링 부트</strong></p>
<ul>
<li>단독 실행 가능한 스프링 애플리케이션을 쉽게 생성</li>
<li>Tomcat 같은 웹 서버를 내장, 별도의 웹 서버 설치 불필요.</li>
<li>손쉬운 빌드 구성을 위한 starter 종속성 제공(라이브러리 종속성 관리 build.gradle 참조)</li>
<li>스프링과 3rd party(외부) 라이브러리 자동 구성(버전당 써드파티 라이브러리 호환성 관리)</li>
<li>메트릭, 상태 확인, 외부 구성 같은 프로덕션 준비 기능 제공(모니터링 환경)</li>
<li>관례에 의한 간결한 설정(디폴트 설정 + 메뉴얼이 잘 되어있음)</li>
</ul>
<p><strong>스프링이라는 단어</strong></p>
<ul>
<li>스프링 DI 컨테이너 기술</li>
<li>스프링 프레임워크</li>
<li><strong>스프링 생태계 전체</strong></li>
</ul>
<p><strong>스프링의 제작 이유 - 핵심 개념</strong></p>
<ul>
<li><strong>자바</strong> 기반 프레임워크: <strong>객체 지향</strong></li>
<li>스프링은 <strong>좋은 객체 지향</strong> 애플리케이션 개발을 돕는 프레임워크</li>
<li>그것을 돕는 <strong>DI 컨테이너</strong></li>
</ul>
<hr>
<h3 id="좋은-객체-지향-프로그래밍">좋은 객체 지향 프로그래밍</h3>
<p><strong>다형성(Polymorphism)</strong></p>
<ul>
<li>객체지향 프로그래밍이 컴포넌트 교체 등으로 인해 <strong>단순, 유연, 변경 용이</strong>하게 만드는 이유.</li>
<li>자동차의 예시) 개별 자동차들이 자동차라는 인터페이스의 구현체이기에, 무한히 확장 가능하며(<strong>확장 가능한 설계</strong>), 운전자에게 영향을 주지 않아도 됨.</li>
<li><strong>역할</strong>과 <strong>구현</strong>을 분리해서 가능한 것!</li>
</ul>
<p><strong>역할과 구현의 분리</strong></p>
<ul>
<li>클라이언트는
<ul>
<li>대상의 역할(인터페이스)만 알면 된다.</li>
<li>대상의 내부 구조를 몰라도 된다.</li>
<li>대상의 내부 구조가 변경되어도 영향 받지 않는다.</li>
<li>구현 대상 자체가 변경되어도 영향 받지 않는다.<br>
-&gt; <strong>추상화, 캡슐화</strong> 등과도 일맥상통.</li>
</ul>
</li>
<li>자바 언어의 다형성:
<ul>
<li>역할 = 인터페이스</li>
<li>구현 = 구현 클래스, 객체</li>
</ul>
</li>
<li>객체 설계시 역할과 구현의 분리</li>
<li>역할(인터페이스)를 먼저 부여하고, 그것의 구현체를 만들어야.</li>
</ul>
<p><strong>객체의 협력</strong></p>
<ul>
<li>객체는 협력관계
<ul>
<li>클라이언트는 요청, 서버는 응답</li>
<li>이런 구조는 중첩될 수도 있다.</li>
</ul>
</li>
</ul>
<p><strong>자바 언어의 다형성 - 오버라이딩</strong></p>
<ul>
<li>다형성으로 인터페이스를 구현한 객체를 실행 시점에 유연하게 변경 가능</li>
<li>클래스 상속 관계에서도 마찬가지</li>
<li>예시: 클라이언트는 MemberRepository에 의존(인식), 이 MemberRepository 자리에 여러 구현체들로 역할 구현 가능.</li>
<li><strong>클라이언트를 변경하지 않고, 서버의 구현 기능을 유연하게 변경 가능.</strong></li>
</ul>
<p><strong>한계점</strong></p>
<ul>
<li>역할 자체의 변화가 발생시 큰 변경 발생.<br>
-&gt; <strong>인터페이스의 설계 중요성</strong></li>
</ul>
<p><strong>스프링과 객체 지향</strong></p>
<ul>
<li><strong>제어의 역전(IoC), 의존관계 주입(DI)</strong> 등은 <strong>다형성</strong>을 활용하여 <strong>역할</strong>과 <strong>구현</strong>을 편리하게 다룰 수 있게 지원함.</li>
</ul>
<hr>
<h3 id="solid-원칙">SOLID 원칙</h3>
<p><strong>SOLID</strong>: 로버트 마틴(클린 코드)가 정리한 좋은 객체 지향 설계의 5원칙</p>
<ul>
<li><strong>SRP</strong>: 단일 책임 원칙(<strong>S</strong>ingle <strong>R</strong>esponsibility <strong>P</strong>rinciple)</li>
<li><strong>OCP</strong>: 개방-폐쇄 원칙(<strong>O</strong>pen/<strong>C</strong>losed <strong>P</strong>rinciple)</li>
<li><strong>LSP</strong>: 리스코프 치환 원칙(<strong>L</strong>iskov <strong>S</strong>ubstitution <strong>P</strong>rinciple)</li>
<li><strong>ISP</strong>: 인터페이스 분리 원칙(<strong>I</strong>nterface <strong>S</strong>egregation <strong>P</strong>rinciple)</li>
<li><strong>DIP</strong>: 의존관계 분리 원칙(<strong>D</strong>ependency <strong>I</strong>nversion <strong>P</strong>rinciple)</li>
</ul>
<p><strong>SRP 단일 책임 원칙</strong>(<strong>S</strong>ingle <strong>R</strong>esponsibility <strong>P</strong>rinciple)</p>
<ul>
<li>한 클래스는 하나의 책임만 가져야 한다.</li>
<li>이 범위를 적절히 조절하는 것이 핵심.</li>
<li>중요한 기준은 <strong>변경</strong>, 변경 시 파급 효과가 적다면 이 원칙을 잘 따른 것.</li>
</ul>
<p><strong>OCP 개방-폐쇄 원칙</strong>(<strong>O</strong>pen/<strong>C</strong>losed <strong>P</strong>rinciple)</p>
<ul>
<li>소프트웨어 요소는 <strong>확장에는 열려</strong> 있으나 <strong>변경에는 닫혀</strong> 있어야 한다.</li>
<li>인터페이스의 새 구현체를 만들어서 새로운 기능을 구현<br>
<strong>문제점</strong>
<ul>
<li>MemberService 클라이언트가 구현 클래스를 직접 선택</li>
<li><code>MemberRepository m = new MemoryMemberRepository();</code>에서</li>
<li><code>MemberRepository m = new JdbcMemberRepository();</code>로 변경</li>
<li>구현 객체를 변경하려면 클라이언트 코드를 변경해야 함.</li>
<li><strong>다형성을 사용했으나, OCP를 지키지 못함.</strong></li>
<li><strong>해결</strong>:객체를 생성하고, 연관관계를 맺어주는 별도의 조립, 설정자가 필요.<br>
-&gt; <strong>스프링의 필요</strong></li>
</ul>
</li>
</ul>
<p><strong>LSP 리스코프 치환 원칙</strong>(<strong>L</strong>iskov <strong>S</strong>ubstitution <strong>P</strong>rinciple)</p>
<ul>
<li>프로그램의 객체는 프로그램의 정확성을 깨뜨리지 않으면서 하위 타입의 인스턴스로 바꿀 수 있어야 한다.</li>
<li>다형성에서 하위 클래스는 인터페이스 규약을 다 지켜야 한다는 것.</li>
</ul>
<p><strong>ISP 인터페이스 분리 원칙</strong>(<strong>I</strong>nterface <strong>S</strong>egregation <strong>P</strong>rinciple)</p>
<ul>
<li>특정 클라이언트를 위한 인터페이스 여러 개가 범용 인터페이스 하나보다 낫다. -&gt; <strong>쪼개라</strong></li>
<li>인터페이스가 명확해지고 대체 가능성이 높아진다.</li>
</ul>
<p><strong>DIP 의존관계 분리 원칙</strong>(<strong>D</strong>ependency <strong>I</strong>nversion <strong>P</strong>rinciple)</p>
<ul>
<li><strong>"프로그래머는 추상화에 의존해야지 구체화에 의존하면 안 된다."</strong></li>
<li>구현에 의존하지 말고 <strong>역할(인터페이스)에 의존</strong>하라, 구현이 아닌 역할을 알게끔 하라.<br>
<strong>위반사례</strong>
<ul>
<li>클래스 MemberService의 코드 <code>MemberRepository m = new MemoryMemberRepository();</code>의 경우</li>
<li>인터페이스 MemberRepository 뿐만 아니라 MemoryMemberRepository 구현체에도 동시 의존한다.</li>
<li>클라이언트가 구현 클래스를 직접 선택하고 있음.</li>
</ul>
</li>
</ul>
<p><strong>정리</strong><br>
다형성 만으로는</p>
<ul>
<li>클라이언트 코드 변경 없이 구현체의 유연한 교체가 불가능하다!</li>
<li>OCP, DIP를 지킬 수 없다.<br>
-&gt; 스프링의 필요성</li>
</ul>
<hr>
<h3 id="객체-지향-설계와-스프링-1">객체 지향 설계와 스프링</h3>
<p>스프링이 <strong>다형성 + OCP, DIP</strong> 가능하게 지원하는 수단</p>
<ul>
<li>DI: 의존관계, 의존성 주입</li>
<li>DI 컨테이너 제공</li>
<li>순수 자바로 객체지향적 개발을 하려면 생산성이 낮음<br>
-&gt; 스프링 프레임워크의 등장.</li>
</ul>
<p><strong>정리</strong></p>
<ul>
<li>설계와 구현의 분리</li>
<li><strong>이상적으로, 모든 설계에 인터페이스를 부여하라.</strong></li>
<li><strong>현실적으로, 인터페이스 남발은 추상화 비용(생산성)이 발생</strong><br>
때문에 기능 확장 가능성이 없을 때는 구체적 클래스를 사용하고 필요할 때 리팩토링으로 인터페이스를 도입하는 방법을 고려.</li>
</ul>

