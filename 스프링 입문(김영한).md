# 스프링 입문(김영한)
## 프로젝트 환경설정
### build.gradle
- 버전 설정 / 라이브러리 가져오는 역할 (세부사항은 추후공부하는 편이 나음)

```java
repositories {  
  mavenCentral()  
}  
  
dependencies {  
  implementation 'org.springframework.boot:spring-boot-starter-thymeleaf'  
  implementation 'org.springframework.boot:spring-boot-starter-web'  
  testImplementation 'org.springframework.boot:spring-boot-starter-test'  
}
```
- 라이브러리들을 mavenCentral에서 다운로드.



### gitignore
- git에 올릴 것, 안 올릴 것 분리


### External Libraries
- gradle/maven은 라이브러리 의존관계를 관리해준다.
- 이전에는 WAS를 서버에 설치, 사용, 거기에 java 코드를 넣는 식으로 했었지만, 지금은 이렇게 tomcat을 embedded 시켜서 개발 라이브러리와 분리하지 않고 개발이 가능하다. 라이브러리를 빌드하여 웹서버에 빌드하는 식.
- slf4j인터페이스, logback로그의 구현체 출력
 
## 스프링 웹 개발 기초
- 정적 컨텐츠: 파일을 그대로 웹 브라우저에 전달
- MVC/템플릿엔진: 서버 내에서 html을 변형하여 전달
- API: json 데이퍼 포맷으로 전달, 서버간 통신

### 정적 컨텐츠
1. 웹 브라우저에서 localhost8080:hello-static html요청
2. 스프링 컨테이너 내에는 매핑된 컨트롤러 없음
3. resources의 static에서 hello-static.html찾아서 웹브라우저로 전달

### MVC와 템플릿 엔진
- Model1: Controller와 View가 구별되지 않았음(View가 전담)
요청 전체를 JSP가 처리한다.
- Model2: MVC방식, 요청은 서블릿, 서블릿이 View와 Model로 구별전달

```java
@GetMapping("registerMvc")  
public String registerMvc(@RequestParam(value = "name", required = false) String name, Model model) {  
    model.addAttribute("name", name);  
 return "registerTemplate";
 ``` 
 - required 값이 true면(기본값) null 불가.
 - ?name=parameter 식으로 인자 전달.
 1. localhost8080/registerMvc?name=parameter 요청
 2. 해당 컨트롤러가 name값을 모델에 담고(RequstParam으로 name은 parameter가 됨), registerTemplate 리턴값전달.
 3. viewResolver에서 templates/registerTemplate.html을 Thymeleaf템플릿 엔진으로 처리, 변환 후의 html을 웹 브라우저로 전달.

### API
### 방식1
```java
@GetMapping("registerString")  
@ResponseBody  
public String registerString(@RequestParam(value = "message") String message, Model model) {  
    return message;  
}
```
- viewResolver를 거치지 않고 바로 String 형태 리턴값은 message만 띄움.

### 방식2
```java
@GetMapping("registerApi")  
@ResponseBody  
public Responser registerApi(@RequestParam(value = "name") String name,  
  @RequestParam(value = "id") int id) {  
    Responser responser = new Responser();  
  responser.name = name;  
  responser.id = id;  
 return responser;  
}
```
- 객체 responser를 전달함.
- getter/setter는 자바빈 표준으로, 프로퍼티 접근 방식이라고도 함
- @ResponseBody에 객체리턴이면 기본적으로 Json 포맷. (Xml은 레거시)
- @RequsetParam은 위와 같이 각 인자별로 붙여서 웹 요청 매개변수를 다수 받을수도 있음.
- @RequestParam값을 둘 이상 전달할 때는
```
http://localhost:8080/registerApi?name=programmer&id=256
```
과 같이 ?값1&값2 하는 식으로 이어나갈 수 있다.

1. 웹 브라우저가 http://localhost:8080/registerApi?name=programmer&id=256 요청
2. @ResponseBoby가 있기에 컨트롤러는 viewResolver로 넘기지 않음.
	responser(name=programmer, id=256)을 HttpMessageConverter로 전달
	객체가 반환값이기에 Json 포맷으로 전달함.
3. HttpMessageConverter는
	단순 문자일 경우 StringConverter(기본은 StringHttpMessageConverter)
	객체일 경우 JsonConverter(기본은 MappingJackson2HttpMessageConverter)
	로 처리, 웹 브라우저로 전달.

## 회원 관리 예제 - 백엔드 개발
- MemberRepository를 인터페이스로 만들고, MemoryMemberRepository로 구현 -> 현재 저장소 구현을 선택하지 않았고, 메모리로 간단하게 구현해보려 하는 경우
```java
public class MemoryMemberRepository implements MemberRepository {  
  
    private static Map<Long, Member> store =new HashMap<>();  
 private static long sequence = 0L;  
  
  @Override  
  public Member save(Member member) {  
        member.setId(++sequence);  
  store.put(member.getId(), member);  
 return member;  
  }  
  
    @Override  
  public Optional<Member> findById(Long id) {  
        return Optional.ofNullable(store.get(id));  
  }  
  
    @Override  
  public Optional<Member> findByName(String name) {  
        return store.values().stream()  
                .filter(member -> member.getName().equals(name))  
                .findAny();  
  
  }  
  
    @Override  
  public List<Member> findAll() {  
        return new ArrayList<>(store.values());  
  }  
}

// domain.Member
public class Member {  
  
    private Long id;
    ...
    }
```
- Member의 id와 findById에서 Long을 사용한 까닭은, long과 달리 Long은 Nullable이라서다. new Member()처럼 객체생성시에는 id값이 없어야 하는데, 그 경우 id를 null로 표현해야 하는 상황이 생김.

### 왜 new HashMap store를 Map<>으로 선언했나?
- 게시판 질문내용 발췌:
> 1. Map 인터페이스의 제약을 따르겠다는 의도를 명확하게 드러냅니다.
> 2. 사용하는 코드가 Map 인터페이스 제약을 따르기 때문에 향후 변경시에 사용코드를 변경하지 않아도 됩니다.
> 3. HashMap을 다른 클래스로 변경이 필요하면 선언하는 코드만 변경하면 됩니다. 사용하는 코드를 고민하지 않아도 됩니다.
> 4. 다른 개발자들이 이 코드를 나중에 더 성능이 좋거나 동시성 처리가 가능한 종류의 구체적인 Map으로 변경해야 할 때 HashMap store = new HashMap()이라고 되어 있다면, 변경 시점에 상당히 많은 고민을 해야 하지만 Map store = new HashMap()으로 선언이 되어 있다면 편안하게 선언부를 변경할 수 있습니다.
> 5. 개발은 무의미한 자유도를 제공하는 것 보다, 제약을 부여하는 것이 혼란을 줄이고, 유지보수하기 쉽습니다.
> 6. 만약 정말 HashMap의 구체적인 기능을 사용해야 한다면 HashMap store = new HashMap() 이라고 선언하는 것이 맞습니다.

- 의존성 주입: 
```java
class MemberRepository {
	
	private Map store;
	
	public MemberRepository(Map store) {
		this.store =store
	}
}
```
그리고 외부에서:
```java
new MemberRepository(new HashMap());

new MemberRepository(new ConcurrentHashMap());
```
> 이렇게 해서 MemberRepository를 전혀 변경하지 않고, 외부에서 구현 객체를 생성해서 파라미터로 넘길 수 있습니다.

### 테스트케이스 작성(메모리저장소)
- 테스트클래스를 run 하여 테스트 전체를 돌릴 수 있음.

```java
@Test  
public void findByName() {  
    Member member2 = new Member();  
  member2.setName("tMember2");  
  repository.save(member2);  
  
  Member member3 = new Member();  
  member3.setName("tMember3");  
  repository.save(member3);  
  
  Member result2 = repository.findByName("tMember2").get();  
  
  assertThat(result2).isEqualTo(member2);  
}
```
- 또, 다수의 테스트를 돌리는 경우 테스트 간 의존관계 없게 하기 위해 각 테스트 시행 이후(@AfterEach) 저장소 클리어 작업을 해줘야 한다. 
	(@AfterEach callBack 메소드 작성)
- 테스트 주도 개발(Test-driven development, TDD): 테스트 케이스 작성 이후 그것을 기반으로 개발을 진행하는 것
 
### 서비스 로직

```java
public Long join(Member member) {  
    // 중복회원금지  
  Optional<Member> result =   
            memberRepository.findByName(member.getName());  
  result.ifPresent(m -> {  
        throw new IllegalStateException("이미 존재하는 회원입니다.");  
  });  
  memberRepository.save(member);  
 return member.getId();  
}
```
그런데 findByName의 리턴형은 어차피 Optional이기 때문에 다음과 같이 축약표현을 사용할 수도 있다:

```java
    public Long join(Member member) {  
        // 중복회원금지  
  memberRepository.findByName(member.getName())  
                .ifPresent(m -> {  
            throw new IllegalStateException("이미 존재하는 회원입니다.");  
  });  
  memberRepository.save(member);  
 return member.getId();  
  }  
}
```
result변수를 할당할 필요 없고, 명확하다.
그런데 중복회원검증절차는 별도의 로직이기에, 따로 메소드를 뽑아내는 편이 좋다. (Shift + Ctrl + Alt + T, 리팩토링 기능)

```java
public Long join(Member member) {  
    // 중복회원금지  
  validateDuplicateMember(member);  
  memberRepository.save(member);  
 return member.getId();  
}  
  
private void validateDuplicateMember(Member member) {  
    memberRepository.findByName(member.getName())  
            .ifPresent(m -> {  
        throw new IllegalStateException("이미 존재하는 회원입니다.");  
  });  
}
```
이렇게 리팩토링 가능하다.

### 테스트케이스 작성(서비스)
- Shift +Ctrl + T = 테스트 쉽게 작성
- 테스트 코드의 경우 메소드의 이름 등을 한글로 작성해도 괜찮다. (직관성)
- 테스트의경우 given~ when~ then~ 형식으로 작성하면 명료하게 확인가능.
 
```java
@Test  
void 중복_회원_예외() {  
    //given  
  Member member1 = new Member();  
  member1.setName("testMember1");  
  
  Member member2 = new Member();  
  member2.setName("testMember1");  
  
  //when  
  memberService.join(member1);  
  
  //then  
  try {  
        memberService.join(member2);  
  fail();  
  }   catch (IllegalStateException e) {  
        assertThat(e.getMessage()).isEqualTo("이미 존재하는 회원입니다.");  
  }  
}
```
- 중복회원로직 검증.(Try~Catch이용)

```java
  void 중복_회원_예외() {  
      //given  
  Member member1 = new Member();  
  member1.setName("testMember1");  
  
  Member member2 = new Member();  
  member2.setName("testMember1");  
  
  //when  
  memberService.join(member1);  
  assertThrows(IllegalStateException.class, () -> memberService.join(member2));  
  
  //then
  }
  ```
  - assertThrows 이용. 이를 에러메시지까지 검증하는 형태로 바꾼다면:

```java
void 중복_회원_예외() {  
    //given  
  Member member1 = new Member();  
  member1.setName("testMember1");  
  
  Member member2 = new Member();  
  member2.setName("testMember1");  
  
  //when  
  memberService.join(member1);  
  IllegalStateException e = assertThrows(IllegalStateException.class, () -> memberService.join(member2));  
  
  assertThat(e.getMessage()).isEqualTo("이미 존재하는 회원입니다.");
  }
  ```
  와 같이 e.getMessage를 이용한다,


**의존성주입(Dependency Injection, DI)**
```java
MemberService memberService = new MemberService();  
MemoryMemberRepository memoryMemberRepository = new MemoryMemberRepository();
```
이며
```java
public class MemberService {  
  
    private final MemberRepository memberRepository = new MemoryMemberRepository();
    ...
 }
 ```
일 때, memberService객체는 new memberRepository를 따로 생성하기에
memoryMemberRepository와 memberRepostiory는 서로 다른 인스턴스.
이 경우에는
```java
public class MemoryMemberRepository implements MemberRepository {  
  
    private static Map<Long, Member> store =new HashMap<>();
	...   
}
```
즉 store가 static 이기에 문제가 발생하지 않지만, store 외의 영역에서 문제가 발생할 수도 있으며, 굳이 MemberMemberRepository 인스턴스를 두 번 생성할 필요가 없는 상황이다.
이 경우,

```java
public class MemberService {  
  
    private final MemberRepository memberRepository;  
 public MemberService(MemberRepository memberRepository) {  
        this.memberRepository = memberRepository;  
  }
}
```
그리고
```java
MemoryMemberRepository memoryMemberRepository = new MemoryMemberRepository();  
MemberService memberService = new MemberService(memoryMemberRepository);
```
로 변경하여, 단일 memberRepository를 사용하게 할 수 있다.

그리고 테스트케이스기에 이를 @BeforeEach 이용하여,
```java
MemoryMemberRepository memoryMemberRepository;  
MemberService memberService;  
  
  
@BeforeEach  
public void beforeEach() {  
    memoryMemberRepository = new MemoryMemberRepository();  
  memberService = new MemberService(memoryMemberRepository);  
}
```
하면, 매 테스트 생성마다 새로 생성, 사용 가능.

## 스프링 빈과 의존관계
**스프링 빈을 등록하는 2가지 방법:**
**1. 컴포넌트 스캔과 자동 의존관계 설정**
- @ Component: 애노테이션이 있으면 스프링 빈으로 자동 등록됨.
- 스프링 빈은 기본적으로 싱글톤 방식으로 스프링 컨테이너에 등록됨.
	@Controller, @Service, @Repository 등.
- 멤버 컨트롤러의 @Autowired(멤버서비스 DI하는 생성자)
	멤버 서비스의 @Autowired(멤버리포지토리 DI하는 생성자)를 통하여
	스프링 컨테이너에 
	`memberController->memberService->memberRepository`
	 식으로 의존관계 설정

**2. 자바 코드로 직접 스프링 빈 등록**

<!--stackedit_data:
eyJoaXN0b3J5IjpbMTM0NjkwMzk0MywtMTkyMjM4OTM3NSwtMj
E3NzE3Njc2LC00MDY0OTUyNDUsLTE0NTU1NTcwNywxNzAyNTA5
MjY4LDYzNjM4MjEwMiwxODA3MzgzNzk2XX0=
-->