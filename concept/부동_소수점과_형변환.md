# 부동소수점과 형변환

- [codelatte.io](http://codelatte.io) 참조

## 실수(부동소수점 방식)의 표현법

- 부동소수점 방식은 근사값이기에, 실제 값과는 오차가 존재한다는 점에 유의해야 한다!

                  부호비트(most significiant bit)
                  
                        ↑

### 실수 32.0    0 000010 0      000 0000  0000 0000  0000 0000

   4byte(32bit)             ↓                                               ↓

                 지수부(Exponent) 8bit              지수부(Mantissa) 23bit

## 2의보수

### 정수 32    0000 0000 0000 0000   0000 0000 0010 0000

                                      ↓  비트를 반전

### 1의 보수  1111 1111 1111 1111 1111  1111 1111 1101 1111

### +1  0000 0000 0000 0000  0000 0000 0000 0001

### 2의 보수 1111 1111 1111 1111  1111 1111 1110 0000

## 상수, 형변환

- 리터럴: 10, 25.7, true 등 "값"
- 심볼릭: final 붙은 변수

### 변수 저장방식

- int a = 50
    - int(4byte)에 50(리터럴, 4byte)을 대입함. 리터럴 50은 일시적으로 메모리를 차지하고, 대입 후 해제된다.

- short b = 90
    - 대입 리터럴 90은 4byte 사이즈. 앞의 2byte를 잘라내고 short b 에 대입.
- long c = 200000000000000L
    - long 사이즈의 경우 L을 명시. JVM은 정수 리터럴 4byte로 다루기에.
- double d = 10.2
    - 8byte 크기 리터럴 10.2를 대입. 실수 리터럴은 8byte가 기본이다.
- float e = 10.2f
    - long 처럼 명시가 필요하다(4byte)

### 5.1265798F와 5.1265798은 다른 값이다

## 형변환

- 암시적 형변환(Implicit Conversion, Automatic -)
- 명시적 형변환(Explicit Conversion)

    - double(8byte)  > float(4byte) > long(8byte) > int(4byte) > short/char(2byte) > byte(1byte)
    - (typeA) a 이고 (typeB) b일때, typeA a = b 대입 연산을 시도한다면,

     A타입이 B타입보다 좌측에 있을 경우 암시적 형변환되며, 반대의 경우 명시적 형변환이 필요.

    (대입값이 온전히 보존되지 않을 수 있는 경우 명시가 필요하다.)

    - 실수→정수 형변환의 경우 변질가능성이 존재한다.
    - long은 float 자료형보다 메모리 차지가 크지만 long인 b에 대하여 float a = b는 암시적 형변환이 가능하다. 메모리 크기가 아닌 값의 표현 범위가 기준이기 때문이다.

    ### 정수의 형변환

    - 암시적 형변환의 경우 앞부분에 padding을 붙임.
    - 명시적 형변환의 경우 앞의 비트부터 잘려나가게 됨.
    - long a = 1 → 이 경우 4바이트로 표현된 1에 padding이 붙어서 암시적 형변환 후  a에 저장

### 암시적 형변환 - 연산

- 정수형 끼리의 연산은 int로 암시적 형변환된다. 이를 피하고 싶을 경우 명시적 형변환이 필요.
- float과 int의 경우, float형으로, double과 int의 경우 double로 암시적 형변환.