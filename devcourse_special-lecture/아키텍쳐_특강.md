# 아키텍쳐 특강



예시: 안드로이드 폰의 아키텍처

- 어플리케이션 계층

- 어플리케이션 프레임워크

- 라이브러리/안드로이드 런타임

- 리눅스 커널



라이브러리: 개발자들이 쉽게 리눅스 커널을 다룰 수 있게끔

애플리케이션 프레임워크: 액티비티 매니저, 윈도우 매니저, 패키지 매니저, 뷰 프로그램 ,로케이션 매니저 등

어플리케이션 : 우리가 사용하는 앱들: 홈, 브라우저, 전화등



### 아키텍트(Architect)

 Robert Martin의 Clean Architecture 참고!

**아키텍트에게는 무엇이 필요할까?**

- 기초적인 지식들

- 프로그래밍 언어에 숙련
  - 어떤 언어를 쓸 지 추천해 줄 수 있어야 함
- 개발 전반을 진두지휘
  - 리더십/코칭 능력 필요

- 아키텍처는 코드로만 구성되는게 아니고
  - 네트워크, 스토리지 등 여러가지로 구성되는 작업이다.
  - 물리적으로 무엇을 사용할 것인지 (머신)
  - 인프라스트럭처에 대한 이해
- 때문에 많은 경험을 요한다.



### Modern Architecture

- 주어진 환경에 가장 적합하게 구현해야 한다.

- Modern -> 여기서는 (현재 시점에서) 활용할 수 있다는 의미로 이해하자.

  - 세부적인 최적화 작업은 개발자들의 유지보수를 어렵게 하는 측면이 있다.

  - 과거 어셈블리어로 코딩하던 사람들을 생각해보자.

  - 만일 클라이언트들의 PC 사양이 높다면 그렇게 하는 것 보다는 재사용성 좋게 만들게

    -> 그래서 C로 코딩하는 사람은 이제 적다

  - 임베디드 분야라면 최적화가 필요할 테니까.

    -> 그러니 C/C++만 쓴다.

    ​	-> 아키텍트가 언어에 대한 이해가 높아야 할 이유

- **Standalone**
  - 그 프로그램이 이 안에서 정해진 기능을 수행한다.
    - ex) 계산기, 과거의 컴퓨터: ENIAC 등도 이런 종류
  - Distributed
    - 여러 곳에 분산되서 작동
    - ex) DBMS, 최초의 Distributed: 원격 저장소
  - Monolithic(과거에는 레이어드 아키텍처라고 불렀었음)
    - 모놀리틱은 단일한 + 돌멩이라는 어원(μονόλιθος)이라고 하네요.. 돌 하나가 강하게 모여 있는 것처럼 하나의 어플리케이션이 완저히 결합된 하나라는 의미인가보다.
  - Microservices(MSA)
    - 모놀리틱을 분할
  - Event-Driven(EDA)
    - 역할의 분산



### 무엇이 아키텍쳐 변화를 유발하는가?

#### 시대적 요구

- 요구되는 자원과 능력capacities)
- 스케일과 안정성
- 역할과 책임
- 자율αὐτόνομος: 사용자





#### 환경적 요구

- enhanced computing power
  - IBM -> 메인 프레임이라는 컴퓨터(작은 양문형 냉장고급)-당시에는 소형 이걸 만들어서 대박침, 원래 키보드나 만들던 놈
    - 엄청난 변화
  - UNIX, PC, Linux, and Intel
  - 컴퓨터 성능의 급격한 발전

- 네트워크
  - TCP / UDP
- 인터넷 -> HTTP
- Machine friendly protocols
  - SOAP(프로토콜)
  - RESTful
    - 해커 그룹에서 제안: 무거운 프로토콜 말고 가벼운 걸 쓰자



**더 빠른 개발 모델(아키텍처 모델)이 요구된다!**

- 단일 모듈 작업이 너무 커지니, 충돌이 발생하기 쉬워짐

  - 작업을 매번 동기화한다는 것은 효율성이 안 좋다

- 특정 Contract에 기반하여 각자의 서비스 모듈을 개발 -> 마이크소서비스

  - 하지만 문제는 여전하다.

  - 오히려 분산 환경에서 문제가 생기면 중앙관리가 안 됨

    -> EDD

- EDD
  - 서로를 보지 말고 이벤트에 의해 생성된 데이터만 본다
  - 마치 함수형 프로그래밍처럼



- 현 시점에서는 다음 정도를 고려할 만하겠다.

  - 모놀리틱
  - MSA
  - EDA
  - Serverless
    - 데브옵스의 부흥을 일으키는 중

  

### 모놀리틱

- 단일 어플리케이션은 모든 제반 기능들을 제공한다.

- 빠른 개발, 빠른 검증: 스타트업의 예를 생각해보자.

- μονό- (monó-, “mono-”) +‎ λίθος (líthos, “stone”) 돌멩이 하나를 깎아 만드는 것과 같음
  - 각 부품들을 따로 조립해서 만든다면
  - 한 부분에 천둥이 떨어져서 돌이 갈라진다고 해도 그 부분만 갈아 끼우면 되는데
  - 대리석 한 덩어리로 만든 조각상의 경우 복구가 힘들 것이다.

- 모놀리틱은 기술 부채를 일으키는 아키텍처



### MSA

- 역할과 책임
- 각 파트별로 역할을 나누고, 거기에 맞는 자원 할당이 가능
  - 조회만 트래픽이 높다면 그 쪽에 리소스를 더 할당하는 식으로

- 적절한 제어 -> 개발의 자율성

- MSA의 계층들: 마틴 파울러가 얘기했던 것

  - Service

  - Business Capabilities: 각자가 vaule를 만들어 내는 역할

  - Product(!Project): 독립적인 어플리케이션들이 연쇄되어 가치를 생성해내는 것을 프로덕트

    - 이 프로덕트는 생명주기를 가진다. 유지, 발전... 반복되다가 사용되지 않으면 끝

  - Endpoints

    - 어떻게 다른 프로덕트와 상호작용하는가

  - Decentralized Governance

    - 획일적인 수단으로 통일시키지 않는다
    - 일부는 Go, 일부는 자바 쓰는 식으로

  - Decentralized Data

    - 종속적이지 않은 데이터
    - 어플리케이션이 얼마나 나뉘어 있다 하더라도
    - 매우 거대한 단일 DB를 쓴다면 .. 망한다!
      - 다른 서비스의 데이터를 참조할 수 있다:
        - 남의 데이터를 조인하고 ...
      - 라이엇은 모든 DB가 하나 참조하니까 5년 걸렸다 ...

  - Infrastructure Automation

    - 빠르게 개발하기 위함

  - Design for failure

    - 문제에 대응할 수 있는 방안
    - MSA는 트랜잭션이 없다.
      - 단위 프로덕트에서는 트랜잭션을 한다
      - A->B성공(남음)->C(실패)
      - 이럴 때는 어떻게 할 것인지
    - 트랜잭션이 전체 흐름을 통제하면 MSA의 설계 철학과 맞지 않아서?

  - Evolutionary Design

    - scale up -> 너무 돈 든다.
      - 대표적으로 DBMS: 데이터가 많이 쌓이면?

    - scale down -> 고려해보라

    - 초기 단계에 이런 문제에 대한 고려, 중간 변화에 대한 설계 등이 필요하다.

- 중요 포인트: 엔드포인트는 어떻게 할 것이냐?
  - 주니어를 벗어나는 척도
  - HTTP 프로토콜
    - 엔드포인트 정의를 통해 액션, 리소스 식별 가능



#### MSA가 부여해 주는 자유도

- 어떤 언어/프레임워크의 설정 등 -> 팀의 높은 자유도
- 실패에 대응하기 위해 중요한 것
  - 잘게 쪼개진 것들을 묶어서 볼 수 있는 하나의 체계: 규정
  - 보편적으로 강제되어야 함

- R&R은 탈 중앙화하지만, 매니지먼트는 중앙화하라
  - kibana 등의 통합 로그 툴

- 위의 탈 집중화와는 다르다.
  - 이것 또한 하나의 역할이자 책임 아닐까





### EDA

- 데이터/이벤트에 주도되는(driven) 서비스들/ 사이의 낮은 결합도

일련의 작업은 크게 흐름으로 볼 수 있음

위 제어 흐름에 따라서 별도로

A->WorkA

B->WorkB 별도로 하지만

그것들은 side-effect가 없다.



### 서버리스

- 클라우드 서비스 사용하여 managing cost를 줄인다.
  - EC2등의 환경에서 구동
    - 가상화 장비
    - 그러나 물리적 장치의 연장선
    - 관리가 필요하다!
      - ex) Disk Pull !! 꽤나 흔한 사례



### 단계에 맞는 아키텍처

규모에 따라, 적절한 타이밍에

모놀리틱/서버리스 -> MSA -> EDA  레벨로 발전

중간에 필요에 따라 전환할 계획 등을 가지고 있어야 한다.

- 기술 부채를 적절히 해결할 수 있어야 한다.



### Q&A / 기타

- 문1: 스프링 부트와 MSA
  - 경력자들의 경우 대기업에서는 MSA 경험이 특히 필요하다.
  - 주니어 레벨에서 모놀리틱에 집중할 지? MSA와 함께 병행을 할지? 무엇이 추천할만한가?

- 답: 스프링부트는 당연히 중요하지만, MSA개념을 벌써 공부하는 것은 추천하고 싶지 않다.

  - 여러분의 직무는 서비스 개발이다.
  - 작은 것을 만들어보는 경험이 더 중요하다.
  - **MSA에 관해서는 오히려 엔드포인트를 잘 정의하는 것이 개발자로서 더 필요한 것이다. 특히 백엔드**
    - 예시: 차량에 대한 **RESTful Endpoint를 정의해봐라!**
    - GET/api/v1/car/111-X-7811/HTTP/1.1 처럼
      - https://app.sli.do/event/4zUnCjKWWZC6EmwRFxvDMN/live/questions
      - API 명세
    - HTTP 응답 메서드를 잘못 사용: GET 써야 하는데 POST

  - 일정 경력을 쌓은 이후에 아키텍트에 challenge 해봐라.
  - **성장 의지를 핵심으로 봐 왔다. 지식보다는 이게 더 중요**
  - **또 중요한건 코드를 "잘 짜려고"하는지**

- 문2: 항상 물어보는 질문
- 답: 가장 인상깊었던 과목(전공불문)

- 문3: 신입 DevOps 가능?

- 답: 신입 말고는 백엔드 이후 전환이 적절하다.
  - 시스템 엔지니어 입사는 있어도, 데브옵스 엔지니어 입사는 없다.

- 문4: 성장의지를 위한 질문

- 답: 코드를 직접 짜라고 물어본다: 가장 직접적인 방법

- 문5: 회사 고를 때 무엇을 봐야?

- 답: 연봉 봐라! + 조직 문화:

  - 그런데, 회사 문화와 개발조직 문화는 또 다르다.

  - 첫 직장은 마지막 직장이 아닐 것이다. 성장을 이끌어줄 수 있는 직장이냐. (연봉 만큼이나 중요한 조건)

    4년이 지나고 연봉이 당신의 진짜 연봉이다.

  - 마지막으로, 회사는 최악의 상황이 아닌 이상 2년 이내로 이직하지 마라.

    - 때려칠거면 6개월 이내로 때려쳐라.

- 문6: TDD 잘 배우려면
- 답: 커버리지 100퍼센트를 목적으로 만들어 봐라
  - 분명 마지막에 남은 무언가가 있을 것이다. 그것을 테스트 할 수 있게끔 해 보라: 리팩토링 하라!
  - 꼭 테스트만 먼저 짜고 개발하고 식의 공부할 필요는 없다.
    - 테스트 커버리지 100퍼센트 짜는 것에 성공하다 보면 테스트 먼저 짜고 개발하는 실력이 생긴다.
- 문7: 개발자 지망생에게 알려주고 싶은 서적
- 답: 자바 할거면 자바 인 모션, GoF, design pattern distiled

- 문8: TDD
- 답: mocking 해라, 그래야 단순해진다. 통합 테스트가 아니라 단위 테스트 해야한다.
  - 상위로 갈수록 복잡해진다면 리팩토링과 구조화가 필요하다.